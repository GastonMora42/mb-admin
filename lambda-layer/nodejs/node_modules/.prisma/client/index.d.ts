
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Alumno
 * 
 */
export type Alumno = $Result.DefaultSelection<Prisma.$AlumnoPayload>
/**
 * Model ConfiguracionPagoAlumno
 * 
 */
export type ConfiguracionPagoAlumno = $Result.DefaultSelection<Prisma.$ConfiguracionPagoAlumnoPayload>
/**
 * Model Descuento
 * 
 */
export type Descuento = $Result.DefaultSelection<Prisma.$DescuentoPayload>
/**
 * Model DescuentoAplicado
 * 
 */
export type DescuentoAplicado = $Result.DefaultSelection<Prisma.$DescuentoAplicadoPayload>
/**
 * Model Deuda
 * 
 */
export type Deuda = $Result.DefaultSelection<Prisma.$DeudaPayload>
/**
 * Model PagoDeuda
 * 
 */
export type PagoDeuda = $Result.DefaultSelection<Prisma.$PagoDeudaPayload>
/**
 * Model Concepto
 * 
 */
export type Concepto = $Result.DefaultSelection<Prisma.$ConceptoPayload>
/**
 * Model Recibo
 * 
 */
export type Recibo = $Result.DefaultSelection<Prisma.$ReciboPayload>
/**
 * Model Estilo
 * 
 */
export type Estilo = $Result.DefaultSelection<Prisma.$EstiloPayload>
/**
 * Model AlumnoEstilos
 * 
 */
export type AlumnoEstilos = $Result.DefaultSelection<Prisma.$AlumnoEstilosPayload>
/**
 * Model Profesor
 * 
 */
export type Profesor = $Result.DefaultSelection<Prisma.$ProfesorPayload>
/**
 * Model CtaCte
 * 
 */
export type CtaCte = $Result.DefaultSelection<Prisma.$CtaCtePayload>
/**
 * Model CajaDiaria
 * 
 */
export type CajaDiaria = $Result.DefaultSelection<Prisma.$CajaDiariaPayload>
/**
 * Model Clase
 * 
 */
export type Clase = $Result.DefaultSelection<Prisma.$ClasePayload>
/**
 * Model Asistencia
 * 
 */
export type Asistencia = $Result.DefaultSelection<Prisma.$AsistenciaPayload>
/**
 * Model AlumnoSuelto
 * 
 */
export type AlumnoSuelto = $Result.DefaultSelection<Prisma.$AlumnoSueltoPayload>
/**
 * Model Liquidacion
 * 
 */
export type Liquidacion = $Result.DefaultSelection<Prisma.$LiquidacionPayload>
/**
 * Model DetalleLiquidacion
 * 
 */
export type DetalleLiquidacion = $Result.DefaultSelection<Prisma.$DetalleLiquidacionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TipoPago: {
  EFECTIVO: 'EFECTIVO',
  MERCADO_PAGO: 'MERCADO_PAGO',
  TRANSFERENCIA: 'TRANSFERENCIA',
  DEBITO_AUTOMATICO: 'DEBITO_AUTOMATICO',
  OTRO: 'OTRO'
};

export type TipoPago = (typeof TipoPago)[keyof typeof TipoPago]


export const EstadoLiquidacion: {
  PENDIENTE: 'PENDIENTE',
  PAGADA: 'PAGADA',
  ANULADA: 'ANULADA'
};

export type EstadoLiquidacion = (typeof EstadoLiquidacion)[keyof typeof EstadoLiquidacion]

}

export type TipoPago = $Enums.TipoPago

export const TipoPago: typeof $Enums.TipoPago

export type EstadoLiquidacion = $Enums.EstadoLiquidacion

export const EstadoLiquidacion: typeof $Enums.EstadoLiquidacion

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Alumnos
 * const alumnos = await prisma.alumno.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Alumnos
   * const alumnos = await prisma.alumno.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.alumno`: Exposes CRUD operations for the **Alumno** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alumnos
    * const alumnos = await prisma.alumno.findMany()
    * ```
    */
  get alumno(): Prisma.AlumnoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.configuracionPagoAlumno`: Exposes CRUD operations for the **ConfiguracionPagoAlumno** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConfiguracionPagoAlumnos
    * const configuracionPagoAlumnos = await prisma.configuracionPagoAlumno.findMany()
    * ```
    */
  get configuracionPagoAlumno(): Prisma.ConfiguracionPagoAlumnoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.descuento`: Exposes CRUD operations for the **Descuento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Descuentos
    * const descuentos = await prisma.descuento.findMany()
    * ```
    */
  get descuento(): Prisma.DescuentoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.descuentoAplicado`: Exposes CRUD operations for the **DescuentoAplicado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DescuentoAplicados
    * const descuentoAplicados = await prisma.descuentoAplicado.findMany()
    * ```
    */
  get descuentoAplicado(): Prisma.DescuentoAplicadoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deuda`: Exposes CRUD operations for the **Deuda** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deudas
    * const deudas = await prisma.deuda.findMany()
    * ```
    */
  get deuda(): Prisma.DeudaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pagoDeuda`: Exposes CRUD operations for the **PagoDeuda** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PagoDeudas
    * const pagoDeudas = await prisma.pagoDeuda.findMany()
    * ```
    */
  get pagoDeuda(): Prisma.PagoDeudaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.concepto`: Exposes CRUD operations for the **Concepto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conceptos
    * const conceptos = await prisma.concepto.findMany()
    * ```
    */
  get concepto(): Prisma.ConceptoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recibo`: Exposes CRUD operations for the **Recibo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recibos
    * const recibos = await prisma.recibo.findMany()
    * ```
    */
  get recibo(): Prisma.ReciboDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.estilo`: Exposes CRUD operations for the **Estilo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estilos
    * const estilos = await prisma.estilo.findMany()
    * ```
    */
  get estilo(): Prisma.EstiloDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alumnoEstilos`: Exposes CRUD operations for the **AlumnoEstilos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AlumnoEstilos
    * const alumnoEstilos = await prisma.alumnoEstilos.findMany()
    * ```
    */
  get alumnoEstilos(): Prisma.AlumnoEstilosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profesor`: Exposes CRUD operations for the **Profesor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profesors
    * const profesors = await prisma.profesor.findMany()
    * ```
    */
  get profesor(): Prisma.ProfesorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ctaCte`: Exposes CRUD operations for the **CtaCte** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CtaCtes
    * const ctaCtes = await prisma.ctaCte.findMany()
    * ```
    */
  get ctaCte(): Prisma.CtaCteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cajaDiaria`: Exposes CRUD operations for the **CajaDiaria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CajaDiarias
    * const cajaDiarias = await prisma.cajaDiaria.findMany()
    * ```
    */
  get cajaDiaria(): Prisma.CajaDiariaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clase`: Exposes CRUD operations for the **Clase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clases
    * const clases = await prisma.clase.findMany()
    * ```
    */
  get clase(): Prisma.ClaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.asistencia`: Exposes CRUD operations for the **Asistencia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Asistencias
    * const asistencias = await prisma.asistencia.findMany()
    * ```
    */
  get asistencia(): Prisma.AsistenciaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alumnoSuelto`: Exposes CRUD operations for the **AlumnoSuelto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AlumnoSueltos
    * const alumnoSueltos = await prisma.alumnoSuelto.findMany()
    * ```
    */
  get alumnoSuelto(): Prisma.AlumnoSueltoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.liquidacion`: Exposes CRUD operations for the **Liquidacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Liquidacions
    * const liquidacions = await prisma.liquidacion.findMany()
    * ```
    */
  get liquidacion(): Prisma.LiquidacionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.detalleLiquidacion`: Exposes CRUD operations for the **DetalleLiquidacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DetalleLiquidacions
    * const detalleLiquidacions = await prisma.detalleLiquidacion.findMany()
    * ```
    */
  get detalleLiquidacion(): Prisma.DetalleLiquidacionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.2.1
   * Query Engine version: 4123509d24aa4dede1e864b46351bf2790323b69
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Alumno: 'Alumno',
    ConfiguracionPagoAlumno: 'ConfiguracionPagoAlumno',
    Descuento: 'Descuento',
    DescuentoAplicado: 'DescuentoAplicado',
    Deuda: 'Deuda',
    PagoDeuda: 'PagoDeuda',
    Concepto: 'Concepto',
    Recibo: 'Recibo',
    Estilo: 'Estilo',
    AlumnoEstilos: 'AlumnoEstilos',
    Profesor: 'Profesor',
    CtaCte: 'CtaCte',
    CajaDiaria: 'CajaDiaria',
    Clase: 'Clase',
    Asistencia: 'Asistencia',
    AlumnoSuelto: 'AlumnoSuelto',
    Liquidacion: 'Liquidacion',
    DetalleLiquidacion: 'DetalleLiquidacion'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "alumno" | "configuracionPagoAlumno" | "descuento" | "descuentoAplicado" | "deuda" | "pagoDeuda" | "concepto" | "recibo" | "estilo" | "alumnoEstilos" | "profesor" | "ctaCte" | "cajaDiaria" | "clase" | "asistencia" | "alumnoSuelto" | "liquidacion" | "detalleLiquidacion"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Alumno: {
        payload: Prisma.$AlumnoPayload<ExtArgs>
        fields: Prisma.AlumnoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlumnoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlumnoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoPayload>
          }
          findFirst: {
            args: Prisma.AlumnoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlumnoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoPayload>
          }
          findMany: {
            args: Prisma.AlumnoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoPayload>[]
          }
          create: {
            args: Prisma.AlumnoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoPayload>
          }
          createMany: {
            args: Prisma.AlumnoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlumnoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoPayload>[]
          }
          delete: {
            args: Prisma.AlumnoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoPayload>
          }
          update: {
            args: Prisma.AlumnoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoPayload>
          }
          deleteMany: {
            args: Prisma.AlumnoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlumnoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlumnoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoPayload>[]
          }
          upsert: {
            args: Prisma.AlumnoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoPayload>
          }
          aggregate: {
            args: Prisma.AlumnoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlumno>
          }
          groupBy: {
            args: Prisma.AlumnoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlumnoGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlumnoCountArgs<ExtArgs>
            result: $Utils.Optional<AlumnoCountAggregateOutputType> | number
          }
        }
      }
      ConfiguracionPagoAlumno: {
        payload: Prisma.$ConfiguracionPagoAlumnoPayload<ExtArgs>
        fields: Prisma.ConfiguracionPagoAlumnoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfiguracionPagoAlumnoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionPagoAlumnoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfiguracionPagoAlumnoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionPagoAlumnoPayload>
          }
          findFirst: {
            args: Prisma.ConfiguracionPagoAlumnoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionPagoAlumnoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfiguracionPagoAlumnoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionPagoAlumnoPayload>
          }
          findMany: {
            args: Prisma.ConfiguracionPagoAlumnoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionPagoAlumnoPayload>[]
          }
          create: {
            args: Prisma.ConfiguracionPagoAlumnoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionPagoAlumnoPayload>
          }
          createMany: {
            args: Prisma.ConfiguracionPagoAlumnoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConfiguracionPagoAlumnoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionPagoAlumnoPayload>[]
          }
          delete: {
            args: Prisma.ConfiguracionPagoAlumnoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionPagoAlumnoPayload>
          }
          update: {
            args: Prisma.ConfiguracionPagoAlumnoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionPagoAlumnoPayload>
          }
          deleteMany: {
            args: Prisma.ConfiguracionPagoAlumnoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConfiguracionPagoAlumnoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConfiguracionPagoAlumnoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionPagoAlumnoPayload>[]
          }
          upsert: {
            args: Prisma.ConfiguracionPagoAlumnoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionPagoAlumnoPayload>
          }
          aggregate: {
            args: Prisma.ConfiguracionPagoAlumnoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfiguracionPagoAlumno>
          }
          groupBy: {
            args: Prisma.ConfiguracionPagoAlumnoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfiguracionPagoAlumnoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConfiguracionPagoAlumnoCountArgs<ExtArgs>
            result: $Utils.Optional<ConfiguracionPagoAlumnoCountAggregateOutputType> | number
          }
        }
      }
      Descuento: {
        payload: Prisma.$DescuentoPayload<ExtArgs>
        fields: Prisma.DescuentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DescuentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DescuentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DescuentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DescuentoPayload>
          }
          findFirst: {
            args: Prisma.DescuentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DescuentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DescuentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DescuentoPayload>
          }
          findMany: {
            args: Prisma.DescuentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DescuentoPayload>[]
          }
          create: {
            args: Prisma.DescuentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DescuentoPayload>
          }
          createMany: {
            args: Prisma.DescuentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DescuentoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DescuentoPayload>[]
          }
          delete: {
            args: Prisma.DescuentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DescuentoPayload>
          }
          update: {
            args: Prisma.DescuentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DescuentoPayload>
          }
          deleteMany: {
            args: Prisma.DescuentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DescuentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DescuentoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DescuentoPayload>[]
          }
          upsert: {
            args: Prisma.DescuentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DescuentoPayload>
          }
          aggregate: {
            args: Prisma.DescuentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDescuento>
          }
          groupBy: {
            args: Prisma.DescuentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<DescuentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.DescuentoCountArgs<ExtArgs>
            result: $Utils.Optional<DescuentoCountAggregateOutputType> | number
          }
        }
      }
      DescuentoAplicado: {
        payload: Prisma.$DescuentoAplicadoPayload<ExtArgs>
        fields: Prisma.DescuentoAplicadoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DescuentoAplicadoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DescuentoAplicadoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DescuentoAplicadoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DescuentoAplicadoPayload>
          }
          findFirst: {
            args: Prisma.DescuentoAplicadoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DescuentoAplicadoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DescuentoAplicadoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DescuentoAplicadoPayload>
          }
          findMany: {
            args: Prisma.DescuentoAplicadoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DescuentoAplicadoPayload>[]
          }
          create: {
            args: Prisma.DescuentoAplicadoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DescuentoAplicadoPayload>
          }
          createMany: {
            args: Prisma.DescuentoAplicadoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DescuentoAplicadoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DescuentoAplicadoPayload>[]
          }
          delete: {
            args: Prisma.DescuentoAplicadoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DescuentoAplicadoPayload>
          }
          update: {
            args: Prisma.DescuentoAplicadoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DescuentoAplicadoPayload>
          }
          deleteMany: {
            args: Prisma.DescuentoAplicadoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DescuentoAplicadoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DescuentoAplicadoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DescuentoAplicadoPayload>[]
          }
          upsert: {
            args: Prisma.DescuentoAplicadoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DescuentoAplicadoPayload>
          }
          aggregate: {
            args: Prisma.DescuentoAplicadoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDescuentoAplicado>
          }
          groupBy: {
            args: Prisma.DescuentoAplicadoGroupByArgs<ExtArgs>
            result: $Utils.Optional<DescuentoAplicadoGroupByOutputType>[]
          }
          count: {
            args: Prisma.DescuentoAplicadoCountArgs<ExtArgs>
            result: $Utils.Optional<DescuentoAplicadoCountAggregateOutputType> | number
          }
        }
      }
      Deuda: {
        payload: Prisma.$DeudaPayload<ExtArgs>
        fields: Prisma.DeudaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeudaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeudaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeudaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeudaPayload>
          }
          findFirst: {
            args: Prisma.DeudaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeudaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeudaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeudaPayload>
          }
          findMany: {
            args: Prisma.DeudaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeudaPayload>[]
          }
          create: {
            args: Prisma.DeudaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeudaPayload>
          }
          createMany: {
            args: Prisma.DeudaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeudaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeudaPayload>[]
          }
          delete: {
            args: Prisma.DeudaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeudaPayload>
          }
          update: {
            args: Prisma.DeudaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeudaPayload>
          }
          deleteMany: {
            args: Prisma.DeudaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeudaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeudaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeudaPayload>[]
          }
          upsert: {
            args: Prisma.DeudaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeudaPayload>
          }
          aggregate: {
            args: Prisma.DeudaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeuda>
          }
          groupBy: {
            args: Prisma.DeudaGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeudaGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeudaCountArgs<ExtArgs>
            result: $Utils.Optional<DeudaCountAggregateOutputType> | number
          }
        }
      }
      PagoDeuda: {
        payload: Prisma.$PagoDeudaPayload<ExtArgs>
        fields: Prisma.PagoDeudaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PagoDeudaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoDeudaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PagoDeudaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoDeudaPayload>
          }
          findFirst: {
            args: Prisma.PagoDeudaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoDeudaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PagoDeudaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoDeudaPayload>
          }
          findMany: {
            args: Prisma.PagoDeudaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoDeudaPayload>[]
          }
          create: {
            args: Prisma.PagoDeudaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoDeudaPayload>
          }
          createMany: {
            args: Prisma.PagoDeudaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PagoDeudaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoDeudaPayload>[]
          }
          delete: {
            args: Prisma.PagoDeudaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoDeudaPayload>
          }
          update: {
            args: Prisma.PagoDeudaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoDeudaPayload>
          }
          deleteMany: {
            args: Prisma.PagoDeudaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PagoDeudaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PagoDeudaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoDeudaPayload>[]
          }
          upsert: {
            args: Prisma.PagoDeudaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoDeudaPayload>
          }
          aggregate: {
            args: Prisma.PagoDeudaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePagoDeuda>
          }
          groupBy: {
            args: Prisma.PagoDeudaGroupByArgs<ExtArgs>
            result: $Utils.Optional<PagoDeudaGroupByOutputType>[]
          }
          count: {
            args: Prisma.PagoDeudaCountArgs<ExtArgs>
            result: $Utils.Optional<PagoDeudaCountAggregateOutputType> | number
          }
        }
      }
      Concepto: {
        payload: Prisma.$ConceptoPayload<ExtArgs>
        fields: Prisma.ConceptoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConceptoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConceptoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptoPayload>
          }
          findFirst: {
            args: Prisma.ConceptoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConceptoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptoPayload>
          }
          findMany: {
            args: Prisma.ConceptoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptoPayload>[]
          }
          create: {
            args: Prisma.ConceptoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptoPayload>
          }
          createMany: {
            args: Prisma.ConceptoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConceptoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptoPayload>[]
          }
          delete: {
            args: Prisma.ConceptoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptoPayload>
          }
          update: {
            args: Prisma.ConceptoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptoPayload>
          }
          deleteMany: {
            args: Prisma.ConceptoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConceptoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConceptoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptoPayload>[]
          }
          upsert: {
            args: Prisma.ConceptoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptoPayload>
          }
          aggregate: {
            args: Prisma.ConceptoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConcepto>
          }
          groupBy: {
            args: Prisma.ConceptoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConceptoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConceptoCountArgs<ExtArgs>
            result: $Utils.Optional<ConceptoCountAggregateOutputType> | number
          }
        }
      }
      Recibo: {
        payload: Prisma.$ReciboPayload<ExtArgs>
        fields: Prisma.ReciboFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReciboFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReciboPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReciboFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReciboPayload>
          }
          findFirst: {
            args: Prisma.ReciboFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReciboPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReciboFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReciboPayload>
          }
          findMany: {
            args: Prisma.ReciboFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReciboPayload>[]
          }
          create: {
            args: Prisma.ReciboCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReciboPayload>
          }
          createMany: {
            args: Prisma.ReciboCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReciboCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReciboPayload>[]
          }
          delete: {
            args: Prisma.ReciboDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReciboPayload>
          }
          update: {
            args: Prisma.ReciboUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReciboPayload>
          }
          deleteMany: {
            args: Prisma.ReciboDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReciboUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReciboUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReciboPayload>[]
          }
          upsert: {
            args: Prisma.ReciboUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReciboPayload>
          }
          aggregate: {
            args: Prisma.ReciboAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecibo>
          }
          groupBy: {
            args: Prisma.ReciboGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReciboGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReciboCountArgs<ExtArgs>
            result: $Utils.Optional<ReciboCountAggregateOutputType> | number
          }
        }
      }
      Estilo: {
        payload: Prisma.$EstiloPayload<ExtArgs>
        fields: Prisma.EstiloFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EstiloFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstiloPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EstiloFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstiloPayload>
          }
          findFirst: {
            args: Prisma.EstiloFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstiloPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EstiloFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstiloPayload>
          }
          findMany: {
            args: Prisma.EstiloFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstiloPayload>[]
          }
          create: {
            args: Prisma.EstiloCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstiloPayload>
          }
          createMany: {
            args: Prisma.EstiloCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EstiloCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstiloPayload>[]
          }
          delete: {
            args: Prisma.EstiloDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstiloPayload>
          }
          update: {
            args: Prisma.EstiloUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstiloPayload>
          }
          deleteMany: {
            args: Prisma.EstiloDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EstiloUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EstiloUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstiloPayload>[]
          }
          upsert: {
            args: Prisma.EstiloUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstiloPayload>
          }
          aggregate: {
            args: Prisma.EstiloAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstilo>
          }
          groupBy: {
            args: Prisma.EstiloGroupByArgs<ExtArgs>
            result: $Utils.Optional<EstiloGroupByOutputType>[]
          }
          count: {
            args: Prisma.EstiloCountArgs<ExtArgs>
            result: $Utils.Optional<EstiloCountAggregateOutputType> | number
          }
        }
      }
      AlumnoEstilos: {
        payload: Prisma.$AlumnoEstilosPayload<ExtArgs>
        fields: Prisma.AlumnoEstilosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlumnoEstilosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoEstilosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlumnoEstilosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoEstilosPayload>
          }
          findFirst: {
            args: Prisma.AlumnoEstilosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoEstilosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlumnoEstilosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoEstilosPayload>
          }
          findMany: {
            args: Prisma.AlumnoEstilosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoEstilosPayload>[]
          }
          create: {
            args: Prisma.AlumnoEstilosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoEstilosPayload>
          }
          createMany: {
            args: Prisma.AlumnoEstilosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlumnoEstilosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoEstilosPayload>[]
          }
          delete: {
            args: Prisma.AlumnoEstilosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoEstilosPayload>
          }
          update: {
            args: Prisma.AlumnoEstilosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoEstilosPayload>
          }
          deleteMany: {
            args: Prisma.AlumnoEstilosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlumnoEstilosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlumnoEstilosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoEstilosPayload>[]
          }
          upsert: {
            args: Prisma.AlumnoEstilosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoEstilosPayload>
          }
          aggregate: {
            args: Prisma.AlumnoEstilosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlumnoEstilos>
          }
          groupBy: {
            args: Prisma.AlumnoEstilosGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlumnoEstilosGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlumnoEstilosCountArgs<ExtArgs>
            result: $Utils.Optional<AlumnoEstilosCountAggregateOutputType> | number
          }
        }
      }
      Profesor: {
        payload: Prisma.$ProfesorPayload<ExtArgs>
        fields: Prisma.ProfesorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfesorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfesorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload>
          }
          findFirst: {
            args: Prisma.ProfesorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfesorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload>
          }
          findMany: {
            args: Prisma.ProfesorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload>[]
          }
          create: {
            args: Prisma.ProfesorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload>
          }
          createMany: {
            args: Prisma.ProfesorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfesorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload>[]
          }
          delete: {
            args: Prisma.ProfesorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload>
          }
          update: {
            args: Prisma.ProfesorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload>
          }
          deleteMany: {
            args: Prisma.ProfesorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfesorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfesorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload>[]
          }
          upsert: {
            args: Prisma.ProfesorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesorPayload>
          }
          aggregate: {
            args: Prisma.ProfesorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfesor>
          }
          groupBy: {
            args: Prisma.ProfesorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfesorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfesorCountArgs<ExtArgs>
            result: $Utils.Optional<ProfesorCountAggregateOutputType> | number
          }
        }
      }
      CtaCte: {
        payload: Prisma.$CtaCtePayload<ExtArgs>
        fields: Prisma.CtaCteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CtaCteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CtaCtePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CtaCteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CtaCtePayload>
          }
          findFirst: {
            args: Prisma.CtaCteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CtaCtePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CtaCteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CtaCtePayload>
          }
          findMany: {
            args: Prisma.CtaCteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CtaCtePayload>[]
          }
          create: {
            args: Prisma.CtaCteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CtaCtePayload>
          }
          createMany: {
            args: Prisma.CtaCteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CtaCteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CtaCtePayload>[]
          }
          delete: {
            args: Prisma.CtaCteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CtaCtePayload>
          }
          update: {
            args: Prisma.CtaCteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CtaCtePayload>
          }
          deleteMany: {
            args: Prisma.CtaCteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CtaCteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CtaCteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CtaCtePayload>[]
          }
          upsert: {
            args: Prisma.CtaCteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CtaCtePayload>
          }
          aggregate: {
            args: Prisma.CtaCteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCtaCte>
          }
          groupBy: {
            args: Prisma.CtaCteGroupByArgs<ExtArgs>
            result: $Utils.Optional<CtaCteGroupByOutputType>[]
          }
          count: {
            args: Prisma.CtaCteCountArgs<ExtArgs>
            result: $Utils.Optional<CtaCteCountAggregateOutputType> | number
          }
        }
      }
      CajaDiaria: {
        payload: Prisma.$CajaDiariaPayload<ExtArgs>
        fields: Prisma.CajaDiariaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CajaDiariaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CajaDiariaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CajaDiariaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CajaDiariaPayload>
          }
          findFirst: {
            args: Prisma.CajaDiariaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CajaDiariaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CajaDiariaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CajaDiariaPayload>
          }
          findMany: {
            args: Prisma.CajaDiariaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CajaDiariaPayload>[]
          }
          create: {
            args: Prisma.CajaDiariaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CajaDiariaPayload>
          }
          createMany: {
            args: Prisma.CajaDiariaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CajaDiariaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CajaDiariaPayload>[]
          }
          delete: {
            args: Prisma.CajaDiariaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CajaDiariaPayload>
          }
          update: {
            args: Prisma.CajaDiariaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CajaDiariaPayload>
          }
          deleteMany: {
            args: Prisma.CajaDiariaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CajaDiariaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CajaDiariaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CajaDiariaPayload>[]
          }
          upsert: {
            args: Prisma.CajaDiariaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CajaDiariaPayload>
          }
          aggregate: {
            args: Prisma.CajaDiariaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCajaDiaria>
          }
          groupBy: {
            args: Prisma.CajaDiariaGroupByArgs<ExtArgs>
            result: $Utils.Optional<CajaDiariaGroupByOutputType>[]
          }
          count: {
            args: Prisma.CajaDiariaCountArgs<ExtArgs>
            result: $Utils.Optional<CajaDiariaCountAggregateOutputType> | number
          }
        }
      }
      Clase: {
        payload: Prisma.$ClasePayload<ExtArgs>
        fields: Prisma.ClaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClasePayload>
          }
          findFirst: {
            args: Prisma.ClaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClasePayload>
          }
          findMany: {
            args: Prisma.ClaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClasePayload>[]
          }
          create: {
            args: Prisma.ClaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClasePayload>
          }
          createMany: {
            args: Prisma.ClaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClasePayload>[]
          }
          delete: {
            args: Prisma.ClaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClasePayload>
          }
          update: {
            args: Prisma.ClaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClasePayload>
          }
          deleteMany: {
            args: Prisma.ClaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClasePayload>[]
          }
          upsert: {
            args: Prisma.ClaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClasePayload>
          }
          aggregate: {
            args: Prisma.ClaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClase>
          }
          groupBy: {
            args: Prisma.ClaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClaseCountArgs<ExtArgs>
            result: $Utils.Optional<ClaseCountAggregateOutputType> | number
          }
        }
      }
      Asistencia: {
        payload: Prisma.$AsistenciaPayload<ExtArgs>
        fields: Prisma.AsistenciaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AsistenciaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsistenciaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AsistenciaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsistenciaPayload>
          }
          findFirst: {
            args: Prisma.AsistenciaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsistenciaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AsistenciaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsistenciaPayload>
          }
          findMany: {
            args: Prisma.AsistenciaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsistenciaPayload>[]
          }
          create: {
            args: Prisma.AsistenciaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsistenciaPayload>
          }
          createMany: {
            args: Prisma.AsistenciaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AsistenciaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsistenciaPayload>[]
          }
          delete: {
            args: Prisma.AsistenciaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsistenciaPayload>
          }
          update: {
            args: Prisma.AsistenciaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsistenciaPayload>
          }
          deleteMany: {
            args: Prisma.AsistenciaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AsistenciaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AsistenciaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsistenciaPayload>[]
          }
          upsert: {
            args: Prisma.AsistenciaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsistenciaPayload>
          }
          aggregate: {
            args: Prisma.AsistenciaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAsistencia>
          }
          groupBy: {
            args: Prisma.AsistenciaGroupByArgs<ExtArgs>
            result: $Utils.Optional<AsistenciaGroupByOutputType>[]
          }
          count: {
            args: Prisma.AsistenciaCountArgs<ExtArgs>
            result: $Utils.Optional<AsistenciaCountAggregateOutputType> | number
          }
        }
      }
      AlumnoSuelto: {
        payload: Prisma.$AlumnoSueltoPayload<ExtArgs>
        fields: Prisma.AlumnoSueltoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlumnoSueltoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoSueltoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlumnoSueltoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoSueltoPayload>
          }
          findFirst: {
            args: Prisma.AlumnoSueltoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoSueltoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlumnoSueltoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoSueltoPayload>
          }
          findMany: {
            args: Prisma.AlumnoSueltoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoSueltoPayload>[]
          }
          create: {
            args: Prisma.AlumnoSueltoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoSueltoPayload>
          }
          createMany: {
            args: Prisma.AlumnoSueltoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlumnoSueltoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoSueltoPayload>[]
          }
          delete: {
            args: Prisma.AlumnoSueltoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoSueltoPayload>
          }
          update: {
            args: Prisma.AlumnoSueltoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoSueltoPayload>
          }
          deleteMany: {
            args: Prisma.AlumnoSueltoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlumnoSueltoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlumnoSueltoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoSueltoPayload>[]
          }
          upsert: {
            args: Prisma.AlumnoSueltoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlumnoSueltoPayload>
          }
          aggregate: {
            args: Prisma.AlumnoSueltoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlumnoSuelto>
          }
          groupBy: {
            args: Prisma.AlumnoSueltoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlumnoSueltoGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlumnoSueltoCountArgs<ExtArgs>
            result: $Utils.Optional<AlumnoSueltoCountAggregateOutputType> | number
          }
        }
      }
      Liquidacion: {
        payload: Prisma.$LiquidacionPayload<ExtArgs>
        fields: Prisma.LiquidacionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LiquidacionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiquidacionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LiquidacionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiquidacionPayload>
          }
          findFirst: {
            args: Prisma.LiquidacionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiquidacionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LiquidacionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiquidacionPayload>
          }
          findMany: {
            args: Prisma.LiquidacionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiquidacionPayload>[]
          }
          create: {
            args: Prisma.LiquidacionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiquidacionPayload>
          }
          createMany: {
            args: Prisma.LiquidacionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LiquidacionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiquidacionPayload>[]
          }
          delete: {
            args: Prisma.LiquidacionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiquidacionPayload>
          }
          update: {
            args: Prisma.LiquidacionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiquidacionPayload>
          }
          deleteMany: {
            args: Prisma.LiquidacionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LiquidacionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LiquidacionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiquidacionPayload>[]
          }
          upsert: {
            args: Prisma.LiquidacionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiquidacionPayload>
          }
          aggregate: {
            args: Prisma.LiquidacionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLiquidacion>
          }
          groupBy: {
            args: Prisma.LiquidacionGroupByArgs<ExtArgs>
            result: $Utils.Optional<LiquidacionGroupByOutputType>[]
          }
          count: {
            args: Prisma.LiquidacionCountArgs<ExtArgs>
            result: $Utils.Optional<LiquidacionCountAggregateOutputType> | number
          }
        }
      }
      DetalleLiquidacion: {
        payload: Prisma.$DetalleLiquidacionPayload<ExtArgs>
        fields: Prisma.DetalleLiquidacionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DetalleLiquidacionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetalleLiquidacionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DetalleLiquidacionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetalleLiquidacionPayload>
          }
          findFirst: {
            args: Prisma.DetalleLiquidacionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetalleLiquidacionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DetalleLiquidacionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetalleLiquidacionPayload>
          }
          findMany: {
            args: Prisma.DetalleLiquidacionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetalleLiquidacionPayload>[]
          }
          create: {
            args: Prisma.DetalleLiquidacionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetalleLiquidacionPayload>
          }
          createMany: {
            args: Prisma.DetalleLiquidacionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DetalleLiquidacionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetalleLiquidacionPayload>[]
          }
          delete: {
            args: Prisma.DetalleLiquidacionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetalleLiquidacionPayload>
          }
          update: {
            args: Prisma.DetalleLiquidacionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetalleLiquidacionPayload>
          }
          deleteMany: {
            args: Prisma.DetalleLiquidacionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DetalleLiquidacionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DetalleLiquidacionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetalleLiquidacionPayload>[]
          }
          upsert: {
            args: Prisma.DetalleLiquidacionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetalleLiquidacionPayload>
          }
          aggregate: {
            args: Prisma.DetalleLiquidacionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDetalleLiquidacion>
          }
          groupBy: {
            args: Prisma.DetalleLiquidacionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DetalleLiquidacionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DetalleLiquidacionCountArgs<ExtArgs>
            result: $Utils.Optional<DetalleLiquidacionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    alumno?: AlumnoOmit
    configuracionPagoAlumno?: ConfiguracionPagoAlumnoOmit
    descuento?: DescuentoOmit
    descuentoAplicado?: DescuentoAplicadoOmit
    deuda?: DeudaOmit
    pagoDeuda?: PagoDeudaOmit
    concepto?: ConceptoOmit
    recibo?: ReciboOmit
    estilo?: EstiloOmit
    alumnoEstilos?: AlumnoEstilosOmit
    profesor?: ProfesorOmit
    ctaCte?: CtaCteOmit
    cajaDiaria?: CajaDiariaOmit
    clase?: ClaseOmit
    asistencia?: AsistenciaOmit
    alumnoSuelto?: AlumnoSueltoOmit
    liquidacion?: LiquidacionOmit
    detalleLiquidacion?: DetalleLiquidacionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AlumnoCountOutputType
   */

  export type AlumnoCountOutputType = {
    recibos: number
    alumnosSueltosAnteriores: number
    estilos: number
    asistencias: number
    alumnoEstilos: number
    deudas: number
    descuentosVigentes: number
  }

  export type AlumnoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recibos?: boolean | AlumnoCountOutputTypeCountRecibosArgs
    alumnosSueltosAnteriores?: boolean | AlumnoCountOutputTypeCountAlumnosSueltosAnterioresArgs
    estilos?: boolean | AlumnoCountOutputTypeCountEstilosArgs
    asistencias?: boolean | AlumnoCountOutputTypeCountAsistenciasArgs
    alumnoEstilos?: boolean | AlumnoCountOutputTypeCountAlumnoEstilosArgs
    deudas?: boolean | AlumnoCountOutputTypeCountDeudasArgs
    descuentosVigentes?: boolean | AlumnoCountOutputTypeCountDescuentosVigentesArgs
  }

  // Custom InputTypes
  /**
   * AlumnoCountOutputType without action
   */
  export type AlumnoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoCountOutputType
     */
    select?: AlumnoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AlumnoCountOutputType without action
   */
  export type AlumnoCountOutputTypeCountRecibosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReciboWhereInput
  }

  /**
   * AlumnoCountOutputType without action
   */
  export type AlumnoCountOutputTypeCountAlumnosSueltosAnterioresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlumnoSueltoWhereInput
  }

  /**
   * AlumnoCountOutputType without action
   */
  export type AlumnoCountOutputTypeCountEstilosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstiloWhereInput
  }

  /**
   * AlumnoCountOutputType without action
   */
  export type AlumnoCountOutputTypeCountAsistenciasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AsistenciaWhereInput
  }

  /**
   * AlumnoCountOutputType without action
   */
  export type AlumnoCountOutputTypeCountAlumnoEstilosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlumnoEstilosWhereInput
  }

  /**
   * AlumnoCountOutputType without action
   */
  export type AlumnoCountOutputTypeCountDeudasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeudaWhereInput
  }

  /**
   * AlumnoCountOutputType without action
   */
  export type AlumnoCountOutputTypeCountDescuentosVigentesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DescuentoAplicadoWhereInput
  }


  /**
   * Count Type DescuentoCountOutputType
   */

  export type DescuentoCountOutputType = {
    aplicadoA: number
  }

  export type DescuentoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aplicadoA?: boolean | DescuentoCountOutputTypeCountAplicadoAArgs
  }

  // Custom InputTypes
  /**
   * DescuentoCountOutputType without action
   */
  export type DescuentoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DescuentoCountOutputType
     */
    select?: DescuentoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DescuentoCountOutputType without action
   */
  export type DescuentoCountOutputTypeCountAplicadoAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DescuentoAplicadoWhereInput
  }


  /**
   * Count Type DeudaCountOutputType
   */

  export type DeudaCountOutputType = {
    pagos: number
  }

  export type DeudaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pagos?: boolean | DeudaCountOutputTypeCountPagosArgs
  }

  // Custom InputTypes
  /**
   * DeudaCountOutputType without action
   */
  export type DeudaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeudaCountOutputType
     */
    select?: DeudaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeudaCountOutputType without action
   */
  export type DeudaCountOutputTypeCountPagosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagoDeudaWhereInput
  }


  /**
   * Count Type ConceptoCountOutputType
   */

  export type ConceptoCountOutputType = {
    recibos: number
  }

  export type ConceptoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recibos?: boolean | ConceptoCountOutputTypeCountRecibosArgs
  }

  // Custom InputTypes
  /**
   * ConceptoCountOutputType without action
   */
  export type ConceptoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptoCountOutputType
     */
    select?: ConceptoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConceptoCountOutputType without action
   */
  export type ConceptoCountOutputTypeCountRecibosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReciboWhereInput
  }


  /**
   * Count Type ReciboCountOutputType
   */

  export type ReciboCountOutputType = {
    pagosDeuda: number
    detallesLiquidacion: number
    recibosAnulados: number
  }

  export type ReciboCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pagosDeuda?: boolean | ReciboCountOutputTypeCountPagosDeudaArgs
    detallesLiquidacion?: boolean | ReciboCountOutputTypeCountDetallesLiquidacionArgs
    recibosAnulados?: boolean | ReciboCountOutputTypeCountRecibosAnuladosArgs
  }

  // Custom InputTypes
  /**
   * ReciboCountOutputType without action
   */
  export type ReciboCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReciboCountOutputType
     */
    select?: ReciboCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReciboCountOutputType without action
   */
  export type ReciboCountOutputTypeCountPagosDeudaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagoDeudaWhereInput
  }

  /**
   * ReciboCountOutputType without action
   */
  export type ReciboCountOutputTypeCountDetallesLiquidacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetalleLiquidacionWhereInput
  }

  /**
   * ReciboCountOutputType without action
   */
  export type ReciboCountOutputTypeCountRecibosAnuladosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReciboWhereInput
  }


  /**
   * Count Type EstiloCountOutputType
   */

  export type EstiloCountOutputType = {
    deudas: number
    conceptos: number
    clases: number
    alumnoEstilos: number
    alumnos: number
  }

  export type EstiloCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deudas?: boolean | EstiloCountOutputTypeCountDeudasArgs
    conceptos?: boolean | EstiloCountOutputTypeCountConceptosArgs
    clases?: boolean | EstiloCountOutputTypeCountClasesArgs
    alumnoEstilos?: boolean | EstiloCountOutputTypeCountAlumnoEstilosArgs
    alumnos?: boolean | EstiloCountOutputTypeCountAlumnosArgs
  }

  // Custom InputTypes
  /**
   * EstiloCountOutputType without action
   */
  export type EstiloCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstiloCountOutputType
     */
    select?: EstiloCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EstiloCountOutputType without action
   */
  export type EstiloCountOutputTypeCountDeudasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeudaWhereInput
  }

  /**
   * EstiloCountOutputType without action
   */
  export type EstiloCountOutputTypeCountConceptosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptoWhereInput
  }

  /**
   * EstiloCountOutputType without action
   */
  export type EstiloCountOutputTypeCountClasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaseWhereInput
  }

  /**
   * EstiloCountOutputType without action
   */
  export type EstiloCountOutputTypeCountAlumnoEstilosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlumnoEstilosWhereInput
  }

  /**
   * EstiloCountOutputType without action
   */
  export type EstiloCountOutputTypeCountAlumnosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlumnoWhereInput
  }


  /**
   * Count Type ProfesorCountOutputType
   */

  export type ProfesorCountOutputType = {
    clases: number
    estilos: number
    liquidaciones: number
  }

  export type ProfesorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clases?: boolean | ProfesorCountOutputTypeCountClasesArgs
    estilos?: boolean | ProfesorCountOutputTypeCountEstilosArgs
    liquidaciones?: boolean | ProfesorCountOutputTypeCountLiquidacionesArgs
  }

  // Custom InputTypes
  /**
   * ProfesorCountOutputType without action
   */
  export type ProfesorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfesorCountOutputType
     */
    select?: ProfesorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfesorCountOutputType without action
   */
  export type ProfesorCountOutputTypeCountClasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaseWhereInput
  }

  /**
   * ProfesorCountOutputType without action
   */
  export type ProfesorCountOutputTypeCountEstilosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstiloWhereInput
  }

  /**
   * ProfesorCountOutputType without action
   */
  export type ProfesorCountOutputTypeCountLiquidacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiquidacionWhereInput
  }


  /**
   * Count Type ClaseCountOutputType
   */

  export type ClaseCountOutputType = {
    asistencias: number
    alumnosSueltos: number
    recibos: number
  }

  export type ClaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asistencias?: boolean | ClaseCountOutputTypeCountAsistenciasArgs
    alumnosSueltos?: boolean | ClaseCountOutputTypeCountAlumnosSueltosArgs
    recibos?: boolean | ClaseCountOutputTypeCountRecibosArgs
  }

  // Custom InputTypes
  /**
   * ClaseCountOutputType without action
   */
  export type ClaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaseCountOutputType
     */
    select?: ClaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClaseCountOutputType without action
   */
  export type ClaseCountOutputTypeCountAsistenciasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AsistenciaWhereInput
  }

  /**
   * ClaseCountOutputType without action
   */
  export type ClaseCountOutputTypeCountAlumnosSueltosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlumnoSueltoWhereInput
  }

  /**
   * ClaseCountOutputType without action
   */
  export type ClaseCountOutputTypeCountRecibosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReciboWhereInput
  }


  /**
   * Count Type AlumnoSueltoCountOutputType
   */

  export type AlumnoSueltoCountOutputType = {
    recibos: number
    clases: number
  }

  export type AlumnoSueltoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recibos?: boolean | AlumnoSueltoCountOutputTypeCountRecibosArgs
    clases?: boolean | AlumnoSueltoCountOutputTypeCountClasesArgs
  }

  // Custom InputTypes
  /**
   * AlumnoSueltoCountOutputType without action
   */
  export type AlumnoSueltoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoSueltoCountOutputType
     */
    select?: AlumnoSueltoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AlumnoSueltoCountOutputType without action
   */
  export type AlumnoSueltoCountOutputTypeCountRecibosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReciboWhereInput
  }

  /**
   * AlumnoSueltoCountOutputType without action
   */
  export type AlumnoSueltoCountOutputTypeCountClasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaseWhereInput
  }


  /**
   * Count Type LiquidacionCountOutputType
   */

  export type LiquidacionCountOutputType = {
    detalles: number
  }

  export type LiquidacionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detalles?: boolean | LiquidacionCountOutputTypeCountDetallesArgs
  }

  // Custom InputTypes
  /**
   * LiquidacionCountOutputType without action
   */
  export type LiquidacionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiquidacionCountOutputType
     */
    select?: LiquidacionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LiquidacionCountOutputType without action
   */
  export type LiquidacionCountOutputTypeCountDetallesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetalleLiquidacionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Alumno
   */

  export type AggregateAlumno = {
    _count: AlumnoCountAggregateOutputType | null
    _avg: AlumnoAvgAggregateOutputType | null
    _sum: AlumnoSumAggregateOutputType | null
    _min: AlumnoMinAggregateOutputType | null
    _max: AlumnoMaxAggregateOutputType | null
  }

  export type AlumnoAvgAggregateOutputType = {
    id: number | null
  }

  export type AlumnoSumAggregateOutputType = {
    id: number | null
  }

  export type AlumnoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellido: string | null
    dni: string | null
    activo: boolean | null
    fechaNacimiento: Date | null
    email: string | null
    telefono: string | null
    numeroEmergencia: string | null
    direccion: string | null
    obraSocial: string | null
    nombreTutor: string | null
    dniTutor: string | null
    notas: string | null
    fechaIngreso: Date | null
    fechaBaja: Date | null
    motivoBaja: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlumnoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellido: string | null
    dni: string | null
    activo: boolean | null
    fechaNacimiento: Date | null
    email: string | null
    telefono: string | null
    numeroEmergencia: string | null
    direccion: string | null
    obraSocial: string | null
    nombreTutor: string | null
    dniTutor: string | null
    notas: string | null
    fechaIngreso: Date | null
    fechaBaja: Date | null
    motivoBaja: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlumnoCountAggregateOutputType = {
    id: number
    nombre: number
    apellido: number
    dni: number
    activo: number
    fechaNacimiento: number
    email: number
    telefono: number
    numeroEmergencia: number
    direccion: number
    obraSocial: number
    nombreTutor: number
    dniTutor: number
    notas: number
    fechaIngreso: number
    fechaBaja: number
    motivoBaja: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AlumnoAvgAggregateInputType = {
    id?: true
  }

  export type AlumnoSumAggregateInputType = {
    id?: true
  }

  export type AlumnoMinAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    dni?: true
    activo?: true
    fechaNacimiento?: true
    email?: true
    telefono?: true
    numeroEmergencia?: true
    direccion?: true
    obraSocial?: true
    nombreTutor?: true
    dniTutor?: true
    notas?: true
    fechaIngreso?: true
    fechaBaja?: true
    motivoBaja?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlumnoMaxAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    dni?: true
    activo?: true
    fechaNacimiento?: true
    email?: true
    telefono?: true
    numeroEmergencia?: true
    direccion?: true
    obraSocial?: true
    nombreTutor?: true
    dniTutor?: true
    notas?: true
    fechaIngreso?: true
    fechaBaja?: true
    motivoBaja?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlumnoCountAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    dni?: true
    activo?: true
    fechaNacimiento?: true
    email?: true
    telefono?: true
    numeroEmergencia?: true
    direccion?: true
    obraSocial?: true
    nombreTutor?: true
    dniTutor?: true
    notas?: true
    fechaIngreso?: true
    fechaBaja?: true
    motivoBaja?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AlumnoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alumno to aggregate.
     */
    where?: AlumnoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alumnos to fetch.
     */
    orderBy?: AlumnoOrderByWithRelationInput | AlumnoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlumnoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alumnos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alumnos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alumnos
    **/
    _count?: true | AlumnoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlumnoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlumnoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlumnoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlumnoMaxAggregateInputType
  }

  export type GetAlumnoAggregateType<T extends AlumnoAggregateArgs> = {
        [P in keyof T & keyof AggregateAlumno]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlumno[P]>
      : GetScalarType<T[P], AggregateAlumno[P]>
  }




  export type AlumnoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlumnoWhereInput
    orderBy?: AlumnoOrderByWithAggregationInput | AlumnoOrderByWithAggregationInput[]
    by: AlumnoScalarFieldEnum[] | AlumnoScalarFieldEnum
    having?: AlumnoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlumnoCountAggregateInputType | true
    _avg?: AlumnoAvgAggregateInputType
    _sum?: AlumnoSumAggregateInputType
    _min?: AlumnoMinAggregateInputType
    _max?: AlumnoMaxAggregateInputType
  }

  export type AlumnoGroupByOutputType = {
    id: number
    nombre: string
    apellido: string
    dni: string
    activo: boolean
    fechaNacimiento: Date
    email: string | null
    telefono: string | null
    numeroEmergencia: string | null
    direccion: string | null
    obraSocial: string | null
    nombreTutor: string | null
    dniTutor: string | null
    notas: string | null
    fechaIngreso: Date
    fechaBaja: Date | null
    motivoBaja: string | null
    createdAt: Date
    updatedAt: Date
    _count: AlumnoCountAggregateOutputType | null
    _avg: AlumnoAvgAggregateOutputType | null
    _sum: AlumnoSumAggregateOutputType | null
    _min: AlumnoMinAggregateOutputType | null
    _max: AlumnoMaxAggregateOutputType | null
  }

  type GetAlumnoGroupByPayload<T extends AlumnoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlumnoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlumnoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlumnoGroupByOutputType[P]>
            : GetScalarType<T[P], AlumnoGroupByOutputType[P]>
        }
      >
    >


  export type AlumnoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    dni?: boolean
    activo?: boolean
    fechaNacimiento?: boolean
    email?: boolean
    telefono?: boolean
    numeroEmergencia?: boolean
    direccion?: boolean
    obraSocial?: boolean
    nombreTutor?: boolean
    dniTutor?: boolean
    notas?: boolean
    fechaIngreso?: boolean
    fechaBaja?: boolean
    motivoBaja?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    recibos?: boolean | Alumno$recibosArgs<ExtArgs>
    alumnosSueltosAnteriores?: boolean | Alumno$alumnosSueltosAnterioresArgs<ExtArgs>
    ctaCte?: boolean | Alumno$ctaCteArgs<ExtArgs>
    estilos?: boolean | Alumno$estilosArgs<ExtArgs>
    asistencias?: boolean | Alumno$asistenciasArgs<ExtArgs>
    alumnoEstilos?: boolean | Alumno$alumnoEstilosArgs<ExtArgs>
    deudas?: boolean | Alumno$deudasArgs<ExtArgs>
    descuentosVigentes?: boolean | Alumno$descuentosVigentesArgs<ExtArgs>
    configuracionPago?: boolean | Alumno$configuracionPagoArgs<ExtArgs>
    _count?: boolean | AlumnoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alumno"]>

  export type AlumnoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    dni?: boolean
    activo?: boolean
    fechaNacimiento?: boolean
    email?: boolean
    telefono?: boolean
    numeroEmergencia?: boolean
    direccion?: boolean
    obraSocial?: boolean
    nombreTutor?: boolean
    dniTutor?: boolean
    notas?: boolean
    fechaIngreso?: boolean
    fechaBaja?: boolean
    motivoBaja?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["alumno"]>

  export type AlumnoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    dni?: boolean
    activo?: boolean
    fechaNacimiento?: boolean
    email?: boolean
    telefono?: boolean
    numeroEmergencia?: boolean
    direccion?: boolean
    obraSocial?: boolean
    nombreTutor?: boolean
    dniTutor?: boolean
    notas?: boolean
    fechaIngreso?: boolean
    fechaBaja?: boolean
    motivoBaja?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["alumno"]>

  export type AlumnoSelectScalar = {
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    dni?: boolean
    activo?: boolean
    fechaNacimiento?: boolean
    email?: boolean
    telefono?: boolean
    numeroEmergencia?: boolean
    direccion?: boolean
    obraSocial?: boolean
    nombreTutor?: boolean
    dniTutor?: boolean
    notas?: boolean
    fechaIngreso?: boolean
    fechaBaja?: boolean
    motivoBaja?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AlumnoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "apellido" | "dni" | "activo" | "fechaNacimiento" | "email" | "telefono" | "numeroEmergencia" | "direccion" | "obraSocial" | "nombreTutor" | "dniTutor" | "notas" | "fechaIngreso" | "fechaBaja" | "motivoBaja" | "createdAt" | "updatedAt", ExtArgs["result"]["alumno"]>
  export type AlumnoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recibos?: boolean | Alumno$recibosArgs<ExtArgs>
    alumnosSueltosAnteriores?: boolean | Alumno$alumnosSueltosAnterioresArgs<ExtArgs>
    ctaCte?: boolean | Alumno$ctaCteArgs<ExtArgs>
    estilos?: boolean | Alumno$estilosArgs<ExtArgs>
    asistencias?: boolean | Alumno$asistenciasArgs<ExtArgs>
    alumnoEstilos?: boolean | Alumno$alumnoEstilosArgs<ExtArgs>
    deudas?: boolean | Alumno$deudasArgs<ExtArgs>
    descuentosVigentes?: boolean | Alumno$descuentosVigentesArgs<ExtArgs>
    configuracionPago?: boolean | Alumno$configuracionPagoArgs<ExtArgs>
    _count?: boolean | AlumnoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AlumnoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AlumnoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AlumnoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alumno"
    objects: {
      recibos: Prisma.$ReciboPayload<ExtArgs>[]
      alumnosSueltosAnteriores: Prisma.$AlumnoSueltoPayload<ExtArgs>[]
      ctaCte: Prisma.$CtaCtePayload<ExtArgs> | null
      estilos: Prisma.$EstiloPayload<ExtArgs>[]
      asistencias: Prisma.$AsistenciaPayload<ExtArgs>[]
      alumnoEstilos: Prisma.$AlumnoEstilosPayload<ExtArgs>[]
      deudas: Prisma.$DeudaPayload<ExtArgs>[]
      descuentosVigentes: Prisma.$DescuentoAplicadoPayload<ExtArgs>[]
      configuracionPago: Prisma.$ConfiguracionPagoAlumnoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      apellido: string
      dni: string
      activo: boolean
      fechaNacimiento: Date
      email: string | null
      telefono: string | null
      numeroEmergencia: string | null
      direccion: string | null
      obraSocial: string | null
      nombreTutor: string | null
      dniTutor: string | null
      notas: string | null
      fechaIngreso: Date
      fechaBaja: Date | null
      motivoBaja: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["alumno"]>
    composites: {}
  }

  type AlumnoGetPayload<S extends boolean | null | undefined | AlumnoDefaultArgs> = $Result.GetResult<Prisma.$AlumnoPayload, S>

  type AlumnoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlumnoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlumnoCountAggregateInputType | true
    }

  export interface AlumnoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alumno'], meta: { name: 'Alumno' } }
    /**
     * Find zero or one Alumno that matches the filter.
     * @param {AlumnoFindUniqueArgs} args - Arguments to find a Alumno
     * @example
     * // Get one Alumno
     * const alumno = await prisma.alumno.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlumnoFindUniqueArgs>(args: SelectSubset<T, AlumnoFindUniqueArgs<ExtArgs>>): Prisma__AlumnoClient<$Result.GetResult<Prisma.$AlumnoPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Alumno that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlumnoFindUniqueOrThrowArgs} args - Arguments to find a Alumno
     * @example
     * // Get one Alumno
     * const alumno = await prisma.alumno.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlumnoFindUniqueOrThrowArgs>(args: SelectSubset<T, AlumnoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlumnoClient<$Result.GetResult<Prisma.$AlumnoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Alumno that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoFindFirstArgs} args - Arguments to find a Alumno
     * @example
     * // Get one Alumno
     * const alumno = await prisma.alumno.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlumnoFindFirstArgs>(args?: SelectSubset<T, AlumnoFindFirstArgs<ExtArgs>>): Prisma__AlumnoClient<$Result.GetResult<Prisma.$AlumnoPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Alumno that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoFindFirstOrThrowArgs} args - Arguments to find a Alumno
     * @example
     * // Get one Alumno
     * const alumno = await prisma.alumno.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlumnoFindFirstOrThrowArgs>(args?: SelectSubset<T, AlumnoFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlumnoClient<$Result.GetResult<Prisma.$AlumnoPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Alumnos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alumnos
     * const alumnos = await prisma.alumno.findMany()
     * 
     * // Get first 10 Alumnos
     * const alumnos = await prisma.alumno.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alumnoWithIdOnly = await prisma.alumno.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlumnoFindManyArgs>(args?: SelectSubset<T, AlumnoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlumnoPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Alumno.
     * @param {AlumnoCreateArgs} args - Arguments to create a Alumno.
     * @example
     * // Create one Alumno
     * const Alumno = await prisma.alumno.create({
     *   data: {
     *     // ... data to create a Alumno
     *   }
     * })
     * 
     */
    create<T extends AlumnoCreateArgs>(args: SelectSubset<T, AlumnoCreateArgs<ExtArgs>>): Prisma__AlumnoClient<$Result.GetResult<Prisma.$AlumnoPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Alumnos.
     * @param {AlumnoCreateManyArgs} args - Arguments to create many Alumnos.
     * @example
     * // Create many Alumnos
     * const alumno = await prisma.alumno.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlumnoCreateManyArgs>(args?: SelectSubset<T, AlumnoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alumnos and returns the data saved in the database.
     * @param {AlumnoCreateManyAndReturnArgs} args - Arguments to create many Alumnos.
     * @example
     * // Create many Alumnos
     * const alumno = await prisma.alumno.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alumnos and only return the `id`
     * const alumnoWithIdOnly = await prisma.alumno.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlumnoCreateManyAndReturnArgs>(args?: SelectSubset<T, AlumnoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlumnoPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Alumno.
     * @param {AlumnoDeleteArgs} args - Arguments to delete one Alumno.
     * @example
     * // Delete one Alumno
     * const Alumno = await prisma.alumno.delete({
     *   where: {
     *     // ... filter to delete one Alumno
     *   }
     * })
     * 
     */
    delete<T extends AlumnoDeleteArgs>(args: SelectSubset<T, AlumnoDeleteArgs<ExtArgs>>): Prisma__AlumnoClient<$Result.GetResult<Prisma.$AlumnoPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Alumno.
     * @param {AlumnoUpdateArgs} args - Arguments to update one Alumno.
     * @example
     * // Update one Alumno
     * const alumno = await prisma.alumno.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlumnoUpdateArgs>(args: SelectSubset<T, AlumnoUpdateArgs<ExtArgs>>): Prisma__AlumnoClient<$Result.GetResult<Prisma.$AlumnoPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Alumnos.
     * @param {AlumnoDeleteManyArgs} args - Arguments to filter Alumnos to delete.
     * @example
     * // Delete a few Alumnos
     * const { count } = await prisma.alumno.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlumnoDeleteManyArgs>(args?: SelectSubset<T, AlumnoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alumnos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alumnos
     * const alumno = await prisma.alumno.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlumnoUpdateManyArgs>(args: SelectSubset<T, AlumnoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alumnos and returns the data updated in the database.
     * @param {AlumnoUpdateManyAndReturnArgs} args - Arguments to update many Alumnos.
     * @example
     * // Update many Alumnos
     * const alumno = await prisma.alumno.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Alumnos and only return the `id`
     * const alumnoWithIdOnly = await prisma.alumno.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlumnoUpdateManyAndReturnArgs>(args: SelectSubset<T, AlumnoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlumnoPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Alumno.
     * @param {AlumnoUpsertArgs} args - Arguments to update or create a Alumno.
     * @example
     * // Update or create a Alumno
     * const alumno = await prisma.alumno.upsert({
     *   create: {
     *     // ... data to create a Alumno
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alumno we want to update
     *   }
     * })
     */
    upsert<T extends AlumnoUpsertArgs>(args: SelectSubset<T, AlumnoUpsertArgs<ExtArgs>>): Prisma__AlumnoClient<$Result.GetResult<Prisma.$AlumnoPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Alumnos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoCountArgs} args - Arguments to filter Alumnos to count.
     * @example
     * // Count the number of Alumnos
     * const count = await prisma.alumno.count({
     *   where: {
     *     // ... the filter for the Alumnos we want to count
     *   }
     * })
    **/
    count<T extends AlumnoCountArgs>(
      args?: Subset<T, AlumnoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlumnoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alumno.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlumnoAggregateArgs>(args: Subset<T, AlumnoAggregateArgs>): Prisma.PrismaPromise<GetAlumnoAggregateType<T>>

    /**
     * Group by Alumno.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlumnoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlumnoGroupByArgs['orderBy'] }
        : { orderBy?: AlumnoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlumnoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlumnoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alumno model
   */
  readonly fields: AlumnoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alumno.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlumnoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recibos<T extends Alumno$recibosArgs<ExtArgs> = {}>(args?: Subset<T, Alumno$recibosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReciboPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    alumnosSueltosAnteriores<T extends Alumno$alumnosSueltosAnterioresArgs<ExtArgs> = {}>(args?: Subset<T, Alumno$alumnosSueltosAnterioresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlumnoSueltoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    ctaCte<T extends Alumno$ctaCteArgs<ExtArgs> = {}>(args?: Subset<T, Alumno$ctaCteArgs<ExtArgs>>): Prisma__CtaCteClient<$Result.GetResult<Prisma.$CtaCtePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    estilos<T extends Alumno$estilosArgs<ExtArgs> = {}>(args?: Subset<T, Alumno$estilosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstiloPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    asistencias<T extends Alumno$asistenciasArgs<ExtArgs> = {}>(args?: Subset<T, Alumno$asistenciasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AsistenciaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    alumnoEstilos<T extends Alumno$alumnoEstilosArgs<ExtArgs> = {}>(args?: Subset<T, Alumno$alumnoEstilosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlumnoEstilosPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    deudas<T extends Alumno$deudasArgs<ExtArgs> = {}>(args?: Subset<T, Alumno$deudasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeudaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    descuentosVigentes<T extends Alumno$descuentosVigentesArgs<ExtArgs> = {}>(args?: Subset<T, Alumno$descuentosVigentesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DescuentoAplicadoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    configuracionPago<T extends Alumno$configuracionPagoArgs<ExtArgs> = {}>(args?: Subset<T, Alumno$configuracionPagoArgs<ExtArgs>>): Prisma__ConfiguracionPagoAlumnoClient<$Result.GetResult<Prisma.$ConfiguracionPagoAlumnoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alumno model
   */ 
  interface AlumnoFieldRefs {
    readonly id: FieldRef<"Alumno", 'Int'>
    readonly nombre: FieldRef<"Alumno", 'String'>
    readonly apellido: FieldRef<"Alumno", 'String'>
    readonly dni: FieldRef<"Alumno", 'String'>
    readonly activo: FieldRef<"Alumno", 'Boolean'>
    readonly fechaNacimiento: FieldRef<"Alumno", 'DateTime'>
    readonly email: FieldRef<"Alumno", 'String'>
    readonly telefono: FieldRef<"Alumno", 'String'>
    readonly numeroEmergencia: FieldRef<"Alumno", 'String'>
    readonly direccion: FieldRef<"Alumno", 'String'>
    readonly obraSocial: FieldRef<"Alumno", 'String'>
    readonly nombreTutor: FieldRef<"Alumno", 'String'>
    readonly dniTutor: FieldRef<"Alumno", 'String'>
    readonly notas: FieldRef<"Alumno", 'String'>
    readonly fechaIngreso: FieldRef<"Alumno", 'DateTime'>
    readonly fechaBaja: FieldRef<"Alumno", 'DateTime'>
    readonly motivoBaja: FieldRef<"Alumno", 'String'>
    readonly createdAt: FieldRef<"Alumno", 'DateTime'>
    readonly updatedAt: FieldRef<"Alumno", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Alumno findUnique
   */
  export type AlumnoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alumno
     */
    select?: AlumnoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alumno
     */
    omit?: AlumnoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoInclude<ExtArgs> | null
    /**
     * Filter, which Alumno to fetch.
     */
    where: AlumnoWhereUniqueInput
  }

  /**
   * Alumno findUniqueOrThrow
   */
  export type AlumnoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alumno
     */
    select?: AlumnoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alumno
     */
    omit?: AlumnoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoInclude<ExtArgs> | null
    /**
     * Filter, which Alumno to fetch.
     */
    where: AlumnoWhereUniqueInput
  }

  /**
   * Alumno findFirst
   */
  export type AlumnoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alumno
     */
    select?: AlumnoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alumno
     */
    omit?: AlumnoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoInclude<ExtArgs> | null
    /**
     * Filter, which Alumno to fetch.
     */
    where?: AlumnoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alumnos to fetch.
     */
    orderBy?: AlumnoOrderByWithRelationInput | AlumnoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alumnos.
     */
    cursor?: AlumnoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alumnos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alumnos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alumnos.
     */
    distinct?: AlumnoScalarFieldEnum | AlumnoScalarFieldEnum[]
  }

  /**
   * Alumno findFirstOrThrow
   */
  export type AlumnoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alumno
     */
    select?: AlumnoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alumno
     */
    omit?: AlumnoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoInclude<ExtArgs> | null
    /**
     * Filter, which Alumno to fetch.
     */
    where?: AlumnoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alumnos to fetch.
     */
    orderBy?: AlumnoOrderByWithRelationInput | AlumnoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alumnos.
     */
    cursor?: AlumnoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alumnos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alumnos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alumnos.
     */
    distinct?: AlumnoScalarFieldEnum | AlumnoScalarFieldEnum[]
  }

  /**
   * Alumno findMany
   */
  export type AlumnoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alumno
     */
    select?: AlumnoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alumno
     */
    omit?: AlumnoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoInclude<ExtArgs> | null
    /**
     * Filter, which Alumnos to fetch.
     */
    where?: AlumnoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alumnos to fetch.
     */
    orderBy?: AlumnoOrderByWithRelationInput | AlumnoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alumnos.
     */
    cursor?: AlumnoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alumnos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alumnos.
     */
    skip?: number
    distinct?: AlumnoScalarFieldEnum | AlumnoScalarFieldEnum[]
  }

  /**
   * Alumno create
   */
  export type AlumnoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alumno
     */
    select?: AlumnoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alumno
     */
    omit?: AlumnoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoInclude<ExtArgs> | null
    /**
     * The data needed to create a Alumno.
     */
    data: XOR<AlumnoCreateInput, AlumnoUncheckedCreateInput>
  }

  /**
   * Alumno createMany
   */
  export type AlumnoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alumnos.
     */
    data: AlumnoCreateManyInput | AlumnoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alumno createManyAndReturn
   */
  export type AlumnoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alumno
     */
    select?: AlumnoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alumno
     */
    omit?: AlumnoOmit<ExtArgs> | null
    /**
     * The data used to create many Alumnos.
     */
    data: AlumnoCreateManyInput | AlumnoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alumno update
   */
  export type AlumnoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alumno
     */
    select?: AlumnoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alumno
     */
    omit?: AlumnoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoInclude<ExtArgs> | null
    /**
     * The data needed to update a Alumno.
     */
    data: XOR<AlumnoUpdateInput, AlumnoUncheckedUpdateInput>
    /**
     * Choose, which Alumno to update.
     */
    where: AlumnoWhereUniqueInput
  }

  /**
   * Alumno updateMany
   */
  export type AlumnoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alumnos.
     */
    data: XOR<AlumnoUpdateManyMutationInput, AlumnoUncheckedUpdateManyInput>
    /**
     * Filter which Alumnos to update
     */
    where?: AlumnoWhereInput
  }

  /**
   * Alumno updateManyAndReturn
   */
  export type AlumnoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alumno
     */
    select?: AlumnoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alumno
     */
    omit?: AlumnoOmit<ExtArgs> | null
    /**
     * The data used to update Alumnos.
     */
    data: XOR<AlumnoUpdateManyMutationInput, AlumnoUncheckedUpdateManyInput>
    /**
     * Filter which Alumnos to update
     */
    where?: AlumnoWhereInput
  }

  /**
   * Alumno upsert
   */
  export type AlumnoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alumno
     */
    select?: AlumnoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alumno
     */
    omit?: AlumnoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoInclude<ExtArgs> | null
    /**
     * The filter to search for the Alumno to update in case it exists.
     */
    where: AlumnoWhereUniqueInput
    /**
     * In case the Alumno found by the `where` argument doesn't exist, create a new Alumno with this data.
     */
    create: XOR<AlumnoCreateInput, AlumnoUncheckedCreateInput>
    /**
     * In case the Alumno was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlumnoUpdateInput, AlumnoUncheckedUpdateInput>
  }

  /**
   * Alumno delete
   */
  export type AlumnoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alumno
     */
    select?: AlumnoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alumno
     */
    omit?: AlumnoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoInclude<ExtArgs> | null
    /**
     * Filter which Alumno to delete.
     */
    where: AlumnoWhereUniqueInput
  }

  /**
   * Alumno deleteMany
   */
  export type AlumnoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alumnos to delete
     */
    where?: AlumnoWhereInput
  }

  /**
   * Alumno.recibos
   */
  export type Alumno$recibosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recibo
     */
    select?: ReciboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recibo
     */
    omit?: ReciboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReciboInclude<ExtArgs> | null
    where?: ReciboWhereInput
    orderBy?: ReciboOrderByWithRelationInput | ReciboOrderByWithRelationInput[]
    cursor?: ReciboWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReciboScalarFieldEnum | ReciboScalarFieldEnum[]
  }

  /**
   * Alumno.alumnosSueltosAnteriores
   */
  export type Alumno$alumnosSueltosAnterioresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoSuelto
     */
    select?: AlumnoSueltoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoSuelto
     */
    omit?: AlumnoSueltoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoSueltoInclude<ExtArgs> | null
    where?: AlumnoSueltoWhereInput
    orderBy?: AlumnoSueltoOrderByWithRelationInput | AlumnoSueltoOrderByWithRelationInput[]
    cursor?: AlumnoSueltoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlumnoSueltoScalarFieldEnum | AlumnoSueltoScalarFieldEnum[]
  }

  /**
   * Alumno.ctaCte
   */
  export type Alumno$ctaCteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CtaCte
     */
    select?: CtaCteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CtaCte
     */
    omit?: CtaCteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CtaCteInclude<ExtArgs> | null
    where?: CtaCteWhereInput
  }

  /**
   * Alumno.estilos
   */
  export type Alumno$estilosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estilo
     */
    select?: EstiloSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estilo
     */
    omit?: EstiloOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstiloInclude<ExtArgs> | null
    where?: EstiloWhereInput
    orderBy?: EstiloOrderByWithRelationInput | EstiloOrderByWithRelationInput[]
    cursor?: EstiloWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EstiloScalarFieldEnum | EstiloScalarFieldEnum[]
  }

  /**
   * Alumno.asistencias
   */
  export type Alumno$asistenciasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asistencia
     */
    select?: AsistenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asistencia
     */
    omit?: AsistenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsistenciaInclude<ExtArgs> | null
    where?: AsistenciaWhereInput
    orderBy?: AsistenciaOrderByWithRelationInput | AsistenciaOrderByWithRelationInput[]
    cursor?: AsistenciaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AsistenciaScalarFieldEnum | AsistenciaScalarFieldEnum[]
  }

  /**
   * Alumno.alumnoEstilos
   */
  export type Alumno$alumnoEstilosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoEstilos
     */
    select?: AlumnoEstilosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoEstilos
     */
    omit?: AlumnoEstilosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoEstilosInclude<ExtArgs> | null
    where?: AlumnoEstilosWhereInput
    orderBy?: AlumnoEstilosOrderByWithRelationInput | AlumnoEstilosOrderByWithRelationInput[]
    cursor?: AlumnoEstilosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlumnoEstilosScalarFieldEnum | AlumnoEstilosScalarFieldEnum[]
  }

  /**
   * Alumno.deudas
   */
  export type Alumno$deudasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deuda
     */
    select?: DeudaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deuda
     */
    omit?: DeudaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeudaInclude<ExtArgs> | null
    where?: DeudaWhereInput
    orderBy?: DeudaOrderByWithRelationInput | DeudaOrderByWithRelationInput[]
    cursor?: DeudaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeudaScalarFieldEnum | DeudaScalarFieldEnum[]
  }

  /**
   * Alumno.descuentosVigentes
   */
  export type Alumno$descuentosVigentesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DescuentoAplicado
     */
    select?: DescuentoAplicadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DescuentoAplicado
     */
    omit?: DescuentoAplicadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DescuentoAplicadoInclude<ExtArgs> | null
    where?: DescuentoAplicadoWhereInput
    orderBy?: DescuentoAplicadoOrderByWithRelationInput | DescuentoAplicadoOrderByWithRelationInput[]
    cursor?: DescuentoAplicadoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DescuentoAplicadoScalarFieldEnum | DescuentoAplicadoScalarFieldEnum[]
  }

  /**
   * Alumno.configuracionPago
   */
  export type Alumno$configuracionPagoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionPagoAlumno
     */
    select?: ConfiguracionPagoAlumnoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfiguracionPagoAlumno
     */
    omit?: ConfiguracionPagoAlumnoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfiguracionPagoAlumnoInclude<ExtArgs> | null
    where?: ConfiguracionPagoAlumnoWhereInput
  }

  /**
   * Alumno without action
   */
  export type AlumnoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alumno
     */
    select?: AlumnoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alumno
     */
    omit?: AlumnoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoInclude<ExtArgs> | null
  }


  /**
   * Model ConfiguracionPagoAlumno
   */

  export type AggregateConfiguracionPagoAlumno = {
    _count: ConfiguracionPagoAlumnoCountAggregateOutputType | null
    _avg: ConfiguracionPagoAlumnoAvgAggregateOutputType | null
    _sum: ConfiguracionPagoAlumnoSumAggregateOutputType | null
    _min: ConfiguracionPagoAlumnoMinAggregateOutputType | null
    _max: ConfiguracionPagoAlumnoMaxAggregateOutputType | null
  }

  export type ConfiguracionPagoAlumnoAvgAggregateOutputType = {
    id: number | null
    alumnoId: number | null
    diaPago: number | null
    descuentoFijo: number | null
  }

  export type ConfiguracionPagoAlumnoSumAggregateOutputType = {
    id: number | null
    alumnoId: number | null
    diaPago: number | null
    descuentoFijo: number | null
  }

  export type ConfiguracionPagoAlumnoMinAggregateOutputType = {
    id: number | null
    alumnoId: number | null
    diaPago: number | null
    metodoPago: $Enums.TipoPago | null
    descuentoFijo: number | null
    observaciones: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConfiguracionPagoAlumnoMaxAggregateOutputType = {
    id: number | null
    alumnoId: number | null
    diaPago: number | null
    metodoPago: $Enums.TipoPago | null
    descuentoFijo: number | null
    observaciones: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConfiguracionPagoAlumnoCountAggregateOutputType = {
    id: number
    alumnoId: number
    diaPago: number
    metodoPago: number
    descuentoFijo: number
    observaciones: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConfiguracionPagoAlumnoAvgAggregateInputType = {
    id?: true
    alumnoId?: true
    diaPago?: true
    descuentoFijo?: true
  }

  export type ConfiguracionPagoAlumnoSumAggregateInputType = {
    id?: true
    alumnoId?: true
    diaPago?: true
    descuentoFijo?: true
  }

  export type ConfiguracionPagoAlumnoMinAggregateInputType = {
    id?: true
    alumnoId?: true
    diaPago?: true
    metodoPago?: true
    descuentoFijo?: true
    observaciones?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConfiguracionPagoAlumnoMaxAggregateInputType = {
    id?: true
    alumnoId?: true
    diaPago?: true
    metodoPago?: true
    descuentoFijo?: true
    observaciones?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConfiguracionPagoAlumnoCountAggregateInputType = {
    id?: true
    alumnoId?: true
    diaPago?: true
    metodoPago?: true
    descuentoFijo?: true
    observaciones?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConfiguracionPagoAlumnoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfiguracionPagoAlumno to aggregate.
     */
    where?: ConfiguracionPagoAlumnoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfiguracionPagoAlumnos to fetch.
     */
    orderBy?: ConfiguracionPagoAlumnoOrderByWithRelationInput | ConfiguracionPagoAlumnoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfiguracionPagoAlumnoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfiguracionPagoAlumnos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfiguracionPagoAlumnos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConfiguracionPagoAlumnos
    **/
    _count?: true | ConfiguracionPagoAlumnoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConfiguracionPagoAlumnoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConfiguracionPagoAlumnoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfiguracionPagoAlumnoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfiguracionPagoAlumnoMaxAggregateInputType
  }

  export type GetConfiguracionPagoAlumnoAggregateType<T extends ConfiguracionPagoAlumnoAggregateArgs> = {
        [P in keyof T & keyof AggregateConfiguracionPagoAlumno]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfiguracionPagoAlumno[P]>
      : GetScalarType<T[P], AggregateConfiguracionPagoAlumno[P]>
  }




  export type ConfiguracionPagoAlumnoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfiguracionPagoAlumnoWhereInput
    orderBy?: ConfiguracionPagoAlumnoOrderByWithAggregationInput | ConfiguracionPagoAlumnoOrderByWithAggregationInput[]
    by: ConfiguracionPagoAlumnoScalarFieldEnum[] | ConfiguracionPagoAlumnoScalarFieldEnum
    having?: ConfiguracionPagoAlumnoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfiguracionPagoAlumnoCountAggregateInputType | true
    _avg?: ConfiguracionPagoAlumnoAvgAggregateInputType
    _sum?: ConfiguracionPagoAlumnoSumAggregateInputType
    _min?: ConfiguracionPagoAlumnoMinAggregateInputType
    _max?: ConfiguracionPagoAlumnoMaxAggregateInputType
  }

  export type ConfiguracionPagoAlumnoGroupByOutputType = {
    id: number
    alumnoId: number
    diaPago: number | null
    metodoPago: $Enums.TipoPago
    descuentoFijo: number | null
    observaciones: string | null
    createdAt: Date
    updatedAt: Date
    _count: ConfiguracionPagoAlumnoCountAggregateOutputType | null
    _avg: ConfiguracionPagoAlumnoAvgAggregateOutputType | null
    _sum: ConfiguracionPagoAlumnoSumAggregateOutputType | null
    _min: ConfiguracionPagoAlumnoMinAggregateOutputType | null
    _max: ConfiguracionPagoAlumnoMaxAggregateOutputType | null
  }

  type GetConfiguracionPagoAlumnoGroupByPayload<T extends ConfiguracionPagoAlumnoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfiguracionPagoAlumnoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfiguracionPagoAlumnoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfiguracionPagoAlumnoGroupByOutputType[P]>
            : GetScalarType<T[P], ConfiguracionPagoAlumnoGroupByOutputType[P]>
        }
      >
    >


  export type ConfiguracionPagoAlumnoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alumnoId?: boolean
    diaPago?: boolean
    metodoPago?: boolean
    descuentoFijo?: boolean
    observaciones?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["configuracionPagoAlumno"]>

  export type ConfiguracionPagoAlumnoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alumnoId?: boolean
    diaPago?: boolean
    metodoPago?: boolean
    descuentoFijo?: boolean
    observaciones?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["configuracionPagoAlumno"]>

  export type ConfiguracionPagoAlumnoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alumnoId?: boolean
    diaPago?: boolean
    metodoPago?: boolean
    descuentoFijo?: boolean
    observaciones?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["configuracionPagoAlumno"]>

  export type ConfiguracionPagoAlumnoSelectScalar = {
    id?: boolean
    alumnoId?: boolean
    diaPago?: boolean
    metodoPago?: boolean
    descuentoFijo?: boolean
    observaciones?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConfiguracionPagoAlumnoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "alumnoId" | "diaPago" | "metodoPago" | "descuentoFijo" | "observaciones" | "createdAt" | "updatedAt", ExtArgs["result"]["configuracionPagoAlumno"]>
  export type ConfiguracionPagoAlumnoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
  }
  export type ConfiguracionPagoAlumnoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
  }
  export type ConfiguracionPagoAlumnoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
  }

  export type $ConfiguracionPagoAlumnoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConfiguracionPagoAlumno"
    objects: {
      alumno: Prisma.$AlumnoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      alumnoId: number
      diaPago: number | null
      metodoPago: $Enums.TipoPago
      descuentoFijo: number | null
      observaciones: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["configuracionPagoAlumno"]>
    composites: {}
  }

  type ConfiguracionPagoAlumnoGetPayload<S extends boolean | null | undefined | ConfiguracionPagoAlumnoDefaultArgs> = $Result.GetResult<Prisma.$ConfiguracionPagoAlumnoPayload, S>

  type ConfiguracionPagoAlumnoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConfiguracionPagoAlumnoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConfiguracionPagoAlumnoCountAggregateInputType | true
    }

  export interface ConfiguracionPagoAlumnoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConfiguracionPagoAlumno'], meta: { name: 'ConfiguracionPagoAlumno' } }
    /**
     * Find zero or one ConfiguracionPagoAlumno that matches the filter.
     * @param {ConfiguracionPagoAlumnoFindUniqueArgs} args - Arguments to find a ConfiguracionPagoAlumno
     * @example
     * // Get one ConfiguracionPagoAlumno
     * const configuracionPagoAlumno = await prisma.configuracionPagoAlumno.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConfiguracionPagoAlumnoFindUniqueArgs>(args: SelectSubset<T, ConfiguracionPagoAlumnoFindUniqueArgs<ExtArgs>>): Prisma__ConfiguracionPagoAlumnoClient<$Result.GetResult<Prisma.$ConfiguracionPagoAlumnoPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ConfiguracionPagoAlumno that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConfiguracionPagoAlumnoFindUniqueOrThrowArgs} args - Arguments to find a ConfiguracionPagoAlumno
     * @example
     * // Get one ConfiguracionPagoAlumno
     * const configuracionPagoAlumno = await prisma.configuracionPagoAlumno.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConfiguracionPagoAlumnoFindUniqueOrThrowArgs>(args: SelectSubset<T, ConfiguracionPagoAlumnoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConfiguracionPagoAlumnoClient<$Result.GetResult<Prisma.$ConfiguracionPagoAlumnoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ConfiguracionPagoAlumno that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionPagoAlumnoFindFirstArgs} args - Arguments to find a ConfiguracionPagoAlumno
     * @example
     * // Get one ConfiguracionPagoAlumno
     * const configuracionPagoAlumno = await prisma.configuracionPagoAlumno.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConfiguracionPagoAlumnoFindFirstArgs>(args?: SelectSubset<T, ConfiguracionPagoAlumnoFindFirstArgs<ExtArgs>>): Prisma__ConfiguracionPagoAlumnoClient<$Result.GetResult<Prisma.$ConfiguracionPagoAlumnoPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ConfiguracionPagoAlumno that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionPagoAlumnoFindFirstOrThrowArgs} args - Arguments to find a ConfiguracionPagoAlumno
     * @example
     * // Get one ConfiguracionPagoAlumno
     * const configuracionPagoAlumno = await prisma.configuracionPagoAlumno.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConfiguracionPagoAlumnoFindFirstOrThrowArgs>(args?: SelectSubset<T, ConfiguracionPagoAlumnoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConfiguracionPagoAlumnoClient<$Result.GetResult<Prisma.$ConfiguracionPagoAlumnoPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ConfiguracionPagoAlumnos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionPagoAlumnoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConfiguracionPagoAlumnos
     * const configuracionPagoAlumnos = await prisma.configuracionPagoAlumno.findMany()
     * 
     * // Get first 10 ConfiguracionPagoAlumnos
     * const configuracionPagoAlumnos = await prisma.configuracionPagoAlumno.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configuracionPagoAlumnoWithIdOnly = await prisma.configuracionPagoAlumno.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConfiguracionPagoAlumnoFindManyArgs>(args?: SelectSubset<T, ConfiguracionPagoAlumnoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfiguracionPagoAlumnoPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ConfiguracionPagoAlumno.
     * @param {ConfiguracionPagoAlumnoCreateArgs} args - Arguments to create a ConfiguracionPagoAlumno.
     * @example
     * // Create one ConfiguracionPagoAlumno
     * const ConfiguracionPagoAlumno = await prisma.configuracionPagoAlumno.create({
     *   data: {
     *     // ... data to create a ConfiguracionPagoAlumno
     *   }
     * })
     * 
     */
    create<T extends ConfiguracionPagoAlumnoCreateArgs>(args: SelectSubset<T, ConfiguracionPagoAlumnoCreateArgs<ExtArgs>>): Prisma__ConfiguracionPagoAlumnoClient<$Result.GetResult<Prisma.$ConfiguracionPagoAlumnoPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ConfiguracionPagoAlumnos.
     * @param {ConfiguracionPagoAlumnoCreateManyArgs} args - Arguments to create many ConfiguracionPagoAlumnos.
     * @example
     * // Create many ConfiguracionPagoAlumnos
     * const configuracionPagoAlumno = await prisma.configuracionPagoAlumno.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConfiguracionPagoAlumnoCreateManyArgs>(args?: SelectSubset<T, ConfiguracionPagoAlumnoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConfiguracionPagoAlumnos and returns the data saved in the database.
     * @param {ConfiguracionPagoAlumnoCreateManyAndReturnArgs} args - Arguments to create many ConfiguracionPagoAlumnos.
     * @example
     * // Create many ConfiguracionPagoAlumnos
     * const configuracionPagoAlumno = await prisma.configuracionPagoAlumno.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConfiguracionPagoAlumnos and only return the `id`
     * const configuracionPagoAlumnoWithIdOnly = await prisma.configuracionPagoAlumno.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConfiguracionPagoAlumnoCreateManyAndReturnArgs>(args?: SelectSubset<T, ConfiguracionPagoAlumnoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfiguracionPagoAlumnoPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ConfiguracionPagoAlumno.
     * @param {ConfiguracionPagoAlumnoDeleteArgs} args - Arguments to delete one ConfiguracionPagoAlumno.
     * @example
     * // Delete one ConfiguracionPagoAlumno
     * const ConfiguracionPagoAlumno = await prisma.configuracionPagoAlumno.delete({
     *   where: {
     *     // ... filter to delete one ConfiguracionPagoAlumno
     *   }
     * })
     * 
     */
    delete<T extends ConfiguracionPagoAlumnoDeleteArgs>(args: SelectSubset<T, ConfiguracionPagoAlumnoDeleteArgs<ExtArgs>>): Prisma__ConfiguracionPagoAlumnoClient<$Result.GetResult<Prisma.$ConfiguracionPagoAlumnoPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ConfiguracionPagoAlumno.
     * @param {ConfiguracionPagoAlumnoUpdateArgs} args - Arguments to update one ConfiguracionPagoAlumno.
     * @example
     * // Update one ConfiguracionPagoAlumno
     * const configuracionPagoAlumno = await prisma.configuracionPagoAlumno.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConfiguracionPagoAlumnoUpdateArgs>(args: SelectSubset<T, ConfiguracionPagoAlumnoUpdateArgs<ExtArgs>>): Prisma__ConfiguracionPagoAlumnoClient<$Result.GetResult<Prisma.$ConfiguracionPagoAlumnoPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ConfiguracionPagoAlumnos.
     * @param {ConfiguracionPagoAlumnoDeleteManyArgs} args - Arguments to filter ConfiguracionPagoAlumnos to delete.
     * @example
     * // Delete a few ConfiguracionPagoAlumnos
     * const { count } = await prisma.configuracionPagoAlumno.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConfiguracionPagoAlumnoDeleteManyArgs>(args?: SelectSubset<T, ConfiguracionPagoAlumnoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConfiguracionPagoAlumnos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionPagoAlumnoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConfiguracionPagoAlumnos
     * const configuracionPagoAlumno = await prisma.configuracionPagoAlumno.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConfiguracionPagoAlumnoUpdateManyArgs>(args: SelectSubset<T, ConfiguracionPagoAlumnoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConfiguracionPagoAlumnos and returns the data updated in the database.
     * @param {ConfiguracionPagoAlumnoUpdateManyAndReturnArgs} args - Arguments to update many ConfiguracionPagoAlumnos.
     * @example
     * // Update many ConfiguracionPagoAlumnos
     * const configuracionPagoAlumno = await prisma.configuracionPagoAlumno.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConfiguracionPagoAlumnos and only return the `id`
     * const configuracionPagoAlumnoWithIdOnly = await prisma.configuracionPagoAlumno.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConfiguracionPagoAlumnoUpdateManyAndReturnArgs>(args: SelectSubset<T, ConfiguracionPagoAlumnoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfiguracionPagoAlumnoPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ConfiguracionPagoAlumno.
     * @param {ConfiguracionPagoAlumnoUpsertArgs} args - Arguments to update or create a ConfiguracionPagoAlumno.
     * @example
     * // Update or create a ConfiguracionPagoAlumno
     * const configuracionPagoAlumno = await prisma.configuracionPagoAlumno.upsert({
     *   create: {
     *     // ... data to create a ConfiguracionPagoAlumno
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConfiguracionPagoAlumno we want to update
     *   }
     * })
     */
    upsert<T extends ConfiguracionPagoAlumnoUpsertArgs>(args: SelectSubset<T, ConfiguracionPagoAlumnoUpsertArgs<ExtArgs>>): Prisma__ConfiguracionPagoAlumnoClient<$Result.GetResult<Prisma.$ConfiguracionPagoAlumnoPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ConfiguracionPagoAlumnos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionPagoAlumnoCountArgs} args - Arguments to filter ConfiguracionPagoAlumnos to count.
     * @example
     * // Count the number of ConfiguracionPagoAlumnos
     * const count = await prisma.configuracionPagoAlumno.count({
     *   where: {
     *     // ... the filter for the ConfiguracionPagoAlumnos we want to count
     *   }
     * })
    **/
    count<T extends ConfiguracionPagoAlumnoCountArgs>(
      args?: Subset<T, ConfiguracionPagoAlumnoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfiguracionPagoAlumnoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConfiguracionPagoAlumno.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionPagoAlumnoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfiguracionPagoAlumnoAggregateArgs>(args: Subset<T, ConfiguracionPagoAlumnoAggregateArgs>): Prisma.PrismaPromise<GetConfiguracionPagoAlumnoAggregateType<T>>

    /**
     * Group by ConfiguracionPagoAlumno.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionPagoAlumnoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfiguracionPagoAlumnoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfiguracionPagoAlumnoGroupByArgs['orderBy'] }
        : { orderBy?: ConfiguracionPagoAlumnoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfiguracionPagoAlumnoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfiguracionPagoAlumnoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConfiguracionPagoAlumno model
   */
  readonly fields: ConfiguracionPagoAlumnoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConfiguracionPagoAlumno.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfiguracionPagoAlumnoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    alumno<T extends AlumnoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlumnoDefaultArgs<ExtArgs>>): Prisma__AlumnoClient<$Result.GetResult<Prisma.$AlumnoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConfiguracionPagoAlumno model
   */ 
  interface ConfiguracionPagoAlumnoFieldRefs {
    readonly id: FieldRef<"ConfiguracionPagoAlumno", 'Int'>
    readonly alumnoId: FieldRef<"ConfiguracionPagoAlumno", 'Int'>
    readonly diaPago: FieldRef<"ConfiguracionPagoAlumno", 'Int'>
    readonly metodoPago: FieldRef<"ConfiguracionPagoAlumno", 'TipoPago'>
    readonly descuentoFijo: FieldRef<"ConfiguracionPagoAlumno", 'Float'>
    readonly observaciones: FieldRef<"ConfiguracionPagoAlumno", 'String'>
    readonly createdAt: FieldRef<"ConfiguracionPagoAlumno", 'DateTime'>
    readonly updatedAt: FieldRef<"ConfiguracionPagoAlumno", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConfiguracionPagoAlumno findUnique
   */
  export type ConfiguracionPagoAlumnoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionPagoAlumno
     */
    select?: ConfiguracionPagoAlumnoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfiguracionPagoAlumno
     */
    omit?: ConfiguracionPagoAlumnoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfiguracionPagoAlumnoInclude<ExtArgs> | null
    /**
     * Filter, which ConfiguracionPagoAlumno to fetch.
     */
    where: ConfiguracionPagoAlumnoWhereUniqueInput
  }

  /**
   * ConfiguracionPagoAlumno findUniqueOrThrow
   */
  export type ConfiguracionPagoAlumnoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionPagoAlumno
     */
    select?: ConfiguracionPagoAlumnoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfiguracionPagoAlumno
     */
    omit?: ConfiguracionPagoAlumnoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfiguracionPagoAlumnoInclude<ExtArgs> | null
    /**
     * Filter, which ConfiguracionPagoAlumno to fetch.
     */
    where: ConfiguracionPagoAlumnoWhereUniqueInput
  }

  /**
   * ConfiguracionPagoAlumno findFirst
   */
  export type ConfiguracionPagoAlumnoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionPagoAlumno
     */
    select?: ConfiguracionPagoAlumnoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfiguracionPagoAlumno
     */
    omit?: ConfiguracionPagoAlumnoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfiguracionPagoAlumnoInclude<ExtArgs> | null
    /**
     * Filter, which ConfiguracionPagoAlumno to fetch.
     */
    where?: ConfiguracionPagoAlumnoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfiguracionPagoAlumnos to fetch.
     */
    orderBy?: ConfiguracionPagoAlumnoOrderByWithRelationInput | ConfiguracionPagoAlumnoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfiguracionPagoAlumnos.
     */
    cursor?: ConfiguracionPagoAlumnoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfiguracionPagoAlumnos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfiguracionPagoAlumnos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfiguracionPagoAlumnos.
     */
    distinct?: ConfiguracionPagoAlumnoScalarFieldEnum | ConfiguracionPagoAlumnoScalarFieldEnum[]
  }

  /**
   * ConfiguracionPagoAlumno findFirstOrThrow
   */
  export type ConfiguracionPagoAlumnoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionPagoAlumno
     */
    select?: ConfiguracionPagoAlumnoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfiguracionPagoAlumno
     */
    omit?: ConfiguracionPagoAlumnoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfiguracionPagoAlumnoInclude<ExtArgs> | null
    /**
     * Filter, which ConfiguracionPagoAlumno to fetch.
     */
    where?: ConfiguracionPagoAlumnoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfiguracionPagoAlumnos to fetch.
     */
    orderBy?: ConfiguracionPagoAlumnoOrderByWithRelationInput | ConfiguracionPagoAlumnoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfiguracionPagoAlumnos.
     */
    cursor?: ConfiguracionPagoAlumnoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfiguracionPagoAlumnos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfiguracionPagoAlumnos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfiguracionPagoAlumnos.
     */
    distinct?: ConfiguracionPagoAlumnoScalarFieldEnum | ConfiguracionPagoAlumnoScalarFieldEnum[]
  }

  /**
   * ConfiguracionPagoAlumno findMany
   */
  export type ConfiguracionPagoAlumnoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionPagoAlumno
     */
    select?: ConfiguracionPagoAlumnoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfiguracionPagoAlumno
     */
    omit?: ConfiguracionPagoAlumnoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfiguracionPagoAlumnoInclude<ExtArgs> | null
    /**
     * Filter, which ConfiguracionPagoAlumnos to fetch.
     */
    where?: ConfiguracionPagoAlumnoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfiguracionPagoAlumnos to fetch.
     */
    orderBy?: ConfiguracionPagoAlumnoOrderByWithRelationInput | ConfiguracionPagoAlumnoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConfiguracionPagoAlumnos.
     */
    cursor?: ConfiguracionPagoAlumnoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfiguracionPagoAlumnos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfiguracionPagoAlumnos.
     */
    skip?: number
    distinct?: ConfiguracionPagoAlumnoScalarFieldEnum | ConfiguracionPagoAlumnoScalarFieldEnum[]
  }

  /**
   * ConfiguracionPagoAlumno create
   */
  export type ConfiguracionPagoAlumnoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionPagoAlumno
     */
    select?: ConfiguracionPagoAlumnoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfiguracionPagoAlumno
     */
    omit?: ConfiguracionPagoAlumnoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfiguracionPagoAlumnoInclude<ExtArgs> | null
    /**
     * The data needed to create a ConfiguracionPagoAlumno.
     */
    data: XOR<ConfiguracionPagoAlumnoCreateInput, ConfiguracionPagoAlumnoUncheckedCreateInput>
  }

  /**
   * ConfiguracionPagoAlumno createMany
   */
  export type ConfiguracionPagoAlumnoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConfiguracionPagoAlumnos.
     */
    data: ConfiguracionPagoAlumnoCreateManyInput | ConfiguracionPagoAlumnoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConfiguracionPagoAlumno createManyAndReturn
   */
  export type ConfiguracionPagoAlumnoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionPagoAlumno
     */
    select?: ConfiguracionPagoAlumnoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConfiguracionPagoAlumno
     */
    omit?: ConfiguracionPagoAlumnoOmit<ExtArgs> | null
    /**
     * The data used to create many ConfiguracionPagoAlumnos.
     */
    data: ConfiguracionPagoAlumnoCreateManyInput | ConfiguracionPagoAlumnoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfiguracionPagoAlumnoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConfiguracionPagoAlumno update
   */
  export type ConfiguracionPagoAlumnoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionPagoAlumno
     */
    select?: ConfiguracionPagoAlumnoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfiguracionPagoAlumno
     */
    omit?: ConfiguracionPagoAlumnoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfiguracionPagoAlumnoInclude<ExtArgs> | null
    /**
     * The data needed to update a ConfiguracionPagoAlumno.
     */
    data: XOR<ConfiguracionPagoAlumnoUpdateInput, ConfiguracionPagoAlumnoUncheckedUpdateInput>
    /**
     * Choose, which ConfiguracionPagoAlumno to update.
     */
    where: ConfiguracionPagoAlumnoWhereUniqueInput
  }

  /**
   * ConfiguracionPagoAlumno updateMany
   */
  export type ConfiguracionPagoAlumnoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConfiguracionPagoAlumnos.
     */
    data: XOR<ConfiguracionPagoAlumnoUpdateManyMutationInput, ConfiguracionPagoAlumnoUncheckedUpdateManyInput>
    /**
     * Filter which ConfiguracionPagoAlumnos to update
     */
    where?: ConfiguracionPagoAlumnoWhereInput
  }

  /**
   * ConfiguracionPagoAlumno updateManyAndReturn
   */
  export type ConfiguracionPagoAlumnoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionPagoAlumno
     */
    select?: ConfiguracionPagoAlumnoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConfiguracionPagoAlumno
     */
    omit?: ConfiguracionPagoAlumnoOmit<ExtArgs> | null
    /**
     * The data used to update ConfiguracionPagoAlumnos.
     */
    data: XOR<ConfiguracionPagoAlumnoUpdateManyMutationInput, ConfiguracionPagoAlumnoUncheckedUpdateManyInput>
    /**
     * Filter which ConfiguracionPagoAlumnos to update
     */
    where?: ConfiguracionPagoAlumnoWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfiguracionPagoAlumnoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConfiguracionPagoAlumno upsert
   */
  export type ConfiguracionPagoAlumnoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionPagoAlumno
     */
    select?: ConfiguracionPagoAlumnoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfiguracionPagoAlumno
     */
    omit?: ConfiguracionPagoAlumnoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfiguracionPagoAlumnoInclude<ExtArgs> | null
    /**
     * The filter to search for the ConfiguracionPagoAlumno to update in case it exists.
     */
    where: ConfiguracionPagoAlumnoWhereUniqueInput
    /**
     * In case the ConfiguracionPagoAlumno found by the `where` argument doesn't exist, create a new ConfiguracionPagoAlumno with this data.
     */
    create: XOR<ConfiguracionPagoAlumnoCreateInput, ConfiguracionPagoAlumnoUncheckedCreateInput>
    /**
     * In case the ConfiguracionPagoAlumno was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfiguracionPagoAlumnoUpdateInput, ConfiguracionPagoAlumnoUncheckedUpdateInput>
  }

  /**
   * ConfiguracionPagoAlumno delete
   */
  export type ConfiguracionPagoAlumnoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionPagoAlumno
     */
    select?: ConfiguracionPagoAlumnoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfiguracionPagoAlumno
     */
    omit?: ConfiguracionPagoAlumnoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfiguracionPagoAlumnoInclude<ExtArgs> | null
    /**
     * Filter which ConfiguracionPagoAlumno to delete.
     */
    where: ConfiguracionPagoAlumnoWhereUniqueInput
  }

  /**
   * ConfiguracionPagoAlumno deleteMany
   */
  export type ConfiguracionPagoAlumnoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfiguracionPagoAlumnos to delete
     */
    where?: ConfiguracionPagoAlumnoWhereInput
  }

  /**
   * ConfiguracionPagoAlumno without action
   */
  export type ConfiguracionPagoAlumnoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionPagoAlumno
     */
    select?: ConfiguracionPagoAlumnoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfiguracionPagoAlumno
     */
    omit?: ConfiguracionPagoAlumnoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfiguracionPagoAlumnoInclude<ExtArgs> | null
  }


  /**
   * Model Descuento
   */

  export type AggregateDescuento = {
    _count: DescuentoCountAggregateOutputType | null
    _avg: DescuentoAvgAggregateOutputType | null
    _sum: DescuentoSumAggregateOutputType | null
    _min: DescuentoMinAggregateOutputType | null
    _max: DescuentoMaxAggregateOutputType | null
  }

  export type DescuentoAvgAggregateOutputType = {
    id: number | null
    porcentaje: number | null
    minEstilos: number | null
  }

  export type DescuentoSumAggregateOutputType = {
    id: number | null
    porcentaje: number | null
    minEstilos: number | null
  }

  export type DescuentoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    porcentaje: number | null
    activo: boolean | null
    esAutomatico: boolean | null
    minEstilos: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DescuentoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    porcentaje: number | null
    activo: boolean | null
    esAutomatico: boolean | null
    minEstilos: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DescuentoCountAggregateOutputType = {
    id: number
    nombre: number
    porcentaje: number
    activo: number
    esAutomatico: number
    minEstilos: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DescuentoAvgAggregateInputType = {
    id?: true
    porcentaje?: true
    minEstilos?: true
  }

  export type DescuentoSumAggregateInputType = {
    id?: true
    porcentaje?: true
    minEstilos?: true
  }

  export type DescuentoMinAggregateInputType = {
    id?: true
    nombre?: true
    porcentaje?: true
    activo?: true
    esAutomatico?: true
    minEstilos?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DescuentoMaxAggregateInputType = {
    id?: true
    nombre?: true
    porcentaje?: true
    activo?: true
    esAutomatico?: true
    minEstilos?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DescuentoCountAggregateInputType = {
    id?: true
    nombre?: true
    porcentaje?: true
    activo?: true
    esAutomatico?: true
    minEstilos?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DescuentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Descuento to aggregate.
     */
    where?: DescuentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Descuentos to fetch.
     */
    orderBy?: DescuentoOrderByWithRelationInput | DescuentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DescuentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Descuentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Descuentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Descuentos
    **/
    _count?: true | DescuentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DescuentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DescuentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DescuentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DescuentoMaxAggregateInputType
  }

  export type GetDescuentoAggregateType<T extends DescuentoAggregateArgs> = {
        [P in keyof T & keyof AggregateDescuento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDescuento[P]>
      : GetScalarType<T[P], AggregateDescuento[P]>
  }




  export type DescuentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DescuentoWhereInput
    orderBy?: DescuentoOrderByWithAggregationInput | DescuentoOrderByWithAggregationInput[]
    by: DescuentoScalarFieldEnum[] | DescuentoScalarFieldEnum
    having?: DescuentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DescuentoCountAggregateInputType | true
    _avg?: DescuentoAvgAggregateInputType
    _sum?: DescuentoSumAggregateInputType
    _min?: DescuentoMinAggregateInputType
    _max?: DescuentoMaxAggregateInputType
  }

  export type DescuentoGroupByOutputType = {
    id: number
    nombre: string
    porcentaje: number
    activo: boolean
    esAutomatico: boolean
    minEstilos: number | null
    createdAt: Date
    updatedAt: Date
    _count: DescuentoCountAggregateOutputType | null
    _avg: DescuentoAvgAggregateOutputType | null
    _sum: DescuentoSumAggregateOutputType | null
    _min: DescuentoMinAggregateOutputType | null
    _max: DescuentoMaxAggregateOutputType | null
  }

  type GetDescuentoGroupByPayload<T extends DescuentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DescuentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DescuentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DescuentoGroupByOutputType[P]>
            : GetScalarType<T[P], DescuentoGroupByOutputType[P]>
        }
      >
    >


  export type DescuentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    porcentaje?: boolean
    activo?: boolean
    esAutomatico?: boolean
    minEstilos?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aplicadoA?: boolean | Descuento$aplicadoAArgs<ExtArgs>
    _count?: boolean | DescuentoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["descuento"]>

  export type DescuentoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    porcentaje?: boolean
    activo?: boolean
    esAutomatico?: boolean
    minEstilos?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["descuento"]>

  export type DescuentoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    porcentaje?: boolean
    activo?: boolean
    esAutomatico?: boolean
    minEstilos?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["descuento"]>

  export type DescuentoSelectScalar = {
    id?: boolean
    nombre?: boolean
    porcentaje?: boolean
    activo?: boolean
    esAutomatico?: boolean
    minEstilos?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DescuentoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "porcentaje" | "activo" | "esAutomatico" | "minEstilos" | "createdAt" | "updatedAt", ExtArgs["result"]["descuento"]>
  export type DescuentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aplicadoA?: boolean | Descuento$aplicadoAArgs<ExtArgs>
    _count?: boolean | DescuentoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DescuentoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DescuentoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DescuentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Descuento"
    objects: {
      aplicadoA: Prisma.$DescuentoAplicadoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      porcentaje: number
      activo: boolean
      esAutomatico: boolean
      minEstilos: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["descuento"]>
    composites: {}
  }

  type DescuentoGetPayload<S extends boolean | null | undefined | DescuentoDefaultArgs> = $Result.GetResult<Prisma.$DescuentoPayload, S>

  type DescuentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DescuentoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DescuentoCountAggregateInputType | true
    }

  export interface DescuentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Descuento'], meta: { name: 'Descuento' } }
    /**
     * Find zero or one Descuento that matches the filter.
     * @param {DescuentoFindUniqueArgs} args - Arguments to find a Descuento
     * @example
     * // Get one Descuento
     * const descuento = await prisma.descuento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DescuentoFindUniqueArgs>(args: SelectSubset<T, DescuentoFindUniqueArgs<ExtArgs>>): Prisma__DescuentoClient<$Result.GetResult<Prisma.$DescuentoPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Descuento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DescuentoFindUniqueOrThrowArgs} args - Arguments to find a Descuento
     * @example
     * // Get one Descuento
     * const descuento = await prisma.descuento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DescuentoFindUniqueOrThrowArgs>(args: SelectSubset<T, DescuentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DescuentoClient<$Result.GetResult<Prisma.$DescuentoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Descuento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DescuentoFindFirstArgs} args - Arguments to find a Descuento
     * @example
     * // Get one Descuento
     * const descuento = await prisma.descuento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DescuentoFindFirstArgs>(args?: SelectSubset<T, DescuentoFindFirstArgs<ExtArgs>>): Prisma__DescuentoClient<$Result.GetResult<Prisma.$DescuentoPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Descuento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DescuentoFindFirstOrThrowArgs} args - Arguments to find a Descuento
     * @example
     * // Get one Descuento
     * const descuento = await prisma.descuento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DescuentoFindFirstOrThrowArgs>(args?: SelectSubset<T, DescuentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__DescuentoClient<$Result.GetResult<Prisma.$DescuentoPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Descuentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DescuentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Descuentos
     * const descuentos = await prisma.descuento.findMany()
     * 
     * // Get first 10 Descuentos
     * const descuentos = await prisma.descuento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const descuentoWithIdOnly = await prisma.descuento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DescuentoFindManyArgs>(args?: SelectSubset<T, DescuentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DescuentoPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Descuento.
     * @param {DescuentoCreateArgs} args - Arguments to create a Descuento.
     * @example
     * // Create one Descuento
     * const Descuento = await prisma.descuento.create({
     *   data: {
     *     // ... data to create a Descuento
     *   }
     * })
     * 
     */
    create<T extends DescuentoCreateArgs>(args: SelectSubset<T, DescuentoCreateArgs<ExtArgs>>): Prisma__DescuentoClient<$Result.GetResult<Prisma.$DescuentoPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Descuentos.
     * @param {DescuentoCreateManyArgs} args - Arguments to create many Descuentos.
     * @example
     * // Create many Descuentos
     * const descuento = await prisma.descuento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DescuentoCreateManyArgs>(args?: SelectSubset<T, DescuentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Descuentos and returns the data saved in the database.
     * @param {DescuentoCreateManyAndReturnArgs} args - Arguments to create many Descuentos.
     * @example
     * // Create many Descuentos
     * const descuento = await prisma.descuento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Descuentos and only return the `id`
     * const descuentoWithIdOnly = await prisma.descuento.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DescuentoCreateManyAndReturnArgs>(args?: SelectSubset<T, DescuentoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DescuentoPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Descuento.
     * @param {DescuentoDeleteArgs} args - Arguments to delete one Descuento.
     * @example
     * // Delete one Descuento
     * const Descuento = await prisma.descuento.delete({
     *   where: {
     *     // ... filter to delete one Descuento
     *   }
     * })
     * 
     */
    delete<T extends DescuentoDeleteArgs>(args: SelectSubset<T, DescuentoDeleteArgs<ExtArgs>>): Prisma__DescuentoClient<$Result.GetResult<Prisma.$DescuentoPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Descuento.
     * @param {DescuentoUpdateArgs} args - Arguments to update one Descuento.
     * @example
     * // Update one Descuento
     * const descuento = await prisma.descuento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DescuentoUpdateArgs>(args: SelectSubset<T, DescuentoUpdateArgs<ExtArgs>>): Prisma__DescuentoClient<$Result.GetResult<Prisma.$DescuentoPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Descuentos.
     * @param {DescuentoDeleteManyArgs} args - Arguments to filter Descuentos to delete.
     * @example
     * // Delete a few Descuentos
     * const { count } = await prisma.descuento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DescuentoDeleteManyArgs>(args?: SelectSubset<T, DescuentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Descuentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DescuentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Descuentos
     * const descuento = await prisma.descuento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DescuentoUpdateManyArgs>(args: SelectSubset<T, DescuentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Descuentos and returns the data updated in the database.
     * @param {DescuentoUpdateManyAndReturnArgs} args - Arguments to update many Descuentos.
     * @example
     * // Update many Descuentos
     * const descuento = await prisma.descuento.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Descuentos and only return the `id`
     * const descuentoWithIdOnly = await prisma.descuento.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DescuentoUpdateManyAndReturnArgs>(args: SelectSubset<T, DescuentoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DescuentoPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Descuento.
     * @param {DescuentoUpsertArgs} args - Arguments to update or create a Descuento.
     * @example
     * // Update or create a Descuento
     * const descuento = await prisma.descuento.upsert({
     *   create: {
     *     // ... data to create a Descuento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Descuento we want to update
     *   }
     * })
     */
    upsert<T extends DescuentoUpsertArgs>(args: SelectSubset<T, DescuentoUpsertArgs<ExtArgs>>): Prisma__DescuentoClient<$Result.GetResult<Prisma.$DescuentoPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Descuentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DescuentoCountArgs} args - Arguments to filter Descuentos to count.
     * @example
     * // Count the number of Descuentos
     * const count = await prisma.descuento.count({
     *   where: {
     *     // ... the filter for the Descuentos we want to count
     *   }
     * })
    **/
    count<T extends DescuentoCountArgs>(
      args?: Subset<T, DescuentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DescuentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Descuento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DescuentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DescuentoAggregateArgs>(args: Subset<T, DescuentoAggregateArgs>): Prisma.PrismaPromise<GetDescuentoAggregateType<T>>

    /**
     * Group by Descuento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DescuentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DescuentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DescuentoGroupByArgs['orderBy'] }
        : { orderBy?: DescuentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DescuentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDescuentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Descuento model
   */
  readonly fields: DescuentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Descuento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DescuentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aplicadoA<T extends Descuento$aplicadoAArgs<ExtArgs> = {}>(args?: Subset<T, Descuento$aplicadoAArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DescuentoAplicadoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Descuento model
   */ 
  interface DescuentoFieldRefs {
    readonly id: FieldRef<"Descuento", 'Int'>
    readonly nombre: FieldRef<"Descuento", 'String'>
    readonly porcentaje: FieldRef<"Descuento", 'Float'>
    readonly activo: FieldRef<"Descuento", 'Boolean'>
    readonly esAutomatico: FieldRef<"Descuento", 'Boolean'>
    readonly minEstilos: FieldRef<"Descuento", 'Int'>
    readonly createdAt: FieldRef<"Descuento", 'DateTime'>
    readonly updatedAt: FieldRef<"Descuento", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Descuento findUnique
   */
  export type DescuentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Descuento
     */
    select?: DescuentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Descuento
     */
    omit?: DescuentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DescuentoInclude<ExtArgs> | null
    /**
     * Filter, which Descuento to fetch.
     */
    where: DescuentoWhereUniqueInput
  }

  /**
   * Descuento findUniqueOrThrow
   */
  export type DescuentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Descuento
     */
    select?: DescuentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Descuento
     */
    omit?: DescuentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DescuentoInclude<ExtArgs> | null
    /**
     * Filter, which Descuento to fetch.
     */
    where: DescuentoWhereUniqueInput
  }

  /**
   * Descuento findFirst
   */
  export type DescuentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Descuento
     */
    select?: DescuentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Descuento
     */
    omit?: DescuentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DescuentoInclude<ExtArgs> | null
    /**
     * Filter, which Descuento to fetch.
     */
    where?: DescuentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Descuentos to fetch.
     */
    orderBy?: DescuentoOrderByWithRelationInput | DescuentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Descuentos.
     */
    cursor?: DescuentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Descuentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Descuentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Descuentos.
     */
    distinct?: DescuentoScalarFieldEnum | DescuentoScalarFieldEnum[]
  }

  /**
   * Descuento findFirstOrThrow
   */
  export type DescuentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Descuento
     */
    select?: DescuentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Descuento
     */
    omit?: DescuentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DescuentoInclude<ExtArgs> | null
    /**
     * Filter, which Descuento to fetch.
     */
    where?: DescuentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Descuentos to fetch.
     */
    orderBy?: DescuentoOrderByWithRelationInput | DescuentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Descuentos.
     */
    cursor?: DescuentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Descuentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Descuentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Descuentos.
     */
    distinct?: DescuentoScalarFieldEnum | DescuentoScalarFieldEnum[]
  }

  /**
   * Descuento findMany
   */
  export type DescuentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Descuento
     */
    select?: DescuentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Descuento
     */
    omit?: DescuentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DescuentoInclude<ExtArgs> | null
    /**
     * Filter, which Descuentos to fetch.
     */
    where?: DescuentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Descuentos to fetch.
     */
    orderBy?: DescuentoOrderByWithRelationInput | DescuentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Descuentos.
     */
    cursor?: DescuentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Descuentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Descuentos.
     */
    skip?: number
    distinct?: DescuentoScalarFieldEnum | DescuentoScalarFieldEnum[]
  }

  /**
   * Descuento create
   */
  export type DescuentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Descuento
     */
    select?: DescuentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Descuento
     */
    omit?: DescuentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DescuentoInclude<ExtArgs> | null
    /**
     * The data needed to create a Descuento.
     */
    data: XOR<DescuentoCreateInput, DescuentoUncheckedCreateInput>
  }

  /**
   * Descuento createMany
   */
  export type DescuentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Descuentos.
     */
    data: DescuentoCreateManyInput | DescuentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Descuento createManyAndReturn
   */
  export type DescuentoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Descuento
     */
    select?: DescuentoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Descuento
     */
    omit?: DescuentoOmit<ExtArgs> | null
    /**
     * The data used to create many Descuentos.
     */
    data: DescuentoCreateManyInput | DescuentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Descuento update
   */
  export type DescuentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Descuento
     */
    select?: DescuentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Descuento
     */
    omit?: DescuentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DescuentoInclude<ExtArgs> | null
    /**
     * The data needed to update a Descuento.
     */
    data: XOR<DescuentoUpdateInput, DescuentoUncheckedUpdateInput>
    /**
     * Choose, which Descuento to update.
     */
    where: DescuentoWhereUniqueInput
  }

  /**
   * Descuento updateMany
   */
  export type DescuentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Descuentos.
     */
    data: XOR<DescuentoUpdateManyMutationInput, DescuentoUncheckedUpdateManyInput>
    /**
     * Filter which Descuentos to update
     */
    where?: DescuentoWhereInput
  }

  /**
   * Descuento updateManyAndReturn
   */
  export type DescuentoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Descuento
     */
    select?: DescuentoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Descuento
     */
    omit?: DescuentoOmit<ExtArgs> | null
    /**
     * The data used to update Descuentos.
     */
    data: XOR<DescuentoUpdateManyMutationInput, DescuentoUncheckedUpdateManyInput>
    /**
     * Filter which Descuentos to update
     */
    where?: DescuentoWhereInput
  }

  /**
   * Descuento upsert
   */
  export type DescuentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Descuento
     */
    select?: DescuentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Descuento
     */
    omit?: DescuentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DescuentoInclude<ExtArgs> | null
    /**
     * The filter to search for the Descuento to update in case it exists.
     */
    where: DescuentoWhereUniqueInput
    /**
     * In case the Descuento found by the `where` argument doesn't exist, create a new Descuento with this data.
     */
    create: XOR<DescuentoCreateInput, DescuentoUncheckedCreateInput>
    /**
     * In case the Descuento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DescuentoUpdateInput, DescuentoUncheckedUpdateInput>
  }

  /**
   * Descuento delete
   */
  export type DescuentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Descuento
     */
    select?: DescuentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Descuento
     */
    omit?: DescuentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DescuentoInclude<ExtArgs> | null
    /**
     * Filter which Descuento to delete.
     */
    where: DescuentoWhereUniqueInput
  }

  /**
   * Descuento deleteMany
   */
  export type DescuentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Descuentos to delete
     */
    where?: DescuentoWhereInput
  }

  /**
   * Descuento.aplicadoA
   */
  export type Descuento$aplicadoAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DescuentoAplicado
     */
    select?: DescuentoAplicadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DescuentoAplicado
     */
    omit?: DescuentoAplicadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DescuentoAplicadoInclude<ExtArgs> | null
    where?: DescuentoAplicadoWhereInput
    orderBy?: DescuentoAplicadoOrderByWithRelationInput | DescuentoAplicadoOrderByWithRelationInput[]
    cursor?: DescuentoAplicadoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DescuentoAplicadoScalarFieldEnum | DescuentoAplicadoScalarFieldEnum[]
  }

  /**
   * Descuento without action
   */
  export type DescuentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Descuento
     */
    select?: DescuentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Descuento
     */
    omit?: DescuentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DescuentoInclude<ExtArgs> | null
  }


  /**
   * Model DescuentoAplicado
   */

  export type AggregateDescuentoAplicado = {
    _count: DescuentoAplicadoCountAggregateOutputType | null
    _avg: DescuentoAplicadoAvgAggregateOutputType | null
    _sum: DescuentoAplicadoSumAggregateOutputType | null
    _min: DescuentoAplicadoMinAggregateOutputType | null
    _max: DescuentoAplicadoMaxAggregateOutputType | null
  }

  export type DescuentoAplicadoAvgAggregateOutputType = {
    id: number | null
    descuentoId: number | null
    alumnoId: number | null
  }

  export type DescuentoAplicadoSumAggregateOutputType = {
    id: number | null
    descuentoId: number | null
    alumnoId: number | null
  }

  export type DescuentoAplicadoMinAggregateOutputType = {
    id: number | null
    descuentoId: number | null
    alumnoId: number | null
    fechaInicio: Date | null
    fechaFin: Date | null
    activo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DescuentoAplicadoMaxAggregateOutputType = {
    id: number | null
    descuentoId: number | null
    alumnoId: number | null
    fechaInicio: Date | null
    fechaFin: Date | null
    activo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DescuentoAplicadoCountAggregateOutputType = {
    id: number
    descuentoId: number
    alumnoId: number
    fechaInicio: number
    fechaFin: number
    activo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DescuentoAplicadoAvgAggregateInputType = {
    id?: true
    descuentoId?: true
    alumnoId?: true
  }

  export type DescuentoAplicadoSumAggregateInputType = {
    id?: true
    descuentoId?: true
    alumnoId?: true
  }

  export type DescuentoAplicadoMinAggregateInputType = {
    id?: true
    descuentoId?: true
    alumnoId?: true
    fechaInicio?: true
    fechaFin?: true
    activo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DescuentoAplicadoMaxAggregateInputType = {
    id?: true
    descuentoId?: true
    alumnoId?: true
    fechaInicio?: true
    fechaFin?: true
    activo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DescuentoAplicadoCountAggregateInputType = {
    id?: true
    descuentoId?: true
    alumnoId?: true
    fechaInicio?: true
    fechaFin?: true
    activo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DescuentoAplicadoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DescuentoAplicado to aggregate.
     */
    where?: DescuentoAplicadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DescuentoAplicados to fetch.
     */
    orderBy?: DescuentoAplicadoOrderByWithRelationInput | DescuentoAplicadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DescuentoAplicadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DescuentoAplicados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DescuentoAplicados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DescuentoAplicados
    **/
    _count?: true | DescuentoAplicadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DescuentoAplicadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DescuentoAplicadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DescuentoAplicadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DescuentoAplicadoMaxAggregateInputType
  }

  export type GetDescuentoAplicadoAggregateType<T extends DescuentoAplicadoAggregateArgs> = {
        [P in keyof T & keyof AggregateDescuentoAplicado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDescuentoAplicado[P]>
      : GetScalarType<T[P], AggregateDescuentoAplicado[P]>
  }




  export type DescuentoAplicadoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DescuentoAplicadoWhereInput
    orderBy?: DescuentoAplicadoOrderByWithAggregationInput | DescuentoAplicadoOrderByWithAggregationInput[]
    by: DescuentoAplicadoScalarFieldEnum[] | DescuentoAplicadoScalarFieldEnum
    having?: DescuentoAplicadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DescuentoAplicadoCountAggregateInputType | true
    _avg?: DescuentoAplicadoAvgAggregateInputType
    _sum?: DescuentoAplicadoSumAggregateInputType
    _min?: DescuentoAplicadoMinAggregateInputType
    _max?: DescuentoAplicadoMaxAggregateInputType
  }

  export type DescuentoAplicadoGroupByOutputType = {
    id: number
    descuentoId: number
    alumnoId: number
    fechaInicio: Date
    fechaFin: Date | null
    activo: boolean
    createdAt: Date
    updatedAt: Date
    _count: DescuentoAplicadoCountAggregateOutputType | null
    _avg: DescuentoAplicadoAvgAggregateOutputType | null
    _sum: DescuentoAplicadoSumAggregateOutputType | null
    _min: DescuentoAplicadoMinAggregateOutputType | null
    _max: DescuentoAplicadoMaxAggregateOutputType | null
  }

  type GetDescuentoAplicadoGroupByPayload<T extends DescuentoAplicadoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DescuentoAplicadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DescuentoAplicadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DescuentoAplicadoGroupByOutputType[P]>
            : GetScalarType<T[P], DescuentoAplicadoGroupByOutputType[P]>
        }
      >
    >


  export type DescuentoAplicadoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descuentoId?: boolean
    alumnoId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    activo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    descuento?: boolean | DescuentoDefaultArgs<ExtArgs>
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["descuentoAplicado"]>

  export type DescuentoAplicadoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descuentoId?: boolean
    alumnoId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    activo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    descuento?: boolean | DescuentoDefaultArgs<ExtArgs>
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["descuentoAplicado"]>

  export type DescuentoAplicadoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descuentoId?: boolean
    alumnoId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    activo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    descuento?: boolean | DescuentoDefaultArgs<ExtArgs>
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["descuentoAplicado"]>

  export type DescuentoAplicadoSelectScalar = {
    id?: boolean
    descuentoId?: boolean
    alumnoId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    activo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DescuentoAplicadoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descuentoId" | "alumnoId" | "fechaInicio" | "fechaFin" | "activo" | "createdAt" | "updatedAt", ExtArgs["result"]["descuentoAplicado"]>
  export type DescuentoAplicadoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    descuento?: boolean | DescuentoDefaultArgs<ExtArgs>
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
  }
  export type DescuentoAplicadoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    descuento?: boolean | DescuentoDefaultArgs<ExtArgs>
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
  }
  export type DescuentoAplicadoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    descuento?: boolean | DescuentoDefaultArgs<ExtArgs>
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
  }

  export type $DescuentoAplicadoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DescuentoAplicado"
    objects: {
      descuento: Prisma.$DescuentoPayload<ExtArgs>
      alumno: Prisma.$AlumnoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descuentoId: number
      alumnoId: number
      fechaInicio: Date
      fechaFin: Date | null
      activo: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["descuentoAplicado"]>
    composites: {}
  }

  type DescuentoAplicadoGetPayload<S extends boolean | null | undefined | DescuentoAplicadoDefaultArgs> = $Result.GetResult<Prisma.$DescuentoAplicadoPayload, S>

  type DescuentoAplicadoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DescuentoAplicadoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DescuentoAplicadoCountAggregateInputType | true
    }

  export interface DescuentoAplicadoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DescuentoAplicado'], meta: { name: 'DescuentoAplicado' } }
    /**
     * Find zero or one DescuentoAplicado that matches the filter.
     * @param {DescuentoAplicadoFindUniqueArgs} args - Arguments to find a DescuentoAplicado
     * @example
     * // Get one DescuentoAplicado
     * const descuentoAplicado = await prisma.descuentoAplicado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DescuentoAplicadoFindUniqueArgs>(args: SelectSubset<T, DescuentoAplicadoFindUniqueArgs<ExtArgs>>): Prisma__DescuentoAplicadoClient<$Result.GetResult<Prisma.$DescuentoAplicadoPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DescuentoAplicado that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DescuentoAplicadoFindUniqueOrThrowArgs} args - Arguments to find a DescuentoAplicado
     * @example
     * // Get one DescuentoAplicado
     * const descuentoAplicado = await prisma.descuentoAplicado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DescuentoAplicadoFindUniqueOrThrowArgs>(args: SelectSubset<T, DescuentoAplicadoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DescuentoAplicadoClient<$Result.GetResult<Prisma.$DescuentoAplicadoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DescuentoAplicado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DescuentoAplicadoFindFirstArgs} args - Arguments to find a DescuentoAplicado
     * @example
     * // Get one DescuentoAplicado
     * const descuentoAplicado = await prisma.descuentoAplicado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DescuentoAplicadoFindFirstArgs>(args?: SelectSubset<T, DescuentoAplicadoFindFirstArgs<ExtArgs>>): Prisma__DescuentoAplicadoClient<$Result.GetResult<Prisma.$DescuentoAplicadoPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DescuentoAplicado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DescuentoAplicadoFindFirstOrThrowArgs} args - Arguments to find a DescuentoAplicado
     * @example
     * // Get one DescuentoAplicado
     * const descuentoAplicado = await prisma.descuentoAplicado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DescuentoAplicadoFindFirstOrThrowArgs>(args?: SelectSubset<T, DescuentoAplicadoFindFirstOrThrowArgs<ExtArgs>>): Prisma__DescuentoAplicadoClient<$Result.GetResult<Prisma.$DescuentoAplicadoPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DescuentoAplicados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DescuentoAplicadoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DescuentoAplicados
     * const descuentoAplicados = await prisma.descuentoAplicado.findMany()
     * 
     * // Get first 10 DescuentoAplicados
     * const descuentoAplicados = await prisma.descuentoAplicado.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const descuentoAplicadoWithIdOnly = await prisma.descuentoAplicado.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DescuentoAplicadoFindManyArgs>(args?: SelectSubset<T, DescuentoAplicadoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DescuentoAplicadoPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DescuentoAplicado.
     * @param {DescuentoAplicadoCreateArgs} args - Arguments to create a DescuentoAplicado.
     * @example
     * // Create one DescuentoAplicado
     * const DescuentoAplicado = await prisma.descuentoAplicado.create({
     *   data: {
     *     // ... data to create a DescuentoAplicado
     *   }
     * })
     * 
     */
    create<T extends DescuentoAplicadoCreateArgs>(args: SelectSubset<T, DescuentoAplicadoCreateArgs<ExtArgs>>): Prisma__DescuentoAplicadoClient<$Result.GetResult<Prisma.$DescuentoAplicadoPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DescuentoAplicados.
     * @param {DescuentoAplicadoCreateManyArgs} args - Arguments to create many DescuentoAplicados.
     * @example
     * // Create many DescuentoAplicados
     * const descuentoAplicado = await prisma.descuentoAplicado.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DescuentoAplicadoCreateManyArgs>(args?: SelectSubset<T, DescuentoAplicadoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DescuentoAplicados and returns the data saved in the database.
     * @param {DescuentoAplicadoCreateManyAndReturnArgs} args - Arguments to create many DescuentoAplicados.
     * @example
     * // Create many DescuentoAplicados
     * const descuentoAplicado = await prisma.descuentoAplicado.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DescuentoAplicados and only return the `id`
     * const descuentoAplicadoWithIdOnly = await prisma.descuentoAplicado.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DescuentoAplicadoCreateManyAndReturnArgs>(args?: SelectSubset<T, DescuentoAplicadoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DescuentoAplicadoPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a DescuentoAplicado.
     * @param {DescuentoAplicadoDeleteArgs} args - Arguments to delete one DescuentoAplicado.
     * @example
     * // Delete one DescuentoAplicado
     * const DescuentoAplicado = await prisma.descuentoAplicado.delete({
     *   where: {
     *     // ... filter to delete one DescuentoAplicado
     *   }
     * })
     * 
     */
    delete<T extends DescuentoAplicadoDeleteArgs>(args: SelectSubset<T, DescuentoAplicadoDeleteArgs<ExtArgs>>): Prisma__DescuentoAplicadoClient<$Result.GetResult<Prisma.$DescuentoAplicadoPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DescuentoAplicado.
     * @param {DescuentoAplicadoUpdateArgs} args - Arguments to update one DescuentoAplicado.
     * @example
     * // Update one DescuentoAplicado
     * const descuentoAplicado = await prisma.descuentoAplicado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DescuentoAplicadoUpdateArgs>(args: SelectSubset<T, DescuentoAplicadoUpdateArgs<ExtArgs>>): Prisma__DescuentoAplicadoClient<$Result.GetResult<Prisma.$DescuentoAplicadoPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DescuentoAplicados.
     * @param {DescuentoAplicadoDeleteManyArgs} args - Arguments to filter DescuentoAplicados to delete.
     * @example
     * // Delete a few DescuentoAplicados
     * const { count } = await prisma.descuentoAplicado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DescuentoAplicadoDeleteManyArgs>(args?: SelectSubset<T, DescuentoAplicadoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DescuentoAplicados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DescuentoAplicadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DescuentoAplicados
     * const descuentoAplicado = await prisma.descuentoAplicado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DescuentoAplicadoUpdateManyArgs>(args: SelectSubset<T, DescuentoAplicadoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DescuentoAplicados and returns the data updated in the database.
     * @param {DescuentoAplicadoUpdateManyAndReturnArgs} args - Arguments to update many DescuentoAplicados.
     * @example
     * // Update many DescuentoAplicados
     * const descuentoAplicado = await prisma.descuentoAplicado.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DescuentoAplicados and only return the `id`
     * const descuentoAplicadoWithIdOnly = await prisma.descuentoAplicado.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DescuentoAplicadoUpdateManyAndReturnArgs>(args: SelectSubset<T, DescuentoAplicadoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DescuentoAplicadoPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one DescuentoAplicado.
     * @param {DescuentoAplicadoUpsertArgs} args - Arguments to update or create a DescuentoAplicado.
     * @example
     * // Update or create a DescuentoAplicado
     * const descuentoAplicado = await prisma.descuentoAplicado.upsert({
     *   create: {
     *     // ... data to create a DescuentoAplicado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DescuentoAplicado we want to update
     *   }
     * })
     */
    upsert<T extends DescuentoAplicadoUpsertArgs>(args: SelectSubset<T, DescuentoAplicadoUpsertArgs<ExtArgs>>): Prisma__DescuentoAplicadoClient<$Result.GetResult<Prisma.$DescuentoAplicadoPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of DescuentoAplicados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DescuentoAplicadoCountArgs} args - Arguments to filter DescuentoAplicados to count.
     * @example
     * // Count the number of DescuentoAplicados
     * const count = await prisma.descuentoAplicado.count({
     *   where: {
     *     // ... the filter for the DescuentoAplicados we want to count
     *   }
     * })
    **/
    count<T extends DescuentoAplicadoCountArgs>(
      args?: Subset<T, DescuentoAplicadoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DescuentoAplicadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DescuentoAplicado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DescuentoAplicadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DescuentoAplicadoAggregateArgs>(args: Subset<T, DescuentoAplicadoAggregateArgs>): Prisma.PrismaPromise<GetDescuentoAplicadoAggregateType<T>>

    /**
     * Group by DescuentoAplicado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DescuentoAplicadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DescuentoAplicadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DescuentoAplicadoGroupByArgs['orderBy'] }
        : { orderBy?: DescuentoAplicadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DescuentoAplicadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDescuentoAplicadoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DescuentoAplicado model
   */
  readonly fields: DescuentoAplicadoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DescuentoAplicado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DescuentoAplicadoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    descuento<T extends DescuentoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DescuentoDefaultArgs<ExtArgs>>): Prisma__DescuentoClient<$Result.GetResult<Prisma.$DescuentoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    alumno<T extends AlumnoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlumnoDefaultArgs<ExtArgs>>): Prisma__AlumnoClient<$Result.GetResult<Prisma.$AlumnoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DescuentoAplicado model
   */ 
  interface DescuentoAplicadoFieldRefs {
    readonly id: FieldRef<"DescuentoAplicado", 'Int'>
    readonly descuentoId: FieldRef<"DescuentoAplicado", 'Int'>
    readonly alumnoId: FieldRef<"DescuentoAplicado", 'Int'>
    readonly fechaInicio: FieldRef<"DescuentoAplicado", 'DateTime'>
    readonly fechaFin: FieldRef<"DescuentoAplicado", 'DateTime'>
    readonly activo: FieldRef<"DescuentoAplicado", 'Boolean'>
    readonly createdAt: FieldRef<"DescuentoAplicado", 'DateTime'>
    readonly updatedAt: FieldRef<"DescuentoAplicado", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DescuentoAplicado findUnique
   */
  export type DescuentoAplicadoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DescuentoAplicado
     */
    select?: DescuentoAplicadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DescuentoAplicado
     */
    omit?: DescuentoAplicadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DescuentoAplicadoInclude<ExtArgs> | null
    /**
     * Filter, which DescuentoAplicado to fetch.
     */
    where: DescuentoAplicadoWhereUniqueInput
  }

  /**
   * DescuentoAplicado findUniqueOrThrow
   */
  export type DescuentoAplicadoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DescuentoAplicado
     */
    select?: DescuentoAplicadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DescuentoAplicado
     */
    omit?: DescuentoAplicadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DescuentoAplicadoInclude<ExtArgs> | null
    /**
     * Filter, which DescuentoAplicado to fetch.
     */
    where: DescuentoAplicadoWhereUniqueInput
  }

  /**
   * DescuentoAplicado findFirst
   */
  export type DescuentoAplicadoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DescuentoAplicado
     */
    select?: DescuentoAplicadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DescuentoAplicado
     */
    omit?: DescuentoAplicadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DescuentoAplicadoInclude<ExtArgs> | null
    /**
     * Filter, which DescuentoAplicado to fetch.
     */
    where?: DescuentoAplicadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DescuentoAplicados to fetch.
     */
    orderBy?: DescuentoAplicadoOrderByWithRelationInput | DescuentoAplicadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DescuentoAplicados.
     */
    cursor?: DescuentoAplicadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DescuentoAplicados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DescuentoAplicados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DescuentoAplicados.
     */
    distinct?: DescuentoAplicadoScalarFieldEnum | DescuentoAplicadoScalarFieldEnum[]
  }

  /**
   * DescuentoAplicado findFirstOrThrow
   */
  export type DescuentoAplicadoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DescuentoAplicado
     */
    select?: DescuentoAplicadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DescuentoAplicado
     */
    omit?: DescuentoAplicadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DescuentoAplicadoInclude<ExtArgs> | null
    /**
     * Filter, which DescuentoAplicado to fetch.
     */
    where?: DescuentoAplicadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DescuentoAplicados to fetch.
     */
    orderBy?: DescuentoAplicadoOrderByWithRelationInput | DescuentoAplicadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DescuentoAplicados.
     */
    cursor?: DescuentoAplicadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DescuentoAplicados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DescuentoAplicados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DescuentoAplicados.
     */
    distinct?: DescuentoAplicadoScalarFieldEnum | DescuentoAplicadoScalarFieldEnum[]
  }

  /**
   * DescuentoAplicado findMany
   */
  export type DescuentoAplicadoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DescuentoAplicado
     */
    select?: DescuentoAplicadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DescuentoAplicado
     */
    omit?: DescuentoAplicadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DescuentoAplicadoInclude<ExtArgs> | null
    /**
     * Filter, which DescuentoAplicados to fetch.
     */
    where?: DescuentoAplicadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DescuentoAplicados to fetch.
     */
    orderBy?: DescuentoAplicadoOrderByWithRelationInput | DescuentoAplicadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DescuentoAplicados.
     */
    cursor?: DescuentoAplicadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DescuentoAplicados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DescuentoAplicados.
     */
    skip?: number
    distinct?: DescuentoAplicadoScalarFieldEnum | DescuentoAplicadoScalarFieldEnum[]
  }

  /**
   * DescuentoAplicado create
   */
  export type DescuentoAplicadoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DescuentoAplicado
     */
    select?: DescuentoAplicadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DescuentoAplicado
     */
    omit?: DescuentoAplicadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DescuentoAplicadoInclude<ExtArgs> | null
    /**
     * The data needed to create a DescuentoAplicado.
     */
    data: XOR<DescuentoAplicadoCreateInput, DescuentoAplicadoUncheckedCreateInput>
  }

  /**
   * DescuentoAplicado createMany
   */
  export type DescuentoAplicadoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DescuentoAplicados.
     */
    data: DescuentoAplicadoCreateManyInput | DescuentoAplicadoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DescuentoAplicado createManyAndReturn
   */
  export type DescuentoAplicadoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DescuentoAplicado
     */
    select?: DescuentoAplicadoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DescuentoAplicado
     */
    omit?: DescuentoAplicadoOmit<ExtArgs> | null
    /**
     * The data used to create many DescuentoAplicados.
     */
    data: DescuentoAplicadoCreateManyInput | DescuentoAplicadoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DescuentoAplicadoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DescuentoAplicado update
   */
  export type DescuentoAplicadoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DescuentoAplicado
     */
    select?: DescuentoAplicadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DescuentoAplicado
     */
    omit?: DescuentoAplicadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DescuentoAplicadoInclude<ExtArgs> | null
    /**
     * The data needed to update a DescuentoAplicado.
     */
    data: XOR<DescuentoAplicadoUpdateInput, DescuentoAplicadoUncheckedUpdateInput>
    /**
     * Choose, which DescuentoAplicado to update.
     */
    where: DescuentoAplicadoWhereUniqueInput
  }

  /**
   * DescuentoAplicado updateMany
   */
  export type DescuentoAplicadoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DescuentoAplicados.
     */
    data: XOR<DescuentoAplicadoUpdateManyMutationInput, DescuentoAplicadoUncheckedUpdateManyInput>
    /**
     * Filter which DescuentoAplicados to update
     */
    where?: DescuentoAplicadoWhereInput
  }

  /**
   * DescuentoAplicado updateManyAndReturn
   */
  export type DescuentoAplicadoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DescuentoAplicado
     */
    select?: DescuentoAplicadoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DescuentoAplicado
     */
    omit?: DescuentoAplicadoOmit<ExtArgs> | null
    /**
     * The data used to update DescuentoAplicados.
     */
    data: XOR<DescuentoAplicadoUpdateManyMutationInput, DescuentoAplicadoUncheckedUpdateManyInput>
    /**
     * Filter which DescuentoAplicados to update
     */
    where?: DescuentoAplicadoWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DescuentoAplicadoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DescuentoAplicado upsert
   */
  export type DescuentoAplicadoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DescuentoAplicado
     */
    select?: DescuentoAplicadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DescuentoAplicado
     */
    omit?: DescuentoAplicadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DescuentoAplicadoInclude<ExtArgs> | null
    /**
     * The filter to search for the DescuentoAplicado to update in case it exists.
     */
    where: DescuentoAplicadoWhereUniqueInput
    /**
     * In case the DescuentoAplicado found by the `where` argument doesn't exist, create a new DescuentoAplicado with this data.
     */
    create: XOR<DescuentoAplicadoCreateInput, DescuentoAplicadoUncheckedCreateInput>
    /**
     * In case the DescuentoAplicado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DescuentoAplicadoUpdateInput, DescuentoAplicadoUncheckedUpdateInput>
  }

  /**
   * DescuentoAplicado delete
   */
  export type DescuentoAplicadoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DescuentoAplicado
     */
    select?: DescuentoAplicadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DescuentoAplicado
     */
    omit?: DescuentoAplicadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DescuentoAplicadoInclude<ExtArgs> | null
    /**
     * Filter which DescuentoAplicado to delete.
     */
    where: DescuentoAplicadoWhereUniqueInput
  }

  /**
   * DescuentoAplicado deleteMany
   */
  export type DescuentoAplicadoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DescuentoAplicados to delete
     */
    where?: DescuentoAplicadoWhereInput
  }

  /**
   * DescuentoAplicado without action
   */
  export type DescuentoAplicadoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DescuentoAplicado
     */
    select?: DescuentoAplicadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DescuentoAplicado
     */
    omit?: DescuentoAplicadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DescuentoAplicadoInclude<ExtArgs> | null
  }


  /**
   * Model Deuda
   */

  export type AggregateDeuda = {
    _count: DeudaCountAggregateOutputType | null
    _avg: DeudaAvgAggregateOutputType | null
    _sum: DeudaSumAggregateOutputType | null
    _min: DeudaMinAggregateOutputType | null
    _max: DeudaMaxAggregateOutputType | null
  }

  export type DeudaAvgAggregateOutputType = {
    id: number | null
    alumnoId: number | null
    monto: number | null
    montoOriginal: number | null
    anio: number | null
    estiloId: number | null
  }

  export type DeudaSumAggregateOutputType = {
    id: number | null
    alumnoId: number | null
    monto: number | null
    montoOriginal: number | null
    anio: number | null
    estiloId: number | null
  }

  export type DeudaMinAggregateOutputType = {
    id: number | null
    alumnoId: number | null
    monto: number | null
    montoOriginal: number | null
    mes: string | null
    anio: number | null
    estiloId: number | null
    pagada: boolean | null
    fechaPago: Date | null
    fechaVencimiento: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeudaMaxAggregateOutputType = {
    id: number | null
    alumnoId: number | null
    monto: number | null
    montoOriginal: number | null
    mes: string | null
    anio: number | null
    estiloId: number | null
    pagada: boolean | null
    fechaPago: Date | null
    fechaVencimiento: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeudaCountAggregateOutputType = {
    id: number
    alumnoId: number
    monto: number
    montoOriginal: number
    mes: number
    anio: number
    estiloId: number
    pagada: number
    fechaPago: number
    fechaVencimiento: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeudaAvgAggregateInputType = {
    id?: true
    alumnoId?: true
    monto?: true
    montoOriginal?: true
    anio?: true
    estiloId?: true
  }

  export type DeudaSumAggregateInputType = {
    id?: true
    alumnoId?: true
    monto?: true
    montoOriginal?: true
    anio?: true
    estiloId?: true
  }

  export type DeudaMinAggregateInputType = {
    id?: true
    alumnoId?: true
    monto?: true
    montoOriginal?: true
    mes?: true
    anio?: true
    estiloId?: true
    pagada?: true
    fechaPago?: true
    fechaVencimiento?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeudaMaxAggregateInputType = {
    id?: true
    alumnoId?: true
    monto?: true
    montoOriginal?: true
    mes?: true
    anio?: true
    estiloId?: true
    pagada?: true
    fechaPago?: true
    fechaVencimiento?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeudaCountAggregateInputType = {
    id?: true
    alumnoId?: true
    monto?: true
    montoOriginal?: true
    mes?: true
    anio?: true
    estiloId?: true
    pagada?: true
    fechaPago?: true
    fechaVencimiento?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeudaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deuda to aggregate.
     */
    where?: DeudaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deudas to fetch.
     */
    orderBy?: DeudaOrderByWithRelationInput | DeudaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeudaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deudas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deudas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deudas
    **/
    _count?: true | DeudaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeudaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeudaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeudaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeudaMaxAggregateInputType
  }

  export type GetDeudaAggregateType<T extends DeudaAggregateArgs> = {
        [P in keyof T & keyof AggregateDeuda]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeuda[P]>
      : GetScalarType<T[P], AggregateDeuda[P]>
  }




  export type DeudaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeudaWhereInput
    orderBy?: DeudaOrderByWithAggregationInput | DeudaOrderByWithAggregationInput[]
    by: DeudaScalarFieldEnum[] | DeudaScalarFieldEnum
    having?: DeudaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeudaCountAggregateInputType | true
    _avg?: DeudaAvgAggregateInputType
    _sum?: DeudaSumAggregateInputType
    _min?: DeudaMinAggregateInputType
    _max?: DeudaMaxAggregateInputType
  }

  export type DeudaGroupByOutputType = {
    id: number
    alumnoId: number
    monto: number
    montoOriginal: number
    mes: string
    anio: number
    estiloId: number
    pagada: boolean
    fechaPago: Date | null
    fechaVencimiento: Date
    createdAt: Date
    updatedAt: Date
    _count: DeudaCountAggregateOutputType | null
    _avg: DeudaAvgAggregateOutputType | null
    _sum: DeudaSumAggregateOutputType | null
    _min: DeudaMinAggregateOutputType | null
    _max: DeudaMaxAggregateOutputType | null
  }

  type GetDeudaGroupByPayload<T extends DeudaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeudaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeudaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeudaGroupByOutputType[P]>
            : GetScalarType<T[P], DeudaGroupByOutputType[P]>
        }
      >
    >


  export type DeudaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alumnoId?: boolean
    monto?: boolean
    montoOriginal?: boolean
    mes?: boolean
    anio?: boolean
    estiloId?: boolean
    pagada?: boolean
    fechaPago?: boolean
    fechaVencimiento?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
    estilo?: boolean | EstiloDefaultArgs<ExtArgs>
    pagos?: boolean | Deuda$pagosArgs<ExtArgs>
    _count?: boolean | DeudaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deuda"]>

  export type DeudaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alumnoId?: boolean
    monto?: boolean
    montoOriginal?: boolean
    mes?: boolean
    anio?: boolean
    estiloId?: boolean
    pagada?: boolean
    fechaPago?: boolean
    fechaVencimiento?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
    estilo?: boolean | EstiloDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deuda"]>

  export type DeudaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alumnoId?: boolean
    monto?: boolean
    montoOriginal?: boolean
    mes?: boolean
    anio?: boolean
    estiloId?: boolean
    pagada?: boolean
    fechaPago?: boolean
    fechaVencimiento?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
    estilo?: boolean | EstiloDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deuda"]>

  export type DeudaSelectScalar = {
    id?: boolean
    alumnoId?: boolean
    monto?: boolean
    montoOriginal?: boolean
    mes?: boolean
    anio?: boolean
    estiloId?: boolean
    pagada?: boolean
    fechaPago?: boolean
    fechaVencimiento?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeudaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "alumnoId" | "monto" | "montoOriginal" | "mes" | "anio" | "estiloId" | "pagada" | "fechaPago" | "fechaVencimiento" | "createdAt" | "updatedAt", ExtArgs["result"]["deuda"]>
  export type DeudaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
    estilo?: boolean | EstiloDefaultArgs<ExtArgs>
    pagos?: boolean | Deuda$pagosArgs<ExtArgs>
    _count?: boolean | DeudaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeudaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
    estilo?: boolean | EstiloDefaultArgs<ExtArgs>
  }
  export type DeudaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
    estilo?: boolean | EstiloDefaultArgs<ExtArgs>
  }

  export type $DeudaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Deuda"
    objects: {
      alumno: Prisma.$AlumnoPayload<ExtArgs>
      estilo: Prisma.$EstiloPayload<ExtArgs>
      pagos: Prisma.$PagoDeudaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      alumnoId: number
      monto: number
      montoOriginal: number
      mes: string
      anio: number
      estiloId: number
      pagada: boolean
      fechaPago: Date | null
      fechaVencimiento: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deuda"]>
    composites: {}
  }

  type DeudaGetPayload<S extends boolean | null | undefined | DeudaDefaultArgs> = $Result.GetResult<Prisma.$DeudaPayload, S>

  type DeudaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeudaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeudaCountAggregateInputType | true
    }

  export interface DeudaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Deuda'], meta: { name: 'Deuda' } }
    /**
     * Find zero or one Deuda that matches the filter.
     * @param {DeudaFindUniqueArgs} args - Arguments to find a Deuda
     * @example
     * // Get one Deuda
     * const deuda = await prisma.deuda.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeudaFindUniqueArgs>(args: SelectSubset<T, DeudaFindUniqueArgs<ExtArgs>>): Prisma__DeudaClient<$Result.GetResult<Prisma.$DeudaPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Deuda that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeudaFindUniqueOrThrowArgs} args - Arguments to find a Deuda
     * @example
     * // Get one Deuda
     * const deuda = await prisma.deuda.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeudaFindUniqueOrThrowArgs>(args: SelectSubset<T, DeudaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeudaClient<$Result.GetResult<Prisma.$DeudaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Deuda that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeudaFindFirstArgs} args - Arguments to find a Deuda
     * @example
     * // Get one Deuda
     * const deuda = await prisma.deuda.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeudaFindFirstArgs>(args?: SelectSubset<T, DeudaFindFirstArgs<ExtArgs>>): Prisma__DeudaClient<$Result.GetResult<Prisma.$DeudaPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Deuda that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeudaFindFirstOrThrowArgs} args - Arguments to find a Deuda
     * @example
     * // Get one Deuda
     * const deuda = await prisma.deuda.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeudaFindFirstOrThrowArgs>(args?: SelectSubset<T, DeudaFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeudaClient<$Result.GetResult<Prisma.$DeudaPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Deudas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeudaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deudas
     * const deudas = await prisma.deuda.findMany()
     * 
     * // Get first 10 Deudas
     * const deudas = await prisma.deuda.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deudaWithIdOnly = await prisma.deuda.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeudaFindManyArgs>(args?: SelectSubset<T, DeudaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeudaPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Deuda.
     * @param {DeudaCreateArgs} args - Arguments to create a Deuda.
     * @example
     * // Create one Deuda
     * const Deuda = await prisma.deuda.create({
     *   data: {
     *     // ... data to create a Deuda
     *   }
     * })
     * 
     */
    create<T extends DeudaCreateArgs>(args: SelectSubset<T, DeudaCreateArgs<ExtArgs>>): Prisma__DeudaClient<$Result.GetResult<Prisma.$DeudaPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Deudas.
     * @param {DeudaCreateManyArgs} args - Arguments to create many Deudas.
     * @example
     * // Create many Deudas
     * const deuda = await prisma.deuda.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeudaCreateManyArgs>(args?: SelectSubset<T, DeudaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Deudas and returns the data saved in the database.
     * @param {DeudaCreateManyAndReturnArgs} args - Arguments to create many Deudas.
     * @example
     * // Create many Deudas
     * const deuda = await prisma.deuda.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Deudas and only return the `id`
     * const deudaWithIdOnly = await prisma.deuda.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeudaCreateManyAndReturnArgs>(args?: SelectSubset<T, DeudaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeudaPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Deuda.
     * @param {DeudaDeleteArgs} args - Arguments to delete one Deuda.
     * @example
     * // Delete one Deuda
     * const Deuda = await prisma.deuda.delete({
     *   where: {
     *     // ... filter to delete one Deuda
     *   }
     * })
     * 
     */
    delete<T extends DeudaDeleteArgs>(args: SelectSubset<T, DeudaDeleteArgs<ExtArgs>>): Prisma__DeudaClient<$Result.GetResult<Prisma.$DeudaPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Deuda.
     * @param {DeudaUpdateArgs} args - Arguments to update one Deuda.
     * @example
     * // Update one Deuda
     * const deuda = await prisma.deuda.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeudaUpdateArgs>(args: SelectSubset<T, DeudaUpdateArgs<ExtArgs>>): Prisma__DeudaClient<$Result.GetResult<Prisma.$DeudaPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Deudas.
     * @param {DeudaDeleteManyArgs} args - Arguments to filter Deudas to delete.
     * @example
     * // Delete a few Deudas
     * const { count } = await prisma.deuda.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeudaDeleteManyArgs>(args?: SelectSubset<T, DeudaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deudas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeudaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deudas
     * const deuda = await prisma.deuda.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeudaUpdateManyArgs>(args: SelectSubset<T, DeudaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deudas and returns the data updated in the database.
     * @param {DeudaUpdateManyAndReturnArgs} args - Arguments to update many Deudas.
     * @example
     * // Update many Deudas
     * const deuda = await prisma.deuda.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Deudas and only return the `id`
     * const deudaWithIdOnly = await prisma.deuda.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeudaUpdateManyAndReturnArgs>(args: SelectSubset<T, DeudaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeudaPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Deuda.
     * @param {DeudaUpsertArgs} args - Arguments to update or create a Deuda.
     * @example
     * // Update or create a Deuda
     * const deuda = await prisma.deuda.upsert({
     *   create: {
     *     // ... data to create a Deuda
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deuda we want to update
     *   }
     * })
     */
    upsert<T extends DeudaUpsertArgs>(args: SelectSubset<T, DeudaUpsertArgs<ExtArgs>>): Prisma__DeudaClient<$Result.GetResult<Prisma.$DeudaPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Deudas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeudaCountArgs} args - Arguments to filter Deudas to count.
     * @example
     * // Count the number of Deudas
     * const count = await prisma.deuda.count({
     *   where: {
     *     // ... the filter for the Deudas we want to count
     *   }
     * })
    **/
    count<T extends DeudaCountArgs>(
      args?: Subset<T, DeudaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeudaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deuda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeudaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeudaAggregateArgs>(args: Subset<T, DeudaAggregateArgs>): Prisma.PrismaPromise<GetDeudaAggregateType<T>>

    /**
     * Group by Deuda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeudaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeudaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeudaGroupByArgs['orderBy'] }
        : { orderBy?: DeudaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeudaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeudaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Deuda model
   */
  readonly fields: DeudaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Deuda.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeudaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    alumno<T extends AlumnoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlumnoDefaultArgs<ExtArgs>>): Prisma__AlumnoClient<$Result.GetResult<Prisma.$AlumnoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    estilo<T extends EstiloDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EstiloDefaultArgs<ExtArgs>>): Prisma__EstiloClient<$Result.GetResult<Prisma.$EstiloPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    pagos<T extends Deuda$pagosArgs<ExtArgs> = {}>(args?: Subset<T, Deuda$pagosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoDeudaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Deuda model
   */ 
  interface DeudaFieldRefs {
    readonly id: FieldRef<"Deuda", 'Int'>
    readonly alumnoId: FieldRef<"Deuda", 'Int'>
    readonly monto: FieldRef<"Deuda", 'Float'>
    readonly montoOriginal: FieldRef<"Deuda", 'Float'>
    readonly mes: FieldRef<"Deuda", 'String'>
    readonly anio: FieldRef<"Deuda", 'Int'>
    readonly estiloId: FieldRef<"Deuda", 'Int'>
    readonly pagada: FieldRef<"Deuda", 'Boolean'>
    readonly fechaPago: FieldRef<"Deuda", 'DateTime'>
    readonly fechaVencimiento: FieldRef<"Deuda", 'DateTime'>
    readonly createdAt: FieldRef<"Deuda", 'DateTime'>
    readonly updatedAt: FieldRef<"Deuda", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Deuda findUnique
   */
  export type DeudaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deuda
     */
    select?: DeudaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deuda
     */
    omit?: DeudaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeudaInclude<ExtArgs> | null
    /**
     * Filter, which Deuda to fetch.
     */
    where: DeudaWhereUniqueInput
  }

  /**
   * Deuda findUniqueOrThrow
   */
  export type DeudaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deuda
     */
    select?: DeudaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deuda
     */
    omit?: DeudaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeudaInclude<ExtArgs> | null
    /**
     * Filter, which Deuda to fetch.
     */
    where: DeudaWhereUniqueInput
  }

  /**
   * Deuda findFirst
   */
  export type DeudaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deuda
     */
    select?: DeudaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deuda
     */
    omit?: DeudaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeudaInclude<ExtArgs> | null
    /**
     * Filter, which Deuda to fetch.
     */
    where?: DeudaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deudas to fetch.
     */
    orderBy?: DeudaOrderByWithRelationInput | DeudaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deudas.
     */
    cursor?: DeudaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deudas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deudas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deudas.
     */
    distinct?: DeudaScalarFieldEnum | DeudaScalarFieldEnum[]
  }

  /**
   * Deuda findFirstOrThrow
   */
  export type DeudaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deuda
     */
    select?: DeudaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deuda
     */
    omit?: DeudaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeudaInclude<ExtArgs> | null
    /**
     * Filter, which Deuda to fetch.
     */
    where?: DeudaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deudas to fetch.
     */
    orderBy?: DeudaOrderByWithRelationInput | DeudaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deudas.
     */
    cursor?: DeudaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deudas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deudas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deudas.
     */
    distinct?: DeudaScalarFieldEnum | DeudaScalarFieldEnum[]
  }

  /**
   * Deuda findMany
   */
  export type DeudaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deuda
     */
    select?: DeudaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deuda
     */
    omit?: DeudaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeudaInclude<ExtArgs> | null
    /**
     * Filter, which Deudas to fetch.
     */
    where?: DeudaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deudas to fetch.
     */
    orderBy?: DeudaOrderByWithRelationInput | DeudaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deudas.
     */
    cursor?: DeudaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deudas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deudas.
     */
    skip?: number
    distinct?: DeudaScalarFieldEnum | DeudaScalarFieldEnum[]
  }

  /**
   * Deuda create
   */
  export type DeudaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deuda
     */
    select?: DeudaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deuda
     */
    omit?: DeudaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeudaInclude<ExtArgs> | null
    /**
     * The data needed to create a Deuda.
     */
    data: XOR<DeudaCreateInput, DeudaUncheckedCreateInput>
  }

  /**
   * Deuda createMany
   */
  export type DeudaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deudas.
     */
    data: DeudaCreateManyInput | DeudaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Deuda createManyAndReturn
   */
  export type DeudaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deuda
     */
    select?: DeudaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Deuda
     */
    omit?: DeudaOmit<ExtArgs> | null
    /**
     * The data used to create many Deudas.
     */
    data: DeudaCreateManyInput | DeudaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeudaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Deuda update
   */
  export type DeudaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deuda
     */
    select?: DeudaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deuda
     */
    omit?: DeudaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeudaInclude<ExtArgs> | null
    /**
     * The data needed to update a Deuda.
     */
    data: XOR<DeudaUpdateInput, DeudaUncheckedUpdateInput>
    /**
     * Choose, which Deuda to update.
     */
    where: DeudaWhereUniqueInput
  }

  /**
   * Deuda updateMany
   */
  export type DeudaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deudas.
     */
    data: XOR<DeudaUpdateManyMutationInput, DeudaUncheckedUpdateManyInput>
    /**
     * Filter which Deudas to update
     */
    where?: DeudaWhereInput
  }

  /**
   * Deuda updateManyAndReturn
   */
  export type DeudaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deuda
     */
    select?: DeudaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Deuda
     */
    omit?: DeudaOmit<ExtArgs> | null
    /**
     * The data used to update Deudas.
     */
    data: XOR<DeudaUpdateManyMutationInput, DeudaUncheckedUpdateManyInput>
    /**
     * Filter which Deudas to update
     */
    where?: DeudaWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeudaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Deuda upsert
   */
  export type DeudaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deuda
     */
    select?: DeudaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deuda
     */
    omit?: DeudaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeudaInclude<ExtArgs> | null
    /**
     * The filter to search for the Deuda to update in case it exists.
     */
    where: DeudaWhereUniqueInput
    /**
     * In case the Deuda found by the `where` argument doesn't exist, create a new Deuda with this data.
     */
    create: XOR<DeudaCreateInput, DeudaUncheckedCreateInput>
    /**
     * In case the Deuda was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeudaUpdateInput, DeudaUncheckedUpdateInput>
  }

  /**
   * Deuda delete
   */
  export type DeudaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deuda
     */
    select?: DeudaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deuda
     */
    omit?: DeudaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeudaInclude<ExtArgs> | null
    /**
     * Filter which Deuda to delete.
     */
    where: DeudaWhereUniqueInput
  }

  /**
   * Deuda deleteMany
   */
  export type DeudaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deudas to delete
     */
    where?: DeudaWhereInput
  }

  /**
   * Deuda.pagos
   */
  export type Deuda$pagosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDeuda
     */
    select?: PagoDeudaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDeuda
     */
    omit?: PagoDeudaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDeudaInclude<ExtArgs> | null
    where?: PagoDeudaWhereInput
    orderBy?: PagoDeudaOrderByWithRelationInput | PagoDeudaOrderByWithRelationInput[]
    cursor?: PagoDeudaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PagoDeudaScalarFieldEnum | PagoDeudaScalarFieldEnum[]
  }

  /**
   * Deuda without action
   */
  export type DeudaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deuda
     */
    select?: DeudaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deuda
     */
    omit?: DeudaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeudaInclude<ExtArgs> | null
  }


  /**
   * Model PagoDeuda
   */

  export type AggregatePagoDeuda = {
    _count: PagoDeudaCountAggregateOutputType | null
    _avg: PagoDeudaAvgAggregateOutputType | null
    _sum: PagoDeudaSumAggregateOutputType | null
    _min: PagoDeudaMinAggregateOutputType | null
    _max: PagoDeudaMaxAggregateOutputType | null
  }

  export type PagoDeudaAvgAggregateOutputType = {
    id: number | null
    deudaId: number | null
    reciboId: number | null
    monto: number | null
  }

  export type PagoDeudaSumAggregateOutputType = {
    id: number | null
    deudaId: number | null
    reciboId: number | null
    monto: number | null
  }

  export type PagoDeudaMinAggregateOutputType = {
    id: number | null
    deudaId: number | null
    reciboId: number | null
    monto: number | null
    fecha: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PagoDeudaMaxAggregateOutputType = {
    id: number | null
    deudaId: number | null
    reciboId: number | null
    monto: number | null
    fecha: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PagoDeudaCountAggregateOutputType = {
    id: number
    deudaId: number
    reciboId: number
    monto: number
    fecha: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PagoDeudaAvgAggregateInputType = {
    id?: true
    deudaId?: true
    reciboId?: true
    monto?: true
  }

  export type PagoDeudaSumAggregateInputType = {
    id?: true
    deudaId?: true
    reciboId?: true
    monto?: true
  }

  export type PagoDeudaMinAggregateInputType = {
    id?: true
    deudaId?: true
    reciboId?: true
    monto?: true
    fecha?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PagoDeudaMaxAggregateInputType = {
    id?: true
    deudaId?: true
    reciboId?: true
    monto?: true
    fecha?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PagoDeudaCountAggregateInputType = {
    id?: true
    deudaId?: true
    reciboId?: true
    monto?: true
    fecha?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PagoDeudaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PagoDeuda to aggregate.
     */
    where?: PagoDeudaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PagoDeudas to fetch.
     */
    orderBy?: PagoDeudaOrderByWithRelationInput | PagoDeudaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PagoDeudaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PagoDeudas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PagoDeudas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PagoDeudas
    **/
    _count?: true | PagoDeudaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PagoDeudaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PagoDeudaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PagoDeudaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PagoDeudaMaxAggregateInputType
  }

  export type GetPagoDeudaAggregateType<T extends PagoDeudaAggregateArgs> = {
        [P in keyof T & keyof AggregatePagoDeuda]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePagoDeuda[P]>
      : GetScalarType<T[P], AggregatePagoDeuda[P]>
  }




  export type PagoDeudaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagoDeudaWhereInput
    orderBy?: PagoDeudaOrderByWithAggregationInput | PagoDeudaOrderByWithAggregationInput[]
    by: PagoDeudaScalarFieldEnum[] | PagoDeudaScalarFieldEnum
    having?: PagoDeudaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PagoDeudaCountAggregateInputType | true
    _avg?: PagoDeudaAvgAggregateInputType
    _sum?: PagoDeudaSumAggregateInputType
    _min?: PagoDeudaMinAggregateInputType
    _max?: PagoDeudaMaxAggregateInputType
  }

  export type PagoDeudaGroupByOutputType = {
    id: number
    deudaId: number
    reciboId: number
    monto: number
    fecha: Date
    createdAt: Date
    updatedAt: Date
    _count: PagoDeudaCountAggregateOutputType | null
    _avg: PagoDeudaAvgAggregateOutputType | null
    _sum: PagoDeudaSumAggregateOutputType | null
    _min: PagoDeudaMinAggregateOutputType | null
    _max: PagoDeudaMaxAggregateOutputType | null
  }

  type GetPagoDeudaGroupByPayload<T extends PagoDeudaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PagoDeudaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PagoDeudaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PagoDeudaGroupByOutputType[P]>
            : GetScalarType<T[P], PagoDeudaGroupByOutputType[P]>
        }
      >
    >


  export type PagoDeudaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deudaId?: boolean
    reciboId?: boolean
    monto?: boolean
    fecha?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deuda?: boolean | DeudaDefaultArgs<ExtArgs>
    recibo?: boolean | ReciboDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pagoDeuda"]>

  export type PagoDeudaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deudaId?: boolean
    reciboId?: boolean
    monto?: boolean
    fecha?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deuda?: boolean | DeudaDefaultArgs<ExtArgs>
    recibo?: boolean | ReciboDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pagoDeuda"]>

  export type PagoDeudaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deudaId?: boolean
    reciboId?: boolean
    monto?: boolean
    fecha?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deuda?: boolean | DeudaDefaultArgs<ExtArgs>
    recibo?: boolean | ReciboDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pagoDeuda"]>

  export type PagoDeudaSelectScalar = {
    id?: boolean
    deudaId?: boolean
    reciboId?: boolean
    monto?: boolean
    fecha?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PagoDeudaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "deudaId" | "reciboId" | "monto" | "fecha" | "createdAt" | "updatedAt", ExtArgs["result"]["pagoDeuda"]>
  export type PagoDeudaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deuda?: boolean | DeudaDefaultArgs<ExtArgs>
    recibo?: boolean | ReciboDefaultArgs<ExtArgs>
  }
  export type PagoDeudaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deuda?: boolean | DeudaDefaultArgs<ExtArgs>
    recibo?: boolean | ReciboDefaultArgs<ExtArgs>
  }
  export type PagoDeudaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deuda?: boolean | DeudaDefaultArgs<ExtArgs>
    recibo?: boolean | ReciboDefaultArgs<ExtArgs>
  }

  export type $PagoDeudaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PagoDeuda"
    objects: {
      deuda: Prisma.$DeudaPayload<ExtArgs>
      recibo: Prisma.$ReciboPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      deudaId: number
      reciboId: number
      monto: number
      fecha: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pagoDeuda"]>
    composites: {}
  }

  type PagoDeudaGetPayload<S extends boolean | null | undefined | PagoDeudaDefaultArgs> = $Result.GetResult<Prisma.$PagoDeudaPayload, S>

  type PagoDeudaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PagoDeudaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PagoDeudaCountAggregateInputType | true
    }

  export interface PagoDeudaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PagoDeuda'], meta: { name: 'PagoDeuda' } }
    /**
     * Find zero or one PagoDeuda that matches the filter.
     * @param {PagoDeudaFindUniqueArgs} args - Arguments to find a PagoDeuda
     * @example
     * // Get one PagoDeuda
     * const pagoDeuda = await prisma.pagoDeuda.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PagoDeudaFindUniqueArgs>(args: SelectSubset<T, PagoDeudaFindUniqueArgs<ExtArgs>>): Prisma__PagoDeudaClient<$Result.GetResult<Prisma.$PagoDeudaPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one PagoDeuda that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PagoDeudaFindUniqueOrThrowArgs} args - Arguments to find a PagoDeuda
     * @example
     * // Get one PagoDeuda
     * const pagoDeuda = await prisma.pagoDeuda.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PagoDeudaFindUniqueOrThrowArgs>(args: SelectSubset<T, PagoDeudaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PagoDeudaClient<$Result.GetResult<Prisma.$PagoDeudaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first PagoDeuda that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoDeudaFindFirstArgs} args - Arguments to find a PagoDeuda
     * @example
     * // Get one PagoDeuda
     * const pagoDeuda = await prisma.pagoDeuda.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PagoDeudaFindFirstArgs>(args?: SelectSubset<T, PagoDeudaFindFirstArgs<ExtArgs>>): Prisma__PagoDeudaClient<$Result.GetResult<Prisma.$PagoDeudaPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first PagoDeuda that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoDeudaFindFirstOrThrowArgs} args - Arguments to find a PagoDeuda
     * @example
     * // Get one PagoDeuda
     * const pagoDeuda = await prisma.pagoDeuda.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PagoDeudaFindFirstOrThrowArgs>(args?: SelectSubset<T, PagoDeudaFindFirstOrThrowArgs<ExtArgs>>): Prisma__PagoDeudaClient<$Result.GetResult<Prisma.$PagoDeudaPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PagoDeudas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoDeudaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PagoDeudas
     * const pagoDeudas = await prisma.pagoDeuda.findMany()
     * 
     * // Get first 10 PagoDeudas
     * const pagoDeudas = await prisma.pagoDeuda.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pagoDeudaWithIdOnly = await prisma.pagoDeuda.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PagoDeudaFindManyArgs>(args?: SelectSubset<T, PagoDeudaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoDeudaPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a PagoDeuda.
     * @param {PagoDeudaCreateArgs} args - Arguments to create a PagoDeuda.
     * @example
     * // Create one PagoDeuda
     * const PagoDeuda = await prisma.pagoDeuda.create({
     *   data: {
     *     // ... data to create a PagoDeuda
     *   }
     * })
     * 
     */
    create<T extends PagoDeudaCreateArgs>(args: SelectSubset<T, PagoDeudaCreateArgs<ExtArgs>>): Prisma__PagoDeudaClient<$Result.GetResult<Prisma.$PagoDeudaPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many PagoDeudas.
     * @param {PagoDeudaCreateManyArgs} args - Arguments to create many PagoDeudas.
     * @example
     * // Create many PagoDeudas
     * const pagoDeuda = await prisma.pagoDeuda.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PagoDeudaCreateManyArgs>(args?: SelectSubset<T, PagoDeudaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PagoDeudas and returns the data saved in the database.
     * @param {PagoDeudaCreateManyAndReturnArgs} args - Arguments to create many PagoDeudas.
     * @example
     * // Create many PagoDeudas
     * const pagoDeuda = await prisma.pagoDeuda.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PagoDeudas and only return the `id`
     * const pagoDeudaWithIdOnly = await prisma.pagoDeuda.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PagoDeudaCreateManyAndReturnArgs>(args?: SelectSubset<T, PagoDeudaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoDeudaPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a PagoDeuda.
     * @param {PagoDeudaDeleteArgs} args - Arguments to delete one PagoDeuda.
     * @example
     * // Delete one PagoDeuda
     * const PagoDeuda = await prisma.pagoDeuda.delete({
     *   where: {
     *     // ... filter to delete one PagoDeuda
     *   }
     * })
     * 
     */
    delete<T extends PagoDeudaDeleteArgs>(args: SelectSubset<T, PagoDeudaDeleteArgs<ExtArgs>>): Prisma__PagoDeudaClient<$Result.GetResult<Prisma.$PagoDeudaPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one PagoDeuda.
     * @param {PagoDeudaUpdateArgs} args - Arguments to update one PagoDeuda.
     * @example
     * // Update one PagoDeuda
     * const pagoDeuda = await prisma.pagoDeuda.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PagoDeudaUpdateArgs>(args: SelectSubset<T, PagoDeudaUpdateArgs<ExtArgs>>): Prisma__PagoDeudaClient<$Result.GetResult<Prisma.$PagoDeudaPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more PagoDeudas.
     * @param {PagoDeudaDeleteManyArgs} args - Arguments to filter PagoDeudas to delete.
     * @example
     * // Delete a few PagoDeudas
     * const { count } = await prisma.pagoDeuda.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PagoDeudaDeleteManyArgs>(args?: SelectSubset<T, PagoDeudaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PagoDeudas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoDeudaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PagoDeudas
     * const pagoDeuda = await prisma.pagoDeuda.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PagoDeudaUpdateManyArgs>(args: SelectSubset<T, PagoDeudaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PagoDeudas and returns the data updated in the database.
     * @param {PagoDeudaUpdateManyAndReturnArgs} args - Arguments to update many PagoDeudas.
     * @example
     * // Update many PagoDeudas
     * const pagoDeuda = await prisma.pagoDeuda.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PagoDeudas and only return the `id`
     * const pagoDeudaWithIdOnly = await prisma.pagoDeuda.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PagoDeudaUpdateManyAndReturnArgs>(args: SelectSubset<T, PagoDeudaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoDeudaPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one PagoDeuda.
     * @param {PagoDeudaUpsertArgs} args - Arguments to update or create a PagoDeuda.
     * @example
     * // Update or create a PagoDeuda
     * const pagoDeuda = await prisma.pagoDeuda.upsert({
     *   create: {
     *     // ... data to create a PagoDeuda
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PagoDeuda we want to update
     *   }
     * })
     */
    upsert<T extends PagoDeudaUpsertArgs>(args: SelectSubset<T, PagoDeudaUpsertArgs<ExtArgs>>): Prisma__PagoDeudaClient<$Result.GetResult<Prisma.$PagoDeudaPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of PagoDeudas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoDeudaCountArgs} args - Arguments to filter PagoDeudas to count.
     * @example
     * // Count the number of PagoDeudas
     * const count = await prisma.pagoDeuda.count({
     *   where: {
     *     // ... the filter for the PagoDeudas we want to count
     *   }
     * })
    **/
    count<T extends PagoDeudaCountArgs>(
      args?: Subset<T, PagoDeudaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PagoDeudaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PagoDeuda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoDeudaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PagoDeudaAggregateArgs>(args: Subset<T, PagoDeudaAggregateArgs>): Prisma.PrismaPromise<GetPagoDeudaAggregateType<T>>

    /**
     * Group by PagoDeuda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoDeudaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PagoDeudaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PagoDeudaGroupByArgs['orderBy'] }
        : { orderBy?: PagoDeudaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PagoDeudaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPagoDeudaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PagoDeuda model
   */
  readonly fields: PagoDeudaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PagoDeuda.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PagoDeudaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deuda<T extends DeudaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeudaDefaultArgs<ExtArgs>>): Prisma__DeudaClient<$Result.GetResult<Prisma.$DeudaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    recibo<T extends ReciboDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReciboDefaultArgs<ExtArgs>>): Prisma__ReciboClient<$Result.GetResult<Prisma.$ReciboPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PagoDeuda model
   */ 
  interface PagoDeudaFieldRefs {
    readonly id: FieldRef<"PagoDeuda", 'Int'>
    readonly deudaId: FieldRef<"PagoDeuda", 'Int'>
    readonly reciboId: FieldRef<"PagoDeuda", 'Int'>
    readonly monto: FieldRef<"PagoDeuda", 'Float'>
    readonly fecha: FieldRef<"PagoDeuda", 'DateTime'>
    readonly createdAt: FieldRef<"PagoDeuda", 'DateTime'>
    readonly updatedAt: FieldRef<"PagoDeuda", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PagoDeuda findUnique
   */
  export type PagoDeudaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDeuda
     */
    select?: PagoDeudaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDeuda
     */
    omit?: PagoDeudaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDeudaInclude<ExtArgs> | null
    /**
     * Filter, which PagoDeuda to fetch.
     */
    where: PagoDeudaWhereUniqueInput
  }

  /**
   * PagoDeuda findUniqueOrThrow
   */
  export type PagoDeudaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDeuda
     */
    select?: PagoDeudaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDeuda
     */
    omit?: PagoDeudaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDeudaInclude<ExtArgs> | null
    /**
     * Filter, which PagoDeuda to fetch.
     */
    where: PagoDeudaWhereUniqueInput
  }

  /**
   * PagoDeuda findFirst
   */
  export type PagoDeudaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDeuda
     */
    select?: PagoDeudaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDeuda
     */
    omit?: PagoDeudaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDeudaInclude<ExtArgs> | null
    /**
     * Filter, which PagoDeuda to fetch.
     */
    where?: PagoDeudaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PagoDeudas to fetch.
     */
    orderBy?: PagoDeudaOrderByWithRelationInput | PagoDeudaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PagoDeudas.
     */
    cursor?: PagoDeudaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PagoDeudas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PagoDeudas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PagoDeudas.
     */
    distinct?: PagoDeudaScalarFieldEnum | PagoDeudaScalarFieldEnum[]
  }

  /**
   * PagoDeuda findFirstOrThrow
   */
  export type PagoDeudaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDeuda
     */
    select?: PagoDeudaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDeuda
     */
    omit?: PagoDeudaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDeudaInclude<ExtArgs> | null
    /**
     * Filter, which PagoDeuda to fetch.
     */
    where?: PagoDeudaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PagoDeudas to fetch.
     */
    orderBy?: PagoDeudaOrderByWithRelationInput | PagoDeudaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PagoDeudas.
     */
    cursor?: PagoDeudaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PagoDeudas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PagoDeudas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PagoDeudas.
     */
    distinct?: PagoDeudaScalarFieldEnum | PagoDeudaScalarFieldEnum[]
  }

  /**
   * PagoDeuda findMany
   */
  export type PagoDeudaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDeuda
     */
    select?: PagoDeudaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDeuda
     */
    omit?: PagoDeudaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDeudaInclude<ExtArgs> | null
    /**
     * Filter, which PagoDeudas to fetch.
     */
    where?: PagoDeudaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PagoDeudas to fetch.
     */
    orderBy?: PagoDeudaOrderByWithRelationInput | PagoDeudaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PagoDeudas.
     */
    cursor?: PagoDeudaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PagoDeudas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PagoDeudas.
     */
    skip?: number
    distinct?: PagoDeudaScalarFieldEnum | PagoDeudaScalarFieldEnum[]
  }

  /**
   * PagoDeuda create
   */
  export type PagoDeudaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDeuda
     */
    select?: PagoDeudaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDeuda
     */
    omit?: PagoDeudaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDeudaInclude<ExtArgs> | null
    /**
     * The data needed to create a PagoDeuda.
     */
    data: XOR<PagoDeudaCreateInput, PagoDeudaUncheckedCreateInput>
  }

  /**
   * PagoDeuda createMany
   */
  export type PagoDeudaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PagoDeudas.
     */
    data: PagoDeudaCreateManyInput | PagoDeudaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PagoDeuda createManyAndReturn
   */
  export type PagoDeudaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDeuda
     */
    select?: PagoDeudaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDeuda
     */
    omit?: PagoDeudaOmit<ExtArgs> | null
    /**
     * The data used to create many PagoDeudas.
     */
    data: PagoDeudaCreateManyInput | PagoDeudaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDeudaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PagoDeuda update
   */
  export type PagoDeudaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDeuda
     */
    select?: PagoDeudaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDeuda
     */
    omit?: PagoDeudaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDeudaInclude<ExtArgs> | null
    /**
     * The data needed to update a PagoDeuda.
     */
    data: XOR<PagoDeudaUpdateInput, PagoDeudaUncheckedUpdateInput>
    /**
     * Choose, which PagoDeuda to update.
     */
    where: PagoDeudaWhereUniqueInput
  }

  /**
   * PagoDeuda updateMany
   */
  export type PagoDeudaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PagoDeudas.
     */
    data: XOR<PagoDeudaUpdateManyMutationInput, PagoDeudaUncheckedUpdateManyInput>
    /**
     * Filter which PagoDeudas to update
     */
    where?: PagoDeudaWhereInput
  }

  /**
   * PagoDeuda updateManyAndReturn
   */
  export type PagoDeudaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDeuda
     */
    select?: PagoDeudaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDeuda
     */
    omit?: PagoDeudaOmit<ExtArgs> | null
    /**
     * The data used to update PagoDeudas.
     */
    data: XOR<PagoDeudaUpdateManyMutationInput, PagoDeudaUncheckedUpdateManyInput>
    /**
     * Filter which PagoDeudas to update
     */
    where?: PagoDeudaWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDeudaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PagoDeuda upsert
   */
  export type PagoDeudaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDeuda
     */
    select?: PagoDeudaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDeuda
     */
    omit?: PagoDeudaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDeudaInclude<ExtArgs> | null
    /**
     * The filter to search for the PagoDeuda to update in case it exists.
     */
    where: PagoDeudaWhereUniqueInput
    /**
     * In case the PagoDeuda found by the `where` argument doesn't exist, create a new PagoDeuda with this data.
     */
    create: XOR<PagoDeudaCreateInput, PagoDeudaUncheckedCreateInput>
    /**
     * In case the PagoDeuda was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PagoDeudaUpdateInput, PagoDeudaUncheckedUpdateInput>
  }

  /**
   * PagoDeuda delete
   */
  export type PagoDeudaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDeuda
     */
    select?: PagoDeudaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDeuda
     */
    omit?: PagoDeudaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDeudaInclude<ExtArgs> | null
    /**
     * Filter which PagoDeuda to delete.
     */
    where: PagoDeudaWhereUniqueInput
  }

  /**
   * PagoDeuda deleteMany
   */
  export type PagoDeudaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PagoDeudas to delete
     */
    where?: PagoDeudaWhereInput
  }

  /**
   * PagoDeuda without action
   */
  export type PagoDeudaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDeuda
     */
    select?: PagoDeudaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDeuda
     */
    omit?: PagoDeudaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDeudaInclude<ExtArgs> | null
  }


  /**
   * Model Concepto
   */

  export type AggregateConcepto = {
    _count: ConceptoCountAggregateOutputType | null
    _avg: ConceptoAvgAggregateOutputType | null
    _sum: ConceptoSumAggregateOutputType | null
    _min: ConceptoMinAggregateOutputType | null
    _max: ConceptoMaxAggregateOutputType | null
  }

  export type ConceptoAvgAggregateOutputType = {
    id: number | null
    monto: number | null
    estiloId: number | null
  }

  export type ConceptoSumAggregateOutputType = {
    id: number | null
    monto: number | null
    estiloId: number | null
  }

  export type ConceptoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    monto: number | null
    estiloId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConceptoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    monto: number | null
    estiloId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConceptoCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    monto: number
    estiloId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConceptoAvgAggregateInputType = {
    id?: true
    monto?: true
    estiloId?: true
  }

  export type ConceptoSumAggregateInputType = {
    id?: true
    monto?: true
    estiloId?: true
  }

  export type ConceptoMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    monto?: true
    estiloId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConceptoMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    monto?: true
    estiloId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConceptoCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    monto?: true
    estiloId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConceptoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Concepto to aggregate.
     */
    where?: ConceptoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conceptos to fetch.
     */
    orderBy?: ConceptoOrderByWithRelationInput | ConceptoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConceptoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conceptos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conceptos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conceptos
    **/
    _count?: true | ConceptoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConceptoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConceptoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConceptoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConceptoMaxAggregateInputType
  }

  export type GetConceptoAggregateType<T extends ConceptoAggregateArgs> = {
        [P in keyof T & keyof AggregateConcepto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConcepto[P]>
      : GetScalarType<T[P], AggregateConcepto[P]>
  }




  export type ConceptoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptoWhereInput
    orderBy?: ConceptoOrderByWithAggregationInput | ConceptoOrderByWithAggregationInput[]
    by: ConceptoScalarFieldEnum[] | ConceptoScalarFieldEnum
    having?: ConceptoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConceptoCountAggregateInputType | true
    _avg?: ConceptoAvgAggregateInputType
    _sum?: ConceptoSumAggregateInputType
    _min?: ConceptoMinAggregateInputType
    _max?: ConceptoMaxAggregateInputType
  }

  export type ConceptoGroupByOutputType = {
    id: number
    nombre: string
    descripcion: string | null
    monto: number
    estiloId: number | null
    createdAt: Date
    updatedAt: Date
    _count: ConceptoCountAggregateOutputType | null
    _avg: ConceptoAvgAggregateOutputType | null
    _sum: ConceptoSumAggregateOutputType | null
    _min: ConceptoMinAggregateOutputType | null
    _max: ConceptoMaxAggregateOutputType | null
  }

  type GetConceptoGroupByPayload<T extends ConceptoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConceptoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConceptoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConceptoGroupByOutputType[P]>
            : GetScalarType<T[P], ConceptoGroupByOutputType[P]>
        }
      >
    >


  export type ConceptoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    monto?: boolean
    estiloId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    estilo?: boolean | Concepto$estiloArgs<ExtArgs>
    recibos?: boolean | Concepto$recibosArgs<ExtArgs>
    _count?: boolean | ConceptoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["concepto"]>

  export type ConceptoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    monto?: boolean
    estiloId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    estilo?: boolean | Concepto$estiloArgs<ExtArgs>
  }, ExtArgs["result"]["concepto"]>

  export type ConceptoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    monto?: boolean
    estiloId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    estilo?: boolean | Concepto$estiloArgs<ExtArgs>
  }, ExtArgs["result"]["concepto"]>

  export type ConceptoSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    monto?: boolean
    estiloId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConceptoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "descripcion" | "monto" | "estiloId" | "createdAt" | "updatedAt", ExtArgs["result"]["concepto"]>
  export type ConceptoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estilo?: boolean | Concepto$estiloArgs<ExtArgs>
    recibos?: boolean | Concepto$recibosArgs<ExtArgs>
    _count?: boolean | ConceptoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConceptoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estilo?: boolean | Concepto$estiloArgs<ExtArgs>
  }
  export type ConceptoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estilo?: boolean | Concepto$estiloArgs<ExtArgs>
  }

  export type $ConceptoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Concepto"
    objects: {
      estilo: Prisma.$EstiloPayload<ExtArgs> | null
      recibos: Prisma.$ReciboPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      descripcion: string | null
      monto: number
      estiloId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["concepto"]>
    composites: {}
  }

  type ConceptoGetPayload<S extends boolean | null | undefined | ConceptoDefaultArgs> = $Result.GetResult<Prisma.$ConceptoPayload, S>

  type ConceptoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConceptoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConceptoCountAggregateInputType | true
    }

  export interface ConceptoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Concepto'], meta: { name: 'Concepto' } }
    /**
     * Find zero or one Concepto that matches the filter.
     * @param {ConceptoFindUniqueArgs} args - Arguments to find a Concepto
     * @example
     * // Get one Concepto
     * const concepto = await prisma.concepto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConceptoFindUniqueArgs>(args: SelectSubset<T, ConceptoFindUniqueArgs<ExtArgs>>): Prisma__ConceptoClient<$Result.GetResult<Prisma.$ConceptoPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Concepto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConceptoFindUniqueOrThrowArgs} args - Arguments to find a Concepto
     * @example
     * // Get one Concepto
     * const concepto = await prisma.concepto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConceptoFindUniqueOrThrowArgs>(args: SelectSubset<T, ConceptoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConceptoClient<$Result.GetResult<Prisma.$ConceptoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Concepto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptoFindFirstArgs} args - Arguments to find a Concepto
     * @example
     * // Get one Concepto
     * const concepto = await prisma.concepto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConceptoFindFirstArgs>(args?: SelectSubset<T, ConceptoFindFirstArgs<ExtArgs>>): Prisma__ConceptoClient<$Result.GetResult<Prisma.$ConceptoPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Concepto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptoFindFirstOrThrowArgs} args - Arguments to find a Concepto
     * @example
     * // Get one Concepto
     * const concepto = await prisma.concepto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConceptoFindFirstOrThrowArgs>(args?: SelectSubset<T, ConceptoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConceptoClient<$Result.GetResult<Prisma.$ConceptoPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Conceptos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conceptos
     * const conceptos = await prisma.concepto.findMany()
     * 
     * // Get first 10 Conceptos
     * const conceptos = await prisma.concepto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conceptoWithIdOnly = await prisma.concepto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConceptoFindManyArgs>(args?: SelectSubset<T, ConceptoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptoPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Concepto.
     * @param {ConceptoCreateArgs} args - Arguments to create a Concepto.
     * @example
     * // Create one Concepto
     * const Concepto = await prisma.concepto.create({
     *   data: {
     *     // ... data to create a Concepto
     *   }
     * })
     * 
     */
    create<T extends ConceptoCreateArgs>(args: SelectSubset<T, ConceptoCreateArgs<ExtArgs>>): Prisma__ConceptoClient<$Result.GetResult<Prisma.$ConceptoPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Conceptos.
     * @param {ConceptoCreateManyArgs} args - Arguments to create many Conceptos.
     * @example
     * // Create many Conceptos
     * const concepto = await prisma.concepto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConceptoCreateManyArgs>(args?: SelectSubset<T, ConceptoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conceptos and returns the data saved in the database.
     * @param {ConceptoCreateManyAndReturnArgs} args - Arguments to create many Conceptos.
     * @example
     * // Create many Conceptos
     * const concepto = await prisma.concepto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conceptos and only return the `id`
     * const conceptoWithIdOnly = await prisma.concepto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConceptoCreateManyAndReturnArgs>(args?: SelectSubset<T, ConceptoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptoPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Concepto.
     * @param {ConceptoDeleteArgs} args - Arguments to delete one Concepto.
     * @example
     * // Delete one Concepto
     * const Concepto = await prisma.concepto.delete({
     *   where: {
     *     // ... filter to delete one Concepto
     *   }
     * })
     * 
     */
    delete<T extends ConceptoDeleteArgs>(args: SelectSubset<T, ConceptoDeleteArgs<ExtArgs>>): Prisma__ConceptoClient<$Result.GetResult<Prisma.$ConceptoPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Concepto.
     * @param {ConceptoUpdateArgs} args - Arguments to update one Concepto.
     * @example
     * // Update one Concepto
     * const concepto = await prisma.concepto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConceptoUpdateArgs>(args: SelectSubset<T, ConceptoUpdateArgs<ExtArgs>>): Prisma__ConceptoClient<$Result.GetResult<Prisma.$ConceptoPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Conceptos.
     * @param {ConceptoDeleteManyArgs} args - Arguments to filter Conceptos to delete.
     * @example
     * // Delete a few Conceptos
     * const { count } = await prisma.concepto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConceptoDeleteManyArgs>(args?: SelectSubset<T, ConceptoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conceptos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conceptos
     * const concepto = await prisma.concepto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConceptoUpdateManyArgs>(args: SelectSubset<T, ConceptoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conceptos and returns the data updated in the database.
     * @param {ConceptoUpdateManyAndReturnArgs} args - Arguments to update many Conceptos.
     * @example
     * // Update many Conceptos
     * const concepto = await prisma.concepto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conceptos and only return the `id`
     * const conceptoWithIdOnly = await prisma.concepto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConceptoUpdateManyAndReturnArgs>(args: SelectSubset<T, ConceptoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptoPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Concepto.
     * @param {ConceptoUpsertArgs} args - Arguments to update or create a Concepto.
     * @example
     * // Update or create a Concepto
     * const concepto = await prisma.concepto.upsert({
     *   create: {
     *     // ... data to create a Concepto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Concepto we want to update
     *   }
     * })
     */
    upsert<T extends ConceptoUpsertArgs>(args: SelectSubset<T, ConceptoUpsertArgs<ExtArgs>>): Prisma__ConceptoClient<$Result.GetResult<Prisma.$ConceptoPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Conceptos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptoCountArgs} args - Arguments to filter Conceptos to count.
     * @example
     * // Count the number of Conceptos
     * const count = await prisma.concepto.count({
     *   where: {
     *     // ... the filter for the Conceptos we want to count
     *   }
     * })
    **/
    count<T extends ConceptoCountArgs>(
      args?: Subset<T, ConceptoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConceptoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Concepto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConceptoAggregateArgs>(args: Subset<T, ConceptoAggregateArgs>): Prisma.PrismaPromise<GetConceptoAggregateType<T>>

    /**
     * Group by Concepto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConceptoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConceptoGroupByArgs['orderBy'] }
        : { orderBy?: ConceptoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConceptoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConceptoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Concepto model
   */
  readonly fields: ConceptoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Concepto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConceptoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estilo<T extends Concepto$estiloArgs<ExtArgs> = {}>(args?: Subset<T, Concepto$estiloArgs<ExtArgs>>): Prisma__EstiloClient<$Result.GetResult<Prisma.$EstiloPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    recibos<T extends Concepto$recibosArgs<ExtArgs> = {}>(args?: Subset<T, Concepto$recibosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReciboPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Concepto model
   */ 
  interface ConceptoFieldRefs {
    readonly id: FieldRef<"Concepto", 'Int'>
    readonly nombre: FieldRef<"Concepto", 'String'>
    readonly descripcion: FieldRef<"Concepto", 'String'>
    readonly monto: FieldRef<"Concepto", 'Float'>
    readonly estiloId: FieldRef<"Concepto", 'Int'>
    readonly createdAt: FieldRef<"Concepto", 'DateTime'>
    readonly updatedAt: FieldRef<"Concepto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Concepto findUnique
   */
  export type ConceptoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concepto
     */
    select?: ConceptoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Concepto
     */
    omit?: ConceptoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptoInclude<ExtArgs> | null
    /**
     * Filter, which Concepto to fetch.
     */
    where: ConceptoWhereUniqueInput
  }

  /**
   * Concepto findUniqueOrThrow
   */
  export type ConceptoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concepto
     */
    select?: ConceptoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Concepto
     */
    omit?: ConceptoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptoInclude<ExtArgs> | null
    /**
     * Filter, which Concepto to fetch.
     */
    where: ConceptoWhereUniqueInput
  }

  /**
   * Concepto findFirst
   */
  export type ConceptoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concepto
     */
    select?: ConceptoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Concepto
     */
    omit?: ConceptoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptoInclude<ExtArgs> | null
    /**
     * Filter, which Concepto to fetch.
     */
    where?: ConceptoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conceptos to fetch.
     */
    orderBy?: ConceptoOrderByWithRelationInput | ConceptoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conceptos.
     */
    cursor?: ConceptoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conceptos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conceptos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conceptos.
     */
    distinct?: ConceptoScalarFieldEnum | ConceptoScalarFieldEnum[]
  }

  /**
   * Concepto findFirstOrThrow
   */
  export type ConceptoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concepto
     */
    select?: ConceptoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Concepto
     */
    omit?: ConceptoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptoInclude<ExtArgs> | null
    /**
     * Filter, which Concepto to fetch.
     */
    where?: ConceptoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conceptos to fetch.
     */
    orderBy?: ConceptoOrderByWithRelationInput | ConceptoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conceptos.
     */
    cursor?: ConceptoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conceptos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conceptos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conceptos.
     */
    distinct?: ConceptoScalarFieldEnum | ConceptoScalarFieldEnum[]
  }

  /**
   * Concepto findMany
   */
  export type ConceptoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concepto
     */
    select?: ConceptoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Concepto
     */
    omit?: ConceptoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptoInclude<ExtArgs> | null
    /**
     * Filter, which Conceptos to fetch.
     */
    where?: ConceptoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conceptos to fetch.
     */
    orderBy?: ConceptoOrderByWithRelationInput | ConceptoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conceptos.
     */
    cursor?: ConceptoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conceptos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conceptos.
     */
    skip?: number
    distinct?: ConceptoScalarFieldEnum | ConceptoScalarFieldEnum[]
  }

  /**
   * Concepto create
   */
  export type ConceptoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concepto
     */
    select?: ConceptoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Concepto
     */
    omit?: ConceptoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptoInclude<ExtArgs> | null
    /**
     * The data needed to create a Concepto.
     */
    data: XOR<ConceptoCreateInput, ConceptoUncheckedCreateInput>
  }

  /**
   * Concepto createMany
   */
  export type ConceptoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conceptos.
     */
    data: ConceptoCreateManyInput | ConceptoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Concepto createManyAndReturn
   */
  export type ConceptoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concepto
     */
    select?: ConceptoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Concepto
     */
    omit?: ConceptoOmit<ExtArgs> | null
    /**
     * The data used to create many Conceptos.
     */
    data: ConceptoCreateManyInput | ConceptoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Concepto update
   */
  export type ConceptoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concepto
     */
    select?: ConceptoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Concepto
     */
    omit?: ConceptoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptoInclude<ExtArgs> | null
    /**
     * The data needed to update a Concepto.
     */
    data: XOR<ConceptoUpdateInput, ConceptoUncheckedUpdateInput>
    /**
     * Choose, which Concepto to update.
     */
    where: ConceptoWhereUniqueInput
  }

  /**
   * Concepto updateMany
   */
  export type ConceptoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conceptos.
     */
    data: XOR<ConceptoUpdateManyMutationInput, ConceptoUncheckedUpdateManyInput>
    /**
     * Filter which Conceptos to update
     */
    where?: ConceptoWhereInput
  }

  /**
   * Concepto updateManyAndReturn
   */
  export type ConceptoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concepto
     */
    select?: ConceptoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Concepto
     */
    omit?: ConceptoOmit<ExtArgs> | null
    /**
     * The data used to update Conceptos.
     */
    data: XOR<ConceptoUpdateManyMutationInput, ConceptoUncheckedUpdateManyInput>
    /**
     * Filter which Conceptos to update
     */
    where?: ConceptoWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Concepto upsert
   */
  export type ConceptoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concepto
     */
    select?: ConceptoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Concepto
     */
    omit?: ConceptoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptoInclude<ExtArgs> | null
    /**
     * The filter to search for the Concepto to update in case it exists.
     */
    where: ConceptoWhereUniqueInput
    /**
     * In case the Concepto found by the `where` argument doesn't exist, create a new Concepto with this data.
     */
    create: XOR<ConceptoCreateInput, ConceptoUncheckedCreateInput>
    /**
     * In case the Concepto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConceptoUpdateInput, ConceptoUncheckedUpdateInput>
  }

  /**
   * Concepto delete
   */
  export type ConceptoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concepto
     */
    select?: ConceptoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Concepto
     */
    omit?: ConceptoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptoInclude<ExtArgs> | null
    /**
     * Filter which Concepto to delete.
     */
    where: ConceptoWhereUniqueInput
  }

  /**
   * Concepto deleteMany
   */
  export type ConceptoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conceptos to delete
     */
    where?: ConceptoWhereInput
  }

  /**
   * Concepto.estilo
   */
  export type Concepto$estiloArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estilo
     */
    select?: EstiloSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estilo
     */
    omit?: EstiloOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstiloInclude<ExtArgs> | null
    where?: EstiloWhereInput
  }

  /**
   * Concepto.recibos
   */
  export type Concepto$recibosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recibo
     */
    select?: ReciboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recibo
     */
    omit?: ReciboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReciboInclude<ExtArgs> | null
    where?: ReciboWhereInput
    orderBy?: ReciboOrderByWithRelationInput | ReciboOrderByWithRelationInput[]
    cursor?: ReciboWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReciboScalarFieldEnum | ReciboScalarFieldEnum[]
  }

  /**
   * Concepto without action
   */
  export type ConceptoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concepto
     */
    select?: ConceptoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Concepto
     */
    omit?: ConceptoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptoInclude<ExtArgs> | null
  }


  /**
   * Model Recibo
   */

  export type AggregateRecibo = {
    _count: ReciboCountAggregateOutputType | null
    _avg: ReciboAvgAggregateOutputType | null
    _sum: ReciboSumAggregateOutputType | null
    _min: ReciboMinAggregateOutputType | null
    _max: ReciboMaxAggregateOutputType | null
  }

  export type ReciboAvgAggregateOutputType = {
    id: number | null
    numeroRecibo: number | null
    monto: number | null
    montoOriginal: number | null
    descuento: number | null
    alumnoId: number | null
    alumnoSueltoId: number | null
    conceptoId: number | null
    claseId: number | null
    referenciaRecibo: number | null
  }

  export type ReciboSumAggregateOutputType = {
    id: number | null
    numeroRecibo: number | null
    monto: number | null
    montoOriginal: number | null
    descuento: number | null
    alumnoId: number | null
    alumnoSueltoId: number | null
    conceptoId: number | null
    claseId: number | null
    referenciaRecibo: number | null
  }

  export type ReciboMinAggregateOutputType = {
    id: number | null
    numeroRecibo: number | null
    fecha: Date | null
    fechaEfecto: Date | null
    monto: number | null
    montoOriginal: number | null
    descuento: number | null
    periodoPago: string | null
    tipoPago: $Enums.TipoPago | null
    fueraDeTermino: boolean | null
    esClaseSuelta: boolean | null
    esMesCompleto: boolean | null
    alumnoId: number | null
    alumnoSueltoId: number | null
    conceptoId: number | null
    claseId: number | null
    anulado: boolean | null
    motivoAnulacion: string | null
    referenciaRecibo: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReciboMaxAggregateOutputType = {
    id: number | null
    numeroRecibo: number | null
    fecha: Date | null
    fechaEfecto: Date | null
    monto: number | null
    montoOriginal: number | null
    descuento: number | null
    periodoPago: string | null
    tipoPago: $Enums.TipoPago | null
    fueraDeTermino: boolean | null
    esClaseSuelta: boolean | null
    esMesCompleto: boolean | null
    alumnoId: number | null
    alumnoSueltoId: number | null
    conceptoId: number | null
    claseId: number | null
    anulado: boolean | null
    motivoAnulacion: string | null
    referenciaRecibo: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReciboCountAggregateOutputType = {
    id: number
    numeroRecibo: number
    fecha: number
    fechaEfecto: number
    monto: number
    montoOriginal: number
    descuento: number
    periodoPago: number
    tipoPago: number
    fueraDeTermino: number
    esClaseSuelta: number
    esMesCompleto: number
    alumnoId: number
    alumnoSueltoId: number
    conceptoId: number
    claseId: number
    anulado: number
    motivoAnulacion: number
    referenciaRecibo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReciboAvgAggregateInputType = {
    id?: true
    numeroRecibo?: true
    monto?: true
    montoOriginal?: true
    descuento?: true
    alumnoId?: true
    alumnoSueltoId?: true
    conceptoId?: true
    claseId?: true
    referenciaRecibo?: true
  }

  export type ReciboSumAggregateInputType = {
    id?: true
    numeroRecibo?: true
    monto?: true
    montoOriginal?: true
    descuento?: true
    alumnoId?: true
    alumnoSueltoId?: true
    conceptoId?: true
    claseId?: true
    referenciaRecibo?: true
  }

  export type ReciboMinAggregateInputType = {
    id?: true
    numeroRecibo?: true
    fecha?: true
    fechaEfecto?: true
    monto?: true
    montoOriginal?: true
    descuento?: true
    periodoPago?: true
    tipoPago?: true
    fueraDeTermino?: true
    esClaseSuelta?: true
    esMesCompleto?: true
    alumnoId?: true
    alumnoSueltoId?: true
    conceptoId?: true
    claseId?: true
    anulado?: true
    motivoAnulacion?: true
    referenciaRecibo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReciboMaxAggregateInputType = {
    id?: true
    numeroRecibo?: true
    fecha?: true
    fechaEfecto?: true
    monto?: true
    montoOriginal?: true
    descuento?: true
    periodoPago?: true
    tipoPago?: true
    fueraDeTermino?: true
    esClaseSuelta?: true
    esMesCompleto?: true
    alumnoId?: true
    alumnoSueltoId?: true
    conceptoId?: true
    claseId?: true
    anulado?: true
    motivoAnulacion?: true
    referenciaRecibo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReciboCountAggregateInputType = {
    id?: true
    numeroRecibo?: true
    fecha?: true
    fechaEfecto?: true
    monto?: true
    montoOriginal?: true
    descuento?: true
    periodoPago?: true
    tipoPago?: true
    fueraDeTermino?: true
    esClaseSuelta?: true
    esMesCompleto?: true
    alumnoId?: true
    alumnoSueltoId?: true
    conceptoId?: true
    claseId?: true
    anulado?: true
    motivoAnulacion?: true
    referenciaRecibo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReciboAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recibo to aggregate.
     */
    where?: ReciboWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recibos to fetch.
     */
    orderBy?: ReciboOrderByWithRelationInput | ReciboOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReciboWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recibos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recibos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recibos
    **/
    _count?: true | ReciboCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReciboAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReciboSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReciboMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReciboMaxAggregateInputType
  }

  export type GetReciboAggregateType<T extends ReciboAggregateArgs> = {
        [P in keyof T & keyof AggregateRecibo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecibo[P]>
      : GetScalarType<T[P], AggregateRecibo[P]>
  }




  export type ReciboGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReciboWhereInput
    orderBy?: ReciboOrderByWithAggregationInput | ReciboOrderByWithAggregationInput[]
    by: ReciboScalarFieldEnum[] | ReciboScalarFieldEnum
    having?: ReciboScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReciboCountAggregateInputType | true
    _avg?: ReciboAvgAggregateInputType
    _sum?: ReciboSumAggregateInputType
    _min?: ReciboMinAggregateInputType
    _max?: ReciboMaxAggregateInputType
  }

  export type ReciboGroupByOutputType = {
    id: number
    numeroRecibo: number
    fecha: Date
    fechaEfecto: Date
    monto: number
    montoOriginal: number
    descuento: number | null
    periodoPago: string
    tipoPago: $Enums.TipoPago
    fueraDeTermino: boolean
    esClaseSuelta: boolean
    esMesCompleto: boolean
    alumnoId: number | null
    alumnoSueltoId: number | null
    conceptoId: number
    claseId: number | null
    anulado: boolean
    motivoAnulacion: string | null
    referenciaRecibo: number | null
    createdAt: Date
    updatedAt: Date
    _count: ReciboCountAggregateOutputType | null
    _avg: ReciboAvgAggregateOutputType | null
    _sum: ReciboSumAggregateOutputType | null
    _min: ReciboMinAggregateOutputType | null
    _max: ReciboMaxAggregateOutputType | null
  }

  type GetReciboGroupByPayload<T extends ReciboGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReciboGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReciboGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReciboGroupByOutputType[P]>
            : GetScalarType<T[P], ReciboGroupByOutputType[P]>
        }
      >
    >


  export type ReciboSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroRecibo?: boolean
    fecha?: boolean
    fechaEfecto?: boolean
    monto?: boolean
    montoOriginal?: boolean
    descuento?: boolean
    periodoPago?: boolean
    tipoPago?: boolean
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    alumnoId?: boolean
    alumnoSueltoId?: boolean
    conceptoId?: boolean
    claseId?: boolean
    anulado?: boolean
    motivoAnulacion?: boolean
    referenciaRecibo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    alumno?: boolean | Recibo$alumnoArgs<ExtArgs>
    alumnoSuelto?: boolean | Recibo$alumnoSueltoArgs<ExtArgs>
    concepto?: boolean | ConceptoDefaultArgs<ExtArgs>
    pagosDeuda?: boolean | Recibo$pagosDeudaArgs<ExtArgs>
    detallesLiquidacion?: boolean | Recibo$detallesLiquidacionArgs<ExtArgs>
    clase?: boolean | Recibo$claseArgs<ExtArgs>
    reciboAnulado?: boolean | Recibo$reciboAnuladoArgs<ExtArgs>
    recibosAnulados?: boolean | Recibo$recibosAnuladosArgs<ExtArgs>
    _count?: boolean | ReciboCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recibo"]>

  export type ReciboSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroRecibo?: boolean
    fecha?: boolean
    fechaEfecto?: boolean
    monto?: boolean
    montoOriginal?: boolean
    descuento?: boolean
    periodoPago?: boolean
    tipoPago?: boolean
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    alumnoId?: boolean
    alumnoSueltoId?: boolean
    conceptoId?: boolean
    claseId?: boolean
    anulado?: boolean
    motivoAnulacion?: boolean
    referenciaRecibo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    alumno?: boolean | Recibo$alumnoArgs<ExtArgs>
    alumnoSuelto?: boolean | Recibo$alumnoSueltoArgs<ExtArgs>
    concepto?: boolean | ConceptoDefaultArgs<ExtArgs>
    clase?: boolean | Recibo$claseArgs<ExtArgs>
    reciboAnulado?: boolean | Recibo$reciboAnuladoArgs<ExtArgs>
  }, ExtArgs["result"]["recibo"]>

  export type ReciboSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroRecibo?: boolean
    fecha?: boolean
    fechaEfecto?: boolean
    monto?: boolean
    montoOriginal?: boolean
    descuento?: boolean
    periodoPago?: boolean
    tipoPago?: boolean
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    alumnoId?: boolean
    alumnoSueltoId?: boolean
    conceptoId?: boolean
    claseId?: boolean
    anulado?: boolean
    motivoAnulacion?: boolean
    referenciaRecibo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    alumno?: boolean | Recibo$alumnoArgs<ExtArgs>
    alumnoSuelto?: boolean | Recibo$alumnoSueltoArgs<ExtArgs>
    concepto?: boolean | ConceptoDefaultArgs<ExtArgs>
    clase?: boolean | Recibo$claseArgs<ExtArgs>
    reciboAnulado?: boolean | Recibo$reciboAnuladoArgs<ExtArgs>
  }, ExtArgs["result"]["recibo"]>

  export type ReciboSelectScalar = {
    id?: boolean
    numeroRecibo?: boolean
    fecha?: boolean
    fechaEfecto?: boolean
    monto?: boolean
    montoOriginal?: boolean
    descuento?: boolean
    periodoPago?: boolean
    tipoPago?: boolean
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    alumnoId?: boolean
    alumnoSueltoId?: boolean
    conceptoId?: boolean
    claseId?: boolean
    anulado?: boolean
    motivoAnulacion?: boolean
    referenciaRecibo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReciboOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "numeroRecibo" | "fecha" | "fechaEfecto" | "monto" | "montoOriginal" | "descuento" | "periodoPago" | "tipoPago" | "fueraDeTermino" | "esClaseSuelta" | "esMesCompleto" | "alumnoId" | "alumnoSueltoId" | "conceptoId" | "claseId" | "anulado" | "motivoAnulacion" | "referenciaRecibo" | "createdAt" | "updatedAt", ExtArgs["result"]["recibo"]>
  export type ReciboInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alumno?: boolean | Recibo$alumnoArgs<ExtArgs>
    alumnoSuelto?: boolean | Recibo$alumnoSueltoArgs<ExtArgs>
    concepto?: boolean | ConceptoDefaultArgs<ExtArgs>
    pagosDeuda?: boolean | Recibo$pagosDeudaArgs<ExtArgs>
    detallesLiquidacion?: boolean | Recibo$detallesLiquidacionArgs<ExtArgs>
    clase?: boolean | Recibo$claseArgs<ExtArgs>
    reciboAnulado?: boolean | Recibo$reciboAnuladoArgs<ExtArgs>
    recibosAnulados?: boolean | Recibo$recibosAnuladosArgs<ExtArgs>
    _count?: boolean | ReciboCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReciboIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alumno?: boolean | Recibo$alumnoArgs<ExtArgs>
    alumnoSuelto?: boolean | Recibo$alumnoSueltoArgs<ExtArgs>
    concepto?: boolean | ConceptoDefaultArgs<ExtArgs>
    clase?: boolean | Recibo$claseArgs<ExtArgs>
    reciboAnulado?: boolean | Recibo$reciboAnuladoArgs<ExtArgs>
  }
  export type ReciboIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alumno?: boolean | Recibo$alumnoArgs<ExtArgs>
    alumnoSuelto?: boolean | Recibo$alumnoSueltoArgs<ExtArgs>
    concepto?: boolean | ConceptoDefaultArgs<ExtArgs>
    clase?: boolean | Recibo$claseArgs<ExtArgs>
    reciboAnulado?: boolean | Recibo$reciboAnuladoArgs<ExtArgs>
  }

  export type $ReciboPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Recibo"
    objects: {
      alumno: Prisma.$AlumnoPayload<ExtArgs> | null
      alumnoSuelto: Prisma.$AlumnoSueltoPayload<ExtArgs> | null
      concepto: Prisma.$ConceptoPayload<ExtArgs>
      pagosDeuda: Prisma.$PagoDeudaPayload<ExtArgs>[]
      detallesLiquidacion: Prisma.$DetalleLiquidacionPayload<ExtArgs>[]
      clase: Prisma.$ClasePayload<ExtArgs> | null
      reciboAnulado: Prisma.$ReciboPayload<ExtArgs> | null
      recibosAnulados: Prisma.$ReciboPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      numeroRecibo: number
      fecha: Date
      fechaEfecto: Date
      monto: number
      montoOriginal: number
      descuento: number | null
      periodoPago: string
      tipoPago: $Enums.TipoPago
      fueraDeTermino: boolean
      esClaseSuelta: boolean
      esMesCompleto: boolean
      alumnoId: number | null
      alumnoSueltoId: number | null
      conceptoId: number
      claseId: number | null
      anulado: boolean
      motivoAnulacion: string | null
      referenciaRecibo: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["recibo"]>
    composites: {}
  }

  type ReciboGetPayload<S extends boolean | null | undefined | ReciboDefaultArgs> = $Result.GetResult<Prisma.$ReciboPayload, S>

  type ReciboCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReciboFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReciboCountAggregateInputType | true
    }

  export interface ReciboDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Recibo'], meta: { name: 'Recibo' } }
    /**
     * Find zero or one Recibo that matches the filter.
     * @param {ReciboFindUniqueArgs} args - Arguments to find a Recibo
     * @example
     * // Get one Recibo
     * const recibo = await prisma.recibo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReciboFindUniqueArgs>(args: SelectSubset<T, ReciboFindUniqueArgs<ExtArgs>>): Prisma__ReciboClient<$Result.GetResult<Prisma.$ReciboPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Recibo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReciboFindUniqueOrThrowArgs} args - Arguments to find a Recibo
     * @example
     * // Get one Recibo
     * const recibo = await prisma.recibo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReciboFindUniqueOrThrowArgs>(args: SelectSubset<T, ReciboFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReciboClient<$Result.GetResult<Prisma.$ReciboPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Recibo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReciboFindFirstArgs} args - Arguments to find a Recibo
     * @example
     * // Get one Recibo
     * const recibo = await prisma.recibo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReciboFindFirstArgs>(args?: SelectSubset<T, ReciboFindFirstArgs<ExtArgs>>): Prisma__ReciboClient<$Result.GetResult<Prisma.$ReciboPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Recibo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReciboFindFirstOrThrowArgs} args - Arguments to find a Recibo
     * @example
     * // Get one Recibo
     * const recibo = await prisma.recibo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReciboFindFirstOrThrowArgs>(args?: SelectSubset<T, ReciboFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReciboClient<$Result.GetResult<Prisma.$ReciboPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Recibos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReciboFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recibos
     * const recibos = await prisma.recibo.findMany()
     * 
     * // Get first 10 Recibos
     * const recibos = await prisma.recibo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reciboWithIdOnly = await prisma.recibo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReciboFindManyArgs>(args?: SelectSubset<T, ReciboFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReciboPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Recibo.
     * @param {ReciboCreateArgs} args - Arguments to create a Recibo.
     * @example
     * // Create one Recibo
     * const Recibo = await prisma.recibo.create({
     *   data: {
     *     // ... data to create a Recibo
     *   }
     * })
     * 
     */
    create<T extends ReciboCreateArgs>(args: SelectSubset<T, ReciboCreateArgs<ExtArgs>>): Prisma__ReciboClient<$Result.GetResult<Prisma.$ReciboPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Recibos.
     * @param {ReciboCreateManyArgs} args - Arguments to create many Recibos.
     * @example
     * // Create many Recibos
     * const recibo = await prisma.recibo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReciboCreateManyArgs>(args?: SelectSubset<T, ReciboCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Recibos and returns the data saved in the database.
     * @param {ReciboCreateManyAndReturnArgs} args - Arguments to create many Recibos.
     * @example
     * // Create many Recibos
     * const recibo = await prisma.recibo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Recibos and only return the `id`
     * const reciboWithIdOnly = await prisma.recibo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReciboCreateManyAndReturnArgs>(args?: SelectSubset<T, ReciboCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReciboPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Recibo.
     * @param {ReciboDeleteArgs} args - Arguments to delete one Recibo.
     * @example
     * // Delete one Recibo
     * const Recibo = await prisma.recibo.delete({
     *   where: {
     *     // ... filter to delete one Recibo
     *   }
     * })
     * 
     */
    delete<T extends ReciboDeleteArgs>(args: SelectSubset<T, ReciboDeleteArgs<ExtArgs>>): Prisma__ReciboClient<$Result.GetResult<Prisma.$ReciboPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Recibo.
     * @param {ReciboUpdateArgs} args - Arguments to update one Recibo.
     * @example
     * // Update one Recibo
     * const recibo = await prisma.recibo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReciboUpdateArgs>(args: SelectSubset<T, ReciboUpdateArgs<ExtArgs>>): Prisma__ReciboClient<$Result.GetResult<Prisma.$ReciboPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Recibos.
     * @param {ReciboDeleteManyArgs} args - Arguments to filter Recibos to delete.
     * @example
     * // Delete a few Recibos
     * const { count } = await prisma.recibo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReciboDeleteManyArgs>(args?: SelectSubset<T, ReciboDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recibos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReciboUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recibos
     * const recibo = await prisma.recibo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReciboUpdateManyArgs>(args: SelectSubset<T, ReciboUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recibos and returns the data updated in the database.
     * @param {ReciboUpdateManyAndReturnArgs} args - Arguments to update many Recibos.
     * @example
     * // Update many Recibos
     * const recibo = await prisma.recibo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Recibos and only return the `id`
     * const reciboWithIdOnly = await prisma.recibo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReciboUpdateManyAndReturnArgs>(args: SelectSubset<T, ReciboUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReciboPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Recibo.
     * @param {ReciboUpsertArgs} args - Arguments to update or create a Recibo.
     * @example
     * // Update or create a Recibo
     * const recibo = await prisma.recibo.upsert({
     *   create: {
     *     // ... data to create a Recibo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recibo we want to update
     *   }
     * })
     */
    upsert<T extends ReciboUpsertArgs>(args: SelectSubset<T, ReciboUpsertArgs<ExtArgs>>): Prisma__ReciboClient<$Result.GetResult<Prisma.$ReciboPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Recibos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReciboCountArgs} args - Arguments to filter Recibos to count.
     * @example
     * // Count the number of Recibos
     * const count = await prisma.recibo.count({
     *   where: {
     *     // ... the filter for the Recibos we want to count
     *   }
     * })
    **/
    count<T extends ReciboCountArgs>(
      args?: Subset<T, ReciboCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReciboCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recibo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReciboAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReciboAggregateArgs>(args: Subset<T, ReciboAggregateArgs>): Prisma.PrismaPromise<GetReciboAggregateType<T>>

    /**
     * Group by Recibo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReciboGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReciboGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReciboGroupByArgs['orderBy'] }
        : { orderBy?: ReciboGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReciboGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReciboGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Recibo model
   */
  readonly fields: ReciboFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Recibo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReciboClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    alumno<T extends Recibo$alumnoArgs<ExtArgs> = {}>(args?: Subset<T, Recibo$alumnoArgs<ExtArgs>>): Prisma__AlumnoClient<$Result.GetResult<Prisma.$AlumnoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    alumnoSuelto<T extends Recibo$alumnoSueltoArgs<ExtArgs> = {}>(args?: Subset<T, Recibo$alumnoSueltoArgs<ExtArgs>>): Prisma__AlumnoSueltoClient<$Result.GetResult<Prisma.$AlumnoSueltoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    concepto<T extends ConceptoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConceptoDefaultArgs<ExtArgs>>): Prisma__ConceptoClient<$Result.GetResult<Prisma.$ConceptoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    pagosDeuda<T extends Recibo$pagosDeudaArgs<ExtArgs> = {}>(args?: Subset<T, Recibo$pagosDeudaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoDeudaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    detallesLiquidacion<T extends Recibo$detallesLiquidacionArgs<ExtArgs> = {}>(args?: Subset<T, Recibo$detallesLiquidacionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetalleLiquidacionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    clase<T extends Recibo$claseArgs<ExtArgs> = {}>(args?: Subset<T, Recibo$claseArgs<ExtArgs>>): Prisma__ClaseClient<$Result.GetResult<Prisma.$ClasePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    reciboAnulado<T extends Recibo$reciboAnuladoArgs<ExtArgs> = {}>(args?: Subset<T, Recibo$reciboAnuladoArgs<ExtArgs>>): Prisma__ReciboClient<$Result.GetResult<Prisma.$ReciboPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    recibosAnulados<T extends Recibo$recibosAnuladosArgs<ExtArgs> = {}>(args?: Subset<T, Recibo$recibosAnuladosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReciboPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Recibo model
   */ 
  interface ReciboFieldRefs {
    readonly id: FieldRef<"Recibo", 'Int'>
    readonly numeroRecibo: FieldRef<"Recibo", 'Int'>
    readonly fecha: FieldRef<"Recibo", 'DateTime'>
    readonly fechaEfecto: FieldRef<"Recibo", 'DateTime'>
    readonly monto: FieldRef<"Recibo", 'Float'>
    readonly montoOriginal: FieldRef<"Recibo", 'Float'>
    readonly descuento: FieldRef<"Recibo", 'Float'>
    readonly periodoPago: FieldRef<"Recibo", 'String'>
    readonly tipoPago: FieldRef<"Recibo", 'TipoPago'>
    readonly fueraDeTermino: FieldRef<"Recibo", 'Boolean'>
    readonly esClaseSuelta: FieldRef<"Recibo", 'Boolean'>
    readonly esMesCompleto: FieldRef<"Recibo", 'Boolean'>
    readonly alumnoId: FieldRef<"Recibo", 'Int'>
    readonly alumnoSueltoId: FieldRef<"Recibo", 'Int'>
    readonly conceptoId: FieldRef<"Recibo", 'Int'>
    readonly claseId: FieldRef<"Recibo", 'Int'>
    readonly anulado: FieldRef<"Recibo", 'Boolean'>
    readonly motivoAnulacion: FieldRef<"Recibo", 'String'>
    readonly referenciaRecibo: FieldRef<"Recibo", 'Int'>
    readonly createdAt: FieldRef<"Recibo", 'DateTime'>
    readonly updatedAt: FieldRef<"Recibo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Recibo findUnique
   */
  export type ReciboFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recibo
     */
    select?: ReciboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recibo
     */
    omit?: ReciboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReciboInclude<ExtArgs> | null
    /**
     * Filter, which Recibo to fetch.
     */
    where: ReciboWhereUniqueInput
  }

  /**
   * Recibo findUniqueOrThrow
   */
  export type ReciboFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recibo
     */
    select?: ReciboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recibo
     */
    omit?: ReciboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReciboInclude<ExtArgs> | null
    /**
     * Filter, which Recibo to fetch.
     */
    where: ReciboWhereUniqueInput
  }

  /**
   * Recibo findFirst
   */
  export type ReciboFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recibo
     */
    select?: ReciboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recibo
     */
    omit?: ReciboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReciboInclude<ExtArgs> | null
    /**
     * Filter, which Recibo to fetch.
     */
    where?: ReciboWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recibos to fetch.
     */
    orderBy?: ReciboOrderByWithRelationInput | ReciboOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recibos.
     */
    cursor?: ReciboWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recibos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recibos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recibos.
     */
    distinct?: ReciboScalarFieldEnum | ReciboScalarFieldEnum[]
  }

  /**
   * Recibo findFirstOrThrow
   */
  export type ReciboFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recibo
     */
    select?: ReciboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recibo
     */
    omit?: ReciboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReciboInclude<ExtArgs> | null
    /**
     * Filter, which Recibo to fetch.
     */
    where?: ReciboWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recibos to fetch.
     */
    orderBy?: ReciboOrderByWithRelationInput | ReciboOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recibos.
     */
    cursor?: ReciboWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recibos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recibos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recibos.
     */
    distinct?: ReciboScalarFieldEnum | ReciboScalarFieldEnum[]
  }

  /**
   * Recibo findMany
   */
  export type ReciboFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recibo
     */
    select?: ReciboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recibo
     */
    omit?: ReciboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReciboInclude<ExtArgs> | null
    /**
     * Filter, which Recibos to fetch.
     */
    where?: ReciboWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recibos to fetch.
     */
    orderBy?: ReciboOrderByWithRelationInput | ReciboOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recibos.
     */
    cursor?: ReciboWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recibos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recibos.
     */
    skip?: number
    distinct?: ReciboScalarFieldEnum | ReciboScalarFieldEnum[]
  }

  /**
   * Recibo create
   */
  export type ReciboCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recibo
     */
    select?: ReciboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recibo
     */
    omit?: ReciboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReciboInclude<ExtArgs> | null
    /**
     * The data needed to create a Recibo.
     */
    data: XOR<ReciboCreateInput, ReciboUncheckedCreateInput>
  }

  /**
   * Recibo createMany
   */
  export type ReciboCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Recibos.
     */
    data: ReciboCreateManyInput | ReciboCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Recibo createManyAndReturn
   */
  export type ReciboCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recibo
     */
    select?: ReciboSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Recibo
     */
    omit?: ReciboOmit<ExtArgs> | null
    /**
     * The data used to create many Recibos.
     */
    data: ReciboCreateManyInput | ReciboCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReciboIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Recibo update
   */
  export type ReciboUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recibo
     */
    select?: ReciboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recibo
     */
    omit?: ReciboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReciboInclude<ExtArgs> | null
    /**
     * The data needed to update a Recibo.
     */
    data: XOR<ReciboUpdateInput, ReciboUncheckedUpdateInput>
    /**
     * Choose, which Recibo to update.
     */
    where: ReciboWhereUniqueInput
  }

  /**
   * Recibo updateMany
   */
  export type ReciboUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Recibos.
     */
    data: XOR<ReciboUpdateManyMutationInput, ReciboUncheckedUpdateManyInput>
    /**
     * Filter which Recibos to update
     */
    where?: ReciboWhereInput
  }

  /**
   * Recibo updateManyAndReturn
   */
  export type ReciboUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recibo
     */
    select?: ReciboSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Recibo
     */
    omit?: ReciboOmit<ExtArgs> | null
    /**
     * The data used to update Recibos.
     */
    data: XOR<ReciboUpdateManyMutationInput, ReciboUncheckedUpdateManyInput>
    /**
     * Filter which Recibos to update
     */
    where?: ReciboWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReciboIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Recibo upsert
   */
  export type ReciboUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recibo
     */
    select?: ReciboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recibo
     */
    omit?: ReciboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReciboInclude<ExtArgs> | null
    /**
     * The filter to search for the Recibo to update in case it exists.
     */
    where: ReciboWhereUniqueInput
    /**
     * In case the Recibo found by the `where` argument doesn't exist, create a new Recibo with this data.
     */
    create: XOR<ReciboCreateInput, ReciboUncheckedCreateInput>
    /**
     * In case the Recibo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReciboUpdateInput, ReciboUncheckedUpdateInput>
  }

  /**
   * Recibo delete
   */
  export type ReciboDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recibo
     */
    select?: ReciboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recibo
     */
    omit?: ReciboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReciboInclude<ExtArgs> | null
    /**
     * Filter which Recibo to delete.
     */
    where: ReciboWhereUniqueInput
  }

  /**
   * Recibo deleteMany
   */
  export type ReciboDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recibos to delete
     */
    where?: ReciboWhereInput
  }

  /**
   * Recibo.alumno
   */
  export type Recibo$alumnoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alumno
     */
    select?: AlumnoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alumno
     */
    omit?: AlumnoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoInclude<ExtArgs> | null
    where?: AlumnoWhereInput
  }

  /**
   * Recibo.alumnoSuelto
   */
  export type Recibo$alumnoSueltoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoSuelto
     */
    select?: AlumnoSueltoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoSuelto
     */
    omit?: AlumnoSueltoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoSueltoInclude<ExtArgs> | null
    where?: AlumnoSueltoWhereInput
  }

  /**
   * Recibo.pagosDeuda
   */
  export type Recibo$pagosDeudaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDeuda
     */
    select?: PagoDeudaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDeuda
     */
    omit?: PagoDeudaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDeudaInclude<ExtArgs> | null
    where?: PagoDeudaWhereInput
    orderBy?: PagoDeudaOrderByWithRelationInput | PagoDeudaOrderByWithRelationInput[]
    cursor?: PagoDeudaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PagoDeudaScalarFieldEnum | PagoDeudaScalarFieldEnum[]
  }

  /**
   * Recibo.detallesLiquidacion
   */
  export type Recibo$detallesLiquidacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleLiquidacion
     */
    select?: DetalleLiquidacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetalleLiquidacion
     */
    omit?: DetalleLiquidacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetalleLiquidacionInclude<ExtArgs> | null
    where?: DetalleLiquidacionWhereInput
    orderBy?: DetalleLiquidacionOrderByWithRelationInput | DetalleLiquidacionOrderByWithRelationInput[]
    cursor?: DetalleLiquidacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetalleLiquidacionScalarFieldEnum | DetalleLiquidacionScalarFieldEnum[]
  }

  /**
   * Recibo.clase
   */
  export type Recibo$claseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clase
     */
    omit?: ClaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaseInclude<ExtArgs> | null
    where?: ClaseWhereInput
  }

  /**
   * Recibo.reciboAnulado
   */
  export type Recibo$reciboAnuladoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recibo
     */
    select?: ReciboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recibo
     */
    omit?: ReciboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReciboInclude<ExtArgs> | null
    where?: ReciboWhereInput
  }

  /**
   * Recibo.recibosAnulados
   */
  export type Recibo$recibosAnuladosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recibo
     */
    select?: ReciboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recibo
     */
    omit?: ReciboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReciboInclude<ExtArgs> | null
    where?: ReciboWhereInput
    orderBy?: ReciboOrderByWithRelationInput | ReciboOrderByWithRelationInput[]
    cursor?: ReciboWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReciboScalarFieldEnum | ReciboScalarFieldEnum[]
  }

  /**
   * Recibo without action
   */
  export type ReciboDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recibo
     */
    select?: ReciboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recibo
     */
    omit?: ReciboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReciboInclude<ExtArgs> | null
  }


  /**
   * Model Estilo
   */

  export type AggregateEstilo = {
    _count: EstiloCountAggregateOutputType | null
    _avg: EstiloAvgAggregateOutputType | null
    _sum: EstiloSumAggregateOutputType | null
    _min: EstiloMinAggregateOutputType | null
    _max: EstiloMaxAggregateOutputType | null
  }

  export type EstiloAvgAggregateOutputType = {
    id: number | null
    monto: number | null
    importe: number | null
    profesorId: number | null
  }

  export type EstiloSumAggregateOutputType = {
    id: number | null
    monto: number | null
    importe: number | null
    profesorId: number | null
  }

  export type EstiloMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    monto: number | null
    descripcion: string | null
    importe: number | null
    profesorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EstiloMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    monto: number | null
    descripcion: string | null
    importe: number | null
    profesorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EstiloCountAggregateOutputType = {
    id: number
    nombre: number
    monto: number
    descripcion: number
    importe: number
    profesorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EstiloAvgAggregateInputType = {
    id?: true
    monto?: true
    importe?: true
    profesorId?: true
  }

  export type EstiloSumAggregateInputType = {
    id?: true
    monto?: true
    importe?: true
    profesorId?: true
  }

  export type EstiloMinAggregateInputType = {
    id?: true
    nombre?: true
    monto?: true
    descripcion?: true
    importe?: true
    profesorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EstiloMaxAggregateInputType = {
    id?: true
    nombre?: true
    monto?: true
    descripcion?: true
    importe?: true
    profesorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EstiloCountAggregateInputType = {
    id?: true
    nombre?: true
    monto?: true
    descripcion?: true
    importe?: true
    profesorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EstiloAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Estilo to aggregate.
     */
    where?: EstiloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estilos to fetch.
     */
    orderBy?: EstiloOrderByWithRelationInput | EstiloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EstiloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estilos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estilos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Estilos
    **/
    _count?: true | EstiloCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstiloAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstiloSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstiloMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstiloMaxAggregateInputType
  }

  export type GetEstiloAggregateType<T extends EstiloAggregateArgs> = {
        [P in keyof T & keyof AggregateEstilo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstilo[P]>
      : GetScalarType<T[P], AggregateEstilo[P]>
  }




  export type EstiloGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstiloWhereInput
    orderBy?: EstiloOrderByWithAggregationInput | EstiloOrderByWithAggregationInput[]
    by: EstiloScalarFieldEnum[] | EstiloScalarFieldEnum
    having?: EstiloScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstiloCountAggregateInputType | true
    _avg?: EstiloAvgAggregateInputType
    _sum?: EstiloSumAggregateInputType
    _min?: EstiloMinAggregateInputType
    _max?: EstiloMaxAggregateInputType
  }

  export type EstiloGroupByOutputType = {
    id: number
    nombre: string
    monto: number
    descripcion: string | null
    importe: number
    profesorId: number | null
    createdAt: Date
    updatedAt: Date
    _count: EstiloCountAggregateOutputType | null
    _avg: EstiloAvgAggregateOutputType | null
    _sum: EstiloSumAggregateOutputType | null
    _min: EstiloMinAggregateOutputType | null
    _max: EstiloMaxAggregateOutputType | null
  }

  type GetEstiloGroupByPayload<T extends EstiloGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EstiloGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstiloGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstiloGroupByOutputType[P]>
            : GetScalarType<T[P], EstiloGroupByOutputType[P]>
        }
      >
    >


  export type EstiloSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    monto?: boolean
    descripcion?: boolean
    importe?: boolean
    profesorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deudas?: boolean | Estilo$deudasArgs<ExtArgs>
    conceptos?: boolean | Estilo$conceptosArgs<ExtArgs>
    clases?: boolean | Estilo$clasesArgs<ExtArgs>
    alumnoEstilos?: boolean | Estilo$alumnoEstilosArgs<ExtArgs>
    profesor?: boolean | Estilo$profesorArgs<ExtArgs>
    alumnos?: boolean | Estilo$alumnosArgs<ExtArgs>
    _count?: boolean | EstiloCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estilo"]>

  export type EstiloSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    monto?: boolean
    descripcion?: boolean
    importe?: boolean
    profesorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profesor?: boolean | Estilo$profesorArgs<ExtArgs>
  }, ExtArgs["result"]["estilo"]>

  export type EstiloSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    monto?: boolean
    descripcion?: boolean
    importe?: boolean
    profesorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profesor?: boolean | Estilo$profesorArgs<ExtArgs>
  }, ExtArgs["result"]["estilo"]>

  export type EstiloSelectScalar = {
    id?: boolean
    nombre?: boolean
    monto?: boolean
    descripcion?: boolean
    importe?: boolean
    profesorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EstiloOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "monto" | "descripcion" | "importe" | "profesorId" | "createdAt" | "updatedAt", ExtArgs["result"]["estilo"]>
  export type EstiloInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deudas?: boolean | Estilo$deudasArgs<ExtArgs>
    conceptos?: boolean | Estilo$conceptosArgs<ExtArgs>
    clases?: boolean | Estilo$clasesArgs<ExtArgs>
    alumnoEstilos?: boolean | Estilo$alumnoEstilosArgs<ExtArgs>
    profesor?: boolean | Estilo$profesorArgs<ExtArgs>
    alumnos?: boolean | Estilo$alumnosArgs<ExtArgs>
    _count?: boolean | EstiloCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EstiloIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profesor?: boolean | Estilo$profesorArgs<ExtArgs>
  }
  export type EstiloIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profesor?: boolean | Estilo$profesorArgs<ExtArgs>
  }

  export type $EstiloPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Estilo"
    objects: {
      deudas: Prisma.$DeudaPayload<ExtArgs>[]
      conceptos: Prisma.$ConceptoPayload<ExtArgs>[]
      clases: Prisma.$ClasePayload<ExtArgs>[]
      alumnoEstilos: Prisma.$AlumnoEstilosPayload<ExtArgs>[]
      profesor: Prisma.$ProfesorPayload<ExtArgs> | null
      alumnos: Prisma.$AlumnoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      monto: number
      descripcion: string | null
      importe: number
      profesorId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["estilo"]>
    composites: {}
  }

  type EstiloGetPayload<S extends boolean | null | undefined | EstiloDefaultArgs> = $Result.GetResult<Prisma.$EstiloPayload, S>

  type EstiloCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EstiloFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EstiloCountAggregateInputType | true
    }

  export interface EstiloDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Estilo'], meta: { name: 'Estilo' } }
    /**
     * Find zero or one Estilo that matches the filter.
     * @param {EstiloFindUniqueArgs} args - Arguments to find a Estilo
     * @example
     * // Get one Estilo
     * const estilo = await prisma.estilo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EstiloFindUniqueArgs>(args: SelectSubset<T, EstiloFindUniqueArgs<ExtArgs>>): Prisma__EstiloClient<$Result.GetResult<Prisma.$EstiloPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Estilo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EstiloFindUniqueOrThrowArgs} args - Arguments to find a Estilo
     * @example
     * // Get one Estilo
     * const estilo = await prisma.estilo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EstiloFindUniqueOrThrowArgs>(args: SelectSubset<T, EstiloFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EstiloClient<$Result.GetResult<Prisma.$EstiloPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Estilo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstiloFindFirstArgs} args - Arguments to find a Estilo
     * @example
     * // Get one Estilo
     * const estilo = await prisma.estilo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EstiloFindFirstArgs>(args?: SelectSubset<T, EstiloFindFirstArgs<ExtArgs>>): Prisma__EstiloClient<$Result.GetResult<Prisma.$EstiloPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Estilo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstiloFindFirstOrThrowArgs} args - Arguments to find a Estilo
     * @example
     * // Get one Estilo
     * const estilo = await prisma.estilo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EstiloFindFirstOrThrowArgs>(args?: SelectSubset<T, EstiloFindFirstOrThrowArgs<ExtArgs>>): Prisma__EstiloClient<$Result.GetResult<Prisma.$EstiloPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Estilos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstiloFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estilos
     * const estilos = await prisma.estilo.findMany()
     * 
     * // Get first 10 Estilos
     * const estilos = await prisma.estilo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estiloWithIdOnly = await prisma.estilo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EstiloFindManyArgs>(args?: SelectSubset<T, EstiloFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstiloPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Estilo.
     * @param {EstiloCreateArgs} args - Arguments to create a Estilo.
     * @example
     * // Create one Estilo
     * const Estilo = await prisma.estilo.create({
     *   data: {
     *     // ... data to create a Estilo
     *   }
     * })
     * 
     */
    create<T extends EstiloCreateArgs>(args: SelectSubset<T, EstiloCreateArgs<ExtArgs>>): Prisma__EstiloClient<$Result.GetResult<Prisma.$EstiloPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Estilos.
     * @param {EstiloCreateManyArgs} args - Arguments to create many Estilos.
     * @example
     * // Create many Estilos
     * const estilo = await prisma.estilo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EstiloCreateManyArgs>(args?: SelectSubset<T, EstiloCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Estilos and returns the data saved in the database.
     * @param {EstiloCreateManyAndReturnArgs} args - Arguments to create many Estilos.
     * @example
     * // Create many Estilos
     * const estilo = await prisma.estilo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Estilos and only return the `id`
     * const estiloWithIdOnly = await prisma.estilo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EstiloCreateManyAndReturnArgs>(args?: SelectSubset<T, EstiloCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstiloPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Estilo.
     * @param {EstiloDeleteArgs} args - Arguments to delete one Estilo.
     * @example
     * // Delete one Estilo
     * const Estilo = await prisma.estilo.delete({
     *   where: {
     *     // ... filter to delete one Estilo
     *   }
     * })
     * 
     */
    delete<T extends EstiloDeleteArgs>(args: SelectSubset<T, EstiloDeleteArgs<ExtArgs>>): Prisma__EstiloClient<$Result.GetResult<Prisma.$EstiloPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Estilo.
     * @param {EstiloUpdateArgs} args - Arguments to update one Estilo.
     * @example
     * // Update one Estilo
     * const estilo = await prisma.estilo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EstiloUpdateArgs>(args: SelectSubset<T, EstiloUpdateArgs<ExtArgs>>): Prisma__EstiloClient<$Result.GetResult<Prisma.$EstiloPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Estilos.
     * @param {EstiloDeleteManyArgs} args - Arguments to filter Estilos to delete.
     * @example
     * // Delete a few Estilos
     * const { count } = await prisma.estilo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EstiloDeleteManyArgs>(args?: SelectSubset<T, EstiloDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estilos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstiloUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estilos
     * const estilo = await prisma.estilo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EstiloUpdateManyArgs>(args: SelectSubset<T, EstiloUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estilos and returns the data updated in the database.
     * @param {EstiloUpdateManyAndReturnArgs} args - Arguments to update many Estilos.
     * @example
     * // Update many Estilos
     * const estilo = await prisma.estilo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Estilos and only return the `id`
     * const estiloWithIdOnly = await prisma.estilo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EstiloUpdateManyAndReturnArgs>(args: SelectSubset<T, EstiloUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstiloPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Estilo.
     * @param {EstiloUpsertArgs} args - Arguments to update or create a Estilo.
     * @example
     * // Update or create a Estilo
     * const estilo = await prisma.estilo.upsert({
     *   create: {
     *     // ... data to create a Estilo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estilo we want to update
     *   }
     * })
     */
    upsert<T extends EstiloUpsertArgs>(args: SelectSubset<T, EstiloUpsertArgs<ExtArgs>>): Prisma__EstiloClient<$Result.GetResult<Prisma.$EstiloPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Estilos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstiloCountArgs} args - Arguments to filter Estilos to count.
     * @example
     * // Count the number of Estilos
     * const count = await prisma.estilo.count({
     *   where: {
     *     // ... the filter for the Estilos we want to count
     *   }
     * })
    **/
    count<T extends EstiloCountArgs>(
      args?: Subset<T, EstiloCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstiloCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Estilo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstiloAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstiloAggregateArgs>(args: Subset<T, EstiloAggregateArgs>): Prisma.PrismaPromise<GetEstiloAggregateType<T>>

    /**
     * Group by Estilo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstiloGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EstiloGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EstiloGroupByArgs['orderBy'] }
        : { orderBy?: EstiloGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EstiloGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstiloGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Estilo model
   */
  readonly fields: EstiloFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Estilo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EstiloClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deudas<T extends Estilo$deudasArgs<ExtArgs> = {}>(args?: Subset<T, Estilo$deudasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeudaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    conceptos<T extends Estilo$conceptosArgs<ExtArgs> = {}>(args?: Subset<T, Estilo$conceptosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    clases<T extends Estilo$clasesArgs<ExtArgs> = {}>(args?: Subset<T, Estilo$clasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClasePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    alumnoEstilos<T extends Estilo$alumnoEstilosArgs<ExtArgs> = {}>(args?: Subset<T, Estilo$alumnoEstilosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlumnoEstilosPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    profesor<T extends Estilo$profesorArgs<ExtArgs> = {}>(args?: Subset<T, Estilo$profesorArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    alumnos<T extends Estilo$alumnosArgs<ExtArgs> = {}>(args?: Subset<T, Estilo$alumnosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlumnoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Estilo model
   */ 
  interface EstiloFieldRefs {
    readonly id: FieldRef<"Estilo", 'Int'>
    readonly nombre: FieldRef<"Estilo", 'String'>
    readonly monto: FieldRef<"Estilo", 'Float'>
    readonly descripcion: FieldRef<"Estilo", 'String'>
    readonly importe: FieldRef<"Estilo", 'Float'>
    readonly profesorId: FieldRef<"Estilo", 'Int'>
    readonly createdAt: FieldRef<"Estilo", 'DateTime'>
    readonly updatedAt: FieldRef<"Estilo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Estilo findUnique
   */
  export type EstiloFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estilo
     */
    select?: EstiloSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estilo
     */
    omit?: EstiloOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstiloInclude<ExtArgs> | null
    /**
     * Filter, which Estilo to fetch.
     */
    where: EstiloWhereUniqueInput
  }

  /**
   * Estilo findUniqueOrThrow
   */
  export type EstiloFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estilo
     */
    select?: EstiloSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estilo
     */
    omit?: EstiloOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstiloInclude<ExtArgs> | null
    /**
     * Filter, which Estilo to fetch.
     */
    where: EstiloWhereUniqueInput
  }

  /**
   * Estilo findFirst
   */
  export type EstiloFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estilo
     */
    select?: EstiloSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estilo
     */
    omit?: EstiloOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstiloInclude<ExtArgs> | null
    /**
     * Filter, which Estilo to fetch.
     */
    where?: EstiloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estilos to fetch.
     */
    orderBy?: EstiloOrderByWithRelationInput | EstiloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Estilos.
     */
    cursor?: EstiloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estilos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estilos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Estilos.
     */
    distinct?: EstiloScalarFieldEnum | EstiloScalarFieldEnum[]
  }

  /**
   * Estilo findFirstOrThrow
   */
  export type EstiloFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estilo
     */
    select?: EstiloSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estilo
     */
    omit?: EstiloOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstiloInclude<ExtArgs> | null
    /**
     * Filter, which Estilo to fetch.
     */
    where?: EstiloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estilos to fetch.
     */
    orderBy?: EstiloOrderByWithRelationInput | EstiloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Estilos.
     */
    cursor?: EstiloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estilos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estilos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Estilos.
     */
    distinct?: EstiloScalarFieldEnum | EstiloScalarFieldEnum[]
  }

  /**
   * Estilo findMany
   */
  export type EstiloFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estilo
     */
    select?: EstiloSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estilo
     */
    omit?: EstiloOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstiloInclude<ExtArgs> | null
    /**
     * Filter, which Estilos to fetch.
     */
    where?: EstiloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estilos to fetch.
     */
    orderBy?: EstiloOrderByWithRelationInput | EstiloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Estilos.
     */
    cursor?: EstiloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estilos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estilos.
     */
    skip?: number
    distinct?: EstiloScalarFieldEnum | EstiloScalarFieldEnum[]
  }

  /**
   * Estilo create
   */
  export type EstiloCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estilo
     */
    select?: EstiloSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estilo
     */
    omit?: EstiloOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstiloInclude<ExtArgs> | null
    /**
     * The data needed to create a Estilo.
     */
    data: XOR<EstiloCreateInput, EstiloUncheckedCreateInput>
  }

  /**
   * Estilo createMany
   */
  export type EstiloCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Estilos.
     */
    data: EstiloCreateManyInput | EstiloCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Estilo createManyAndReturn
   */
  export type EstiloCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estilo
     */
    select?: EstiloSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Estilo
     */
    omit?: EstiloOmit<ExtArgs> | null
    /**
     * The data used to create many Estilos.
     */
    data: EstiloCreateManyInput | EstiloCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstiloIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Estilo update
   */
  export type EstiloUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estilo
     */
    select?: EstiloSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estilo
     */
    omit?: EstiloOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstiloInclude<ExtArgs> | null
    /**
     * The data needed to update a Estilo.
     */
    data: XOR<EstiloUpdateInput, EstiloUncheckedUpdateInput>
    /**
     * Choose, which Estilo to update.
     */
    where: EstiloWhereUniqueInput
  }

  /**
   * Estilo updateMany
   */
  export type EstiloUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Estilos.
     */
    data: XOR<EstiloUpdateManyMutationInput, EstiloUncheckedUpdateManyInput>
    /**
     * Filter which Estilos to update
     */
    where?: EstiloWhereInput
  }

  /**
   * Estilo updateManyAndReturn
   */
  export type EstiloUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estilo
     */
    select?: EstiloSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Estilo
     */
    omit?: EstiloOmit<ExtArgs> | null
    /**
     * The data used to update Estilos.
     */
    data: XOR<EstiloUpdateManyMutationInput, EstiloUncheckedUpdateManyInput>
    /**
     * Filter which Estilos to update
     */
    where?: EstiloWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstiloIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Estilo upsert
   */
  export type EstiloUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estilo
     */
    select?: EstiloSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estilo
     */
    omit?: EstiloOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstiloInclude<ExtArgs> | null
    /**
     * The filter to search for the Estilo to update in case it exists.
     */
    where: EstiloWhereUniqueInput
    /**
     * In case the Estilo found by the `where` argument doesn't exist, create a new Estilo with this data.
     */
    create: XOR<EstiloCreateInput, EstiloUncheckedCreateInput>
    /**
     * In case the Estilo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EstiloUpdateInput, EstiloUncheckedUpdateInput>
  }

  /**
   * Estilo delete
   */
  export type EstiloDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estilo
     */
    select?: EstiloSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estilo
     */
    omit?: EstiloOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstiloInclude<ExtArgs> | null
    /**
     * Filter which Estilo to delete.
     */
    where: EstiloWhereUniqueInput
  }

  /**
   * Estilo deleteMany
   */
  export type EstiloDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Estilos to delete
     */
    where?: EstiloWhereInput
  }

  /**
   * Estilo.deudas
   */
  export type Estilo$deudasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deuda
     */
    select?: DeudaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deuda
     */
    omit?: DeudaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeudaInclude<ExtArgs> | null
    where?: DeudaWhereInput
    orderBy?: DeudaOrderByWithRelationInput | DeudaOrderByWithRelationInput[]
    cursor?: DeudaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeudaScalarFieldEnum | DeudaScalarFieldEnum[]
  }

  /**
   * Estilo.conceptos
   */
  export type Estilo$conceptosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concepto
     */
    select?: ConceptoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Concepto
     */
    omit?: ConceptoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptoInclude<ExtArgs> | null
    where?: ConceptoWhereInput
    orderBy?: ConceptoOrderByWithRelationInput | ConceptoOrderByWithRelationInput[]
    cursor?: ConceptoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConceptoScalarFieldEnum | ConceptoScalarFieldEnum[]
  }

  /**
   * Estilo.clases
   */
  export type Estilo$clasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clase
     */
    omit?: ClaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaseInclude<ExtArgs> | null
    where?: ClaseWhereInput
    orderBy?: ClaseOrderByWithRelationInput | ClaseOrderByWithRelationInput[]
    cursor?: ClaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaseScalarFieldEnum | ClaseScalarFieldEnum[]
  }

  /**
   * Estilo.alumnoEstilos
   */
  export type Estilo$alumnoEstilosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoEstilos
     */
    select?: AlumnoEstilosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoEstilos
     */
    omit?: AlumnoEstilosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoEstilosInclude<ExtArgs> | null
    where?: AlumnoEstilosWhereInput
    orderBy?: AlumnoEstilosOrderByWithRelationInput | AlumnoEstilosOrderByWithRelationInput[]
    cursor?: AlumnoEstilosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlumnoEstilosScalarFieldEnum | AlumnoEstilosScalarFieldEnum[]
  }

  /**
   * Estilo.profesor
   */
  export type Estilo$profesorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profesor
     */
    omit?: ProfesorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    where?: ProfesorWhereInput
  }

  /**
   * Estilo.alumnos
   */
  export type Estilo$alumnosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alumno
     */
    select?: AlumnoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alumno
     */
    omit?: AlumnoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoInclude<ExtArgs> | null
    where?: AlumnoWhereInput
    orderBy?: AlumnoOrderByWithRelationInput | AlumnoOrderByWithRelationInput[]
    cursor?: AlumnoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlumnoScalarFieldEnum | AlumnoScalarFieldEnum[]
  }

  /**
   * Estilo without action
   */
  export type EstiloDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estilo
     */
    select?: EstiloSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estilo
     */
    omit?: EstiloOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstiloInclude<ExtArgs> | null
  }


  /**
   * Model AlumnoEstilos
   */

  export type AggregateAlumnoEstilos = {
    _count: AlumnoEstilosCountAggregateOutputType | null
    _avg: AlumnoEstilosAvgAggregateOutputType | null
    _sum: AlumnoEstilosSumAggregateOutputType | null
    _min: AlumnoEstilosMinAggregateOutputType | null
    _max: AlumnoEstilosMaxAggregateOutputType | null
  }

  export type AlumnoEstilosAvgAggregateOutputType = {
    id: number | null
    alumnoId: number | null
    estiloId: number | null
    montoPersonalizado: number | null
    descuentoPersonalizado: number | null
  }

  export type AlumnoEstilosSumAggregateOutputType = {
    id: number | null
    alumnoId: number | null
    estiloId: number | null
    montoPersonalizado: number | null
    descuentoPersonalizado: number | null
  }

  export type AlumnoEstilosMinAggregateOutputType = {
    id: number | null
    alumnoId: number | null
    estiloId: number | null
    activo: boolean | null
    fechaInicio: Date | null
    fechaFin: Date | null
    montoPersonalizado: number | null
    descuentoPersonalizado: number | null
    observaciones: string | null
  }

  export type AlumnoEstilosMaxAggregateOutputType = {
    id: number | null
    alumnoId: number | null
    estiloId: number | null
    activo: boolean | null
    fechaInicio: Date | null
    fechaFin: Date | null
    montoPersonalizado: number | null
    descuentoPersonalizado: number | null
    observaciones: string | null
  }

  export type AlumnoEstilosCountAggregateOutputType = {
    id: number
    alumnoId: number
    estiloId: number
    activo: number
    fechaInicio: number
    fechaFin: number
    montoPersonalizado: number
    descuentoPersonalizado: number
    observaciones: number
    _all: number
  }


  export type AlumnoEstilosAvgAggregateInputType = {
    id?: true
    alumnoId?: true
    estiloId?: true
    montoPersonalizado?: true
    descuentoPersonalizado?: true
  }

  export type AlumnoEstilosSumAggregateInputType = {
    id?: true
    alumnoId?: true
    estiloId?: true
    montoPersonalizado?: true
    descuentoPersonalizado?: true
  }

  export type AlumnoEstilosMinAggregateInputType = {
    id?: true
    alumnoId?: true
    estiloId?: true
    activo?: true
    fechaInicio?: true
    fechaFin?: true
    montoPersonalizado?: true
    descuentoPersonalizado?: true
    observaciones?: true
  }

  export type AlumnoEstilosMaxAggregateInputType = {
    id?: true
    alumnoId?: true
    estiloId?: true
    activo?: true
    fechaInicio?: true
    fechaFin?: true
    montoPersonalizado?: true
    descuentoPersonalizado?: true
    observaciones?: true
  }

  export type AlumnoEstilosCountAggregateInputType = {
    id?: true
    alumnoId?: true
    estiloId?: true
    activo?: true
    fechaInicio?: true
    fechaFin?: true
    montoPersonalizado?: true
    descuentoPersonalizado?: true
    observaciones?: true
    _all?: true
  }

  export type AlumnoEstilosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlumnoEstilos to aggregate.
     */
    where?: AlumnoEstilosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlumnoEstilos to fetch.
     */
    orderBy?: AlumnoEstilosOrderByWithRelationInput | AlumnoEstilosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlumnoEstilosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlumnoEstilos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlumnoEstilos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AlumnoEstilos
    **/
    _count?: true | AlumnoEstilosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlumnoEstilosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlumnoEstilosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlumnoEstilosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlumnoEstilosMaxAggregateInputType
  }

  export type GetAlumnoEstilosAggregateType<T extends AlumnoEstilosAggregateArgs> = {
        [P in keyof T & keyof AggregateAlumnoEstilos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlumnoEstilos[P]>
      : GetScalarType<T[P], AggregateAlumnoEstilos[P]>
  }




  export type AlumnoEstilosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlumnoEstilosWhereInput
    orderBy?: AlumnoEstilosOrderByWithAggregationInput | AlumnoEstilosOrderByWithAggregationInput[]
    by: AlumnoEstilosScalarFieldEnum[] | AlumnoEstilosScalarFieldEnum
    having?: AlumnoEstilosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlumnoEstilosCountAggregateInputType | true
    _avg?: AlumnoEstilosAvgAggregateInputType
    _sum?: AlumnoEstilosSumAggregateInputType
    _min?: AlumnoEstilosMinAggregateInputType
    _max?: AlumnoEstilosMaxAggregateInputType
  }

  export type AlumnoEstilosGroupByOutputType = {
    id: number
    alumnoId: number
    estiloId: number
    activo: boolean
    fechaInicio: Date
    fechaFin: Date | null
    montoPersonalizado: number | null
    descuentoPersonalizado: number | null
    observaciones: string | null
    _count: AlumnoEstilosCountAggregateOutputType | null
    _avg: AlumnoEstilosAvgAggregateOutputType | null
    _sum: AlumnoEstilosSumAggregateOutputType | null
    _min: AlumnoEstilosMinAggregateOutputType | null
    _max: AlumnoEstilosMaxAggregateOutputType | null
  }

  type GetAlumnoEstilosGroupByPayload<T extends AlumnoEstilosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlumnoEstilosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlumnoEstilosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlumnoEstilosGroupByOutputType[P]>
            : GetScalarType<T[P], AlumnoEstilosGroupByOutputType[P]>
        }
      >
    >


  export type AlumnoEstilosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alumnoId?: boolean
    estiloId?: boolean
    activo?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    montoPersonalizado?: boolean
    descuentoPersonalizado?: boolean
    observaciones?: boolean
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
    estilo?: boolean | EstiloDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alumnoEstilos"]>

  export type AlumnoEstilosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alumnoId?: boolean
    estiloId?: boolean
    activo?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    montoPersonalizado?: boolean
    descuentoPersonalizado?: boolean
    observaciones?: boolean
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
    estilo?: boolean | EstiloDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alumnoEstilos"]>

  export type AlumnoEstilosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alumnoId?: boolean
    estiloId?: boolean
    activo?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    montoPersonalizado?: boolean
    descuentoPersonalizado?: boolean
    observaciones?: boolean
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
    estilo?: boolean | EstiloDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alumnoEstilos"]>

  export type AlumnoEstilosSelectScalar = {
    id?: boolean
    alumnoId?: boolean
    estiloId?: boolean
    activo?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    montoPersonalizado?: boolean
    descuentoPersonalizado?: boolean
    observaciones?: boolean
  }

  export type AlumnoEstilosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "alumnoId" | "estiloId" | "activo" | "fechaInicio" | "fechaFin" | "montoPersonalizado" | "descuentoPersonalizado" | "observaciones", ExtArgs["result"]["alumnoEstilos"]>
  export type AlumnoEstilosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
    estilo?: boolean | EstiloDefaultArgs<ExtArgs>
  }
  export type AlumnoEstilosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
    estilo?: boolean | EstiloDefaultArgs<ExtArgs>
  }
  export type AlumnoEstilosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
    estilo?: boolean | EstiloDefaultArgs<ExtArgs>
  }

  export type $AlumnoEstilosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AlumnoEstilos"
    objects: {
      alumno: Prisma.$AlumnoPayload<ExtArgs>
      estilo: Prisma.$EstiloPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      alumnoId: number
      estiloId: number
      activo: boolean
      fechaInicio: Date
      fechaFin: Date | null
      montoPersonalizado: number | null
      descuentoPersonalizado: number | null
      observaciones: string | null
    }, ExtArgs["result"]["alumnoEstilos"]>
    composites: {}
  }

  type AlumnoEstilosGetPayload<S extends boolean | null | undefined | AlumnoEstilosDefaultArgs> = $Result.GetResult<Prisma.$AlumnoEstilosPayload, S>

  type AlumnoEstilosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlumnoEstilosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlumnoEstilosCountAggregateInputType | true
    }

  export interface AlumnoEstilosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AlumnoEstilos'], meta: { name: 'AlumnoEstilos' } }
    /**
     * Find zero or one AlumnoEstilos that matches the filter.
     * @param {AlumnoEstilosFindUniqueArgs} args - Arguments to find a AlumnoEstilos
     * @example
     * // Get one AlumnoEstilos
     * const alumnoEstilos = await prisma.alumnoEstilos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlumnoEstilosFindUniqueArgs>(args: SelectSubset<T, AlumnoEstilosFindUniqueArgs<ExtArgs>>): Prisma__AlumnoEstilosClient<$Result.GetResult<Prisma.$AlumnoEstilosPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AlumnoEstilos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlumnoEstilosFindUniqueOrThrowArgs} args - Arguments to find a AlumnoEstilos
     * @example
     * // Get one AlumnoEstilos
     * const alumnoEstilos = await prisma.alumnoEstilos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlumnoEstilosFindUniqueOrThrowArgs>(args: SelectSubset<T, AlumnoEstilosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlumnoEstilosClient<$Result.GetResult<Prisma.$AlumnoEstilosPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AlumnoEstilos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoEstilosFindFirstArgs} args - Arguments to find a AlumnoEstilos
     * @example
     * // Get one AlumnoEstilos
     * const alumnoEstilos = await prisma.alumnoEstilos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlumnoEstilosFindFirstArgs>(args?: SelectSubset<T, AlumnoEstilosFindFirstArgs<ExtArgs>>): Prisma__AlumnoEstilosClient<$Result.GetResult<Prisma.$AlumnoEstilosPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AlumnoEstilos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoEstilosFindFirstOrThrowArgs} args - Arguments to find a AlumnoEstilos
     * @example
     * // Get one AlumnoEstilos
     * const alumnoEstilos = await prisma.alumnoEstilos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlumnoEstilosFindFirstOrThrowArgs>(args?: SelectSubset<T, AlumnoEstilosFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlumnoEstilosClient<$Result.GetResult<Prisma.$AlumnoEstilosPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AlumnoEstilos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoEstilosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AlumnoEstilos
     * const alumnoEstilos = await prisma.alumnoEstilos.findMany()
     * 
     * // Get first 10 AlumnoEstilos
     * const alumnoEstilos = await prisma.alumnoEstilos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alumnoEstilosWithIdOnly = await prisma.alumnoEstilos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlumnoEstilosFindManyArgs>(args?: SelectSubset<T, AlumnoEstilosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlumnoEstilosPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AlumnoEstilos.
     * @param {AlumnoEstilosCreateArgs} args - Arguments to create a AlumnoEstilos.
     * @example
     * // Create one AlumnoEstilos
     * const AlumnoEstilos = await prisma.alumnoEstilos.create({
     *   data: {
     *     // ... data to create a AlumnoEstilos
     *   }
     * })
     * 
     */
    create<T extends AlumnoEstilosCreateArgs>(args: SelectSubset<T, AlumnoEstilosCreateArgs<ExtArgs>>): Prisma__AlumnoEstilosClient<$Result.GetResult<Prisma.$AlumnoEstilosPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AlumnoEstilos.
     * @param {AlumnoEstilosCreateManyArgs} args - Arguments to create many AlumnoEstilos.
     * @example
     * // Create many AlumnoEstilos
     * const alumnoEstilos = await prisma.alumnoEstilos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlumnoEstilosCreateManyArgs>(args?: SelectSubset<T, AlumnoEstilosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AlumnoEstilos and returns the data saved in the database.
     * @param {AlumnoEstilosCreateManyAndReturnArgs} args - Arguments to create many AlumnoEstilos.
     * @example
     * // Create many AlumnoEstilos
     * const alumnoEstilos = await prisma.alumnoEstilos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AlumnoEstilos and only return the `id`
     * const alumnoEstilosWithIdOnly = await prisma.alumnoEstilos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlumnoEstilosCreateManyAndReturnArgs>(args?: SelectSubset<T, AlumnoEstilosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlumnoEstilosPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AlumnoEstilos.
     * @param {AlumnoEstilosDeleteArgs} args - Arguments to delete one AlumnoEstilos.
     * @example
     * // Delete one AlumnoEstilos
     * const AlumnoEstilos = await prisma.alumnoEstilos.delete({
     *   where: {
     *     // ... filter to delete one AlumnoEstilos
     *   }
     * })
     * 
     */
    delete<T extends AlumnoEstilosDeleteArgs>(args: SelectSubset<T, AlumnoEstilosDeleteArgs<ExtArgs>>): Prisma__AlumnoEstilosClient<$Result.GetResult<Prisma.$AlumnoEstilosPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AlumnoEstilos.
     * @param {AlumnoEstilosUpdateArgs} args - Arguments to update one AlumnoEstilos.
     * @example
     * // Update one AlumnoEstilos
     * const alumnoEstilos = await prisma.alumnoEstilos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlumnoEstilosUpdateArgs>(args: SelectSubset<T, AlumnoEstilosUpdateArgs<ExtArgs>>): Prisma__AlumnoEstilosClient<$Result.GetResult<Prisma.$AlumnoEstilosPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AlumnoEstilos.
     * @param {AlumnoEstilosDeleteManyArgs} args - Arguments to filter AlumnoEstilos to delete.
     * @example
     * // Delete a few AlumnoEstilos
     * const { count } = await prisma.alumnoEstilos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlumnoEstilosDeleteManyArgs>(args?: SelectSubset<T, AlumnoEstilosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlumnoEstilos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoEstilosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AlumnoEstilos
     * const alumnoEstilos = await prisma.alumnoEstilos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlumnoEstilosUpdateManyArgs>(args: SelectSubset<T, AlumnoEstilosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlumnoEstilos and returns the data updated in the database.
     * @param {AlumnoEstilosUpdateManyAndReturnArgs} args - Arguments to update many AlumnoEstilos.
     * @example
     * // Update many AlumnoEstilos
     * const alumnoEstilos = await prisma.alumnoEstilos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AlumnoEstilos and only return the `id`
     * const alumnoEstilosWithIdOnly = await prisma.alumnoEstilos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlumnoEstilosUpdateManyAndReturnArgs>(args: SelectSubset<T, AlumnoEstilosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlumnoEstilosPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AlumnoEstilos.
     * @param {AlumnoEstilosUpsertArgs} args - Arguments to update or create a AlumnoEstilos.
     * @example
     * // Update or create a AlumnoEstilos
     * const alumnoEstilos = await prisma.alumnoEstilos.upsert({
     *   create: {
     *     // ... data to create a AlumnoEstilos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AlumnoEstilos we want to update
     *   }
     * })
     */
    upsert<T extends AlumnoEstilosUpsertArgs>(args: SelectSubset<T, AlumnoEstilosUpsertArgs<ExtArgs>>): Prisma__AlumnoEstilosClient<$Result.GetResult<Prisma.$AlumnoEstilosPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AlumnoEstilos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoEstilosCountArgs} args - Arguments to filter AlumnoEstilos to count.
     * @example
     * // Count the number of AlumnoEstilos
     * const count = await prisma.alumnoEstilos.count({
     *   where: {
     *     // ... the filter for the AlumnoEstilos we want to count
     *   }
     * })
    **/
    count<T extends AlumnoEstilosCountArgs>(
      args?: Subset<T, AlumnoEstilosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlumnoEstilosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AlumnoEstilos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoEstilosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlumnoEstilosAggregateArgs>(args: Subset<T, AlumnoEstilosAggregateArgs>): Prisma.PrismaPromise<GetAlumnoEstilosAggregateType<T>>

    /**
     * Group by AlumnoEstilos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoEstilosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlumnoEstilosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlumnoEstilosGroupByArgs['orderBy'] }
        : { orderBy?: AlumnoEstilosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlumnoEstilosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlumnoEstilosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AlumnoEstilos model
   */
  readonly fields: AlumnoEstilosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AlumnoEstilos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlumnoEstilosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    alumno<T extends AlumnoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlumnoDefaultArgs<ExtArgs>>): Prisma__AlumnoClient<$Result.GetResult<Prisma.$AlumnoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    estilo<T extends EstiloDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EstiloDefaultArgs<ExtArgs>>): Prisma__EstiloClient<$Result.GetResult<Prisma.$EstiloPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AlumnoEstilos model
   */ 
  interface AlumnoEstilosFieldRefs {
    readonly id: FieldRef<"AlumnoEstilos", 'Int'>
    readonly alumnoId: FieldRef<"AlumnoEstilos", 'Int'>
    readonly estiloId: FieldRef<"AlumnoEstilos", 'Int'>
    readonly activo: FieldRef<"AlumnoEstilos", 'Boolean'>
    readonly fechaInicio: FieldRef<"AlumnoEstilos", 'DateTime'>
    readonly fechaFin: FieldRef<"AlumnoEstilos", 'DateTime'>
    readonly montoPersonalizado: FieldRef<"AlumnoEstilos", 'Float'>
    readonly descuentoPersonalizado: FieldRef<"AlumnoEstilos", 'Float'>
    readonly observaciones: FieldRef<"AlumnoEstilos", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AlumnoEstilos findUnique
   */
  export type AlumnoEstilosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoEstilos
     */
    select?: AlumnoEstilosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoEstilos
     */
    omit?: AlumnoEstilosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoEstilosInclude<ExtArgs> | null
    /**
     * Filter, which AlumnoEstilos to fetch.
     */
    where: AlumnoEstilosWhereUniqueInput
  }

  /**
   * AlumnoEstilos findUniqueOrThrow
   */
  export type AlumnoEstilosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoEstilos
     */
    select?: AlumnoEstilosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoEstilos
     */
    omit?: AlumnoEstilosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoEstilosInclude<ExtArgs> | null
    /**
     * Filter, which AlumnoEstilos to fetch.
     */
    where: AlumnoEstilosWhereUniqueInput
  }

  /**
   * AlumnoEstilos findFirst
   */
  export type AlumnoEstilosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoEstilos
     */
    select?: AlumnoEstilosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoEstilos
     */
    omit?: AlumnoEstilosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoEstilosInclude<ExtArgs> | null
    /**
     * Filter, which AlumnoEstilos to fetch.
     */
    where?: AlumnoEstilosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlumnoEstilos to fetch.
     */
    orderBy?: AlumnoEstilosOrderByWithRelationInput | AlumnoEstilosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlumnoEstilos.
     */
    cursor?: AlumnoEstilosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlumnoEstilos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlumnoEstilos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlumnoEstilos.
     */
    distinct?: AlumnoEstilosScalarFieldEnum | AlumnoEstilosScalarFieldEnum[]
  }

  /**
   * AlumnoEstilos findFirstOrThrow
   */
  export type AlumnoEstilosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoEstilos
     */
    select?: AlumnoEstilosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoEstilos
     */
    omit?: AlumnoEstilosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoEstilosInclude<ExtArgs> | null
    /**
     * Filter, which AlumnoEstilos to fetch.
     */
    where?: AlumnoEstilosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlumnoEstilos to fetch.
     */
    orderBy?: AlumnoEstilosOrderByWithRelationInput | AlumnoEstilosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlumnoEstilos.
     */
    cursor?: AlumnoEstilosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlumnoEstilos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlumnoEstilos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlumnoEstilos.
     */
    distinct?: AlumnoEstilosScalarFieldEnum | AlumnoEstilosScalarFieldEnum[]
  }

  /**
   * AlumnoEstilos findMany
   */
  export type AlumnoEstilosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoEstilos
     */
    select?: AlumnoEstilosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoEstilos
     */
    omit?: AlumnoEstilosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoEstilosInclude<ExtArgs> | null
    /**
     * Filter, which AlumnoEstilos to fetch.
     */
    where?: AlumnoEstilosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlumnoEstilos to fetch.
     */
    orderBy?: AlumnoEstilosOrderByWithRelationInput | AlumnoEstilosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AlumnoEstilos.
     */
    cursor?: AlumnoEstilosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlumnoEstilos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlumnoEstilos.
     */
    skip?: number
    distinct?: AlumnoEstilosScalarFieldEnum | AlumnoEstilosScalarFieldEnum[]
  }

  /**
   * AlumnoEstilos create
   */
  export type AlumnoEstilosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoEstilos
     */
    select?: AlumnoEstilosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoEstilos
     */
    omit?: AlumnoEstilosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoEstilosInclude<ExtArgs> | null
    /**
     * The data needed to create a AlumnoEstilos.
     */
    data: XOR<AlumnoEstilosCreateInput, AlumnoEstilosUncheckedCreateInput>
  }

  /**
   * AlumnoEstilos createMany
   */
  export type AlumnoEstilosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AlumnoEstilos.
     */
    data: AlumnoEstilosCreateManyInput | AlumnoEstilosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AlumnoEstilos createManyAndReturn
   */
  export type AlumnoEstilosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoEstilos
     */
    select?: AlumnoEstilosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoEstilos
     */
    omit?: AlumnoEstilosOmit<ExtArgs> | null
    /**
     * The data used to create many AlumnoEstilos.
     */
    data: AlumnoEstilosCreateManyInput | AlumnoEstilosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoEstilosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AlumnoEstilos update
   */
  export type AlumnoEstilosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoEstilos
     */
    select?: AlumnoEstilosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoEstilos
     */
    omit?: AlumnoEstilosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoEstilosInclude<ExtArgs> | null
    /**
     * The data needed to update a AlumnoEstilos.
     */
    data: XOR<AlumnoEstilosUpdateInput, AlumnoEstilosUncheckedUpdateInput>
    /**
     * Choose, which AlumnoEstilos to update.
     */
    where: AlumnoEstilosWhereUniqueInput
  }

  /**
   * AlumnoEstilos updateMany
   */
  export type AlumnoEstilosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AlumnoEstilos.
     */
    data: XOR<AlumnoEstilosUpdateManyMutationInput, AlumnoEstilosUncheckedUpdateManyInput>
    /**
     * Filter which AlumnoEstilos to update
     */
    where?: AlumnoEstilosWhereInput
  }

  /**
   * AlumnoEstilos updateManyAndReturn
   */
  export type AlumnoEstilosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoEstilos
     */
    select?: AlumnoEstilosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoEstilos
     */
    omit?: AlumnoEstilosOmit<ExtArgs> | null
    /**
     * The data used to update AlumnoEstilos.
     */
    data: XOR<AlumnoEstilosUpdateManyMutationInput, AlumnoEstilosUncheckedUpdateManyInput>
    /**
     * Filter which AlumnoEstilos to update
     */
    where?: AlumnoEstilosWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoEstilosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AlumnoEstilos upsert
   */
  export type AlumnoEstilosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoEstilos
     */
    select?: AlumnoEstilosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoEstilos
     */
    omit?: AlumnoEstilosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoEstilosInclude<ExtArgs> | null
    /**
     * The filter to search for the AlumnoEstilos to update in case it exists.
     */
    where: AlumnoEstilosWhereUniqueInput
    /**
     * In case the AlumnoEstilos found by the `where` argument doesn't exist, create a new AlumnoEstilos with this data.
     */
    create: XOR<AlumnoEstilosCreateInput, AlumnoEstilosUncheckedCreateInput>
    /**
     * In case the AlumnoEstilos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlumnoEstilosUpdateInput, AlumnoEstilosUncheckedUpdateInput>
  }

  /**
   * AlumnoEstilos delete
   */
  export type AlumnoEstilosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoEstilos
     */
    select?: AlumnoEstilosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoEstilos
     */
    omit?: AlumnoEstilosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoEstilosInclude<ExtArgs> | null
    /**
     * Filter which AlumnoEstilos to delete.
     */
    where: AlumnoEstilosWhereUniqueInput
  }

  /**
   * AlumnoEstilos deleteMany
   */
  export type AlumnoEstilosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlumnoEstilos to delete
     */
    where?: AlumnoEstilosWhereInput
  }

  /**
   * AlumnoEstilos without action
   */
  export type AlumnoEstilosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoEstilos
     */
    select?: AlumnoEstilosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoEstilos
     */
    omit?: AlumnoEstilosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoEstilosInclude<ExtArgs> | null
  }


  /**
   * Model Profesor
   */

  export type AggregateProfesor = {
    _count: ProfesorCountAggregateOutputType | null
    _avg: ProfesorAvgAggregateOutputType | null
    _sum: ProfesorSumAggregateOutputType | null
    _min: ProfesorMinAggregateOutputType | null
    _max: ProfesorMaxAggregateOutputType | null
  }

  export type ProfesorAvgAggregateOutputType = {
    id: number | null
    porcentajePorDefecto: number | null
    porcentajeClasesSueltasPorDefecto: number | null
  }

  export type ProfesorSumAggregateOutputType = {
    id: number | null
    porcentajePorDefecto: number | null
    porcentajeClasesSueltasPorDefecto: number | null
  }

  export type ProfesorMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellido: string | null
    dni: string | null
    fechaNacimiento: Date | null
    direccion: string | null
    cuit: string | null
    email: string | null
    telefono: string | null
    fechaIngreso: Date | null
    porcentajePorDefecto: number | null
    porcentajeClasesSueltasPorDefecto: number | null
    activo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfesorMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellido: string | null
    dni: string | null
    fechaNacimiento: Date | null
    direccion: string | null
    cuit: string | null
    email: string | null
    telefono: string | null
    fechaIngreso: Date | null
    porcentajePorDefecto: number | null
    porcentajeClasesSueltasPorDefecto: number | null
    activo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfesorCountAggregateOutputType = {
    id: number
    nombre: number
    apellido: number
    dni: number
    fechaNacimiento: number
    direccion: number
    cuit: number
    email: number
    telefono: number
    fechaIngreso: number
    porcentajePorDefecto: number
    porcentajeClasesSueltasPorDefecto: number
    activo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfesorAvgAggregateInputType = {
    id?: true
    porcentajePorDefecto?: true
    porcentajeClasesSueltasPorDefecto?: true
  }

  export type ProfesorSumAggregateInputType = {
    id?: true
    porcentajePorDefecto?: true
    porcentajeClasesSueltasPorDefecto?: true
  }

  export type ProfesorMinAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    dni?: true
    fechaNacimiento?: true
    direccion?: true
    cuit?: true
    email?: true
    telefono?: true
    fechaIngreso?: true
    porcentajePorDefecto?: true
    porcentajeClasesSueltasPorDefecto?: true
    activo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfesorMaxAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    dni?: true
    fechaNacimiento?: true
    direccion?: true
    cuit?: true
    email?: true
    telefono?: true
    fechaIngreso?: true
    porcentajePorDefecto?: true
    porcentajeClasesSueltasPorDefecto?: true
    activo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfesorCountAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    dni?: true
    fechaNacimiento?: true
    direccion?: true
    cuit?: true
    email?: true
    telefono?: true
    fechaIngreso?: true
    porcentajePorDefecto?: true
    porcentajeClasesSueltasPorDefecto?: true
    activo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfesorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profesor to aggregate.
     */
    where?: ProfesorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profesors to fetch.
     */
    orderBy?: ProfesorOrderByWithRelationInput | ProfesorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfesorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profesors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profesors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profesors
    **/
    _count?: true | ProfesorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfesorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfesorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfesorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfesorMaxAggregateInputType
  }

  export type GetProfesorAggregateType<T extends ProfesorAggregateArgs> = {
        [P in keyof T & keyof AggregateProfesor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfesor[P]>
      : GetScalarType<T[P], AggregateProfesor[P]>
  }




  export type ProfesorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfesorWhereInput
    orderBy?: ProfesorOrderByWithAggregationInput | ProfesorOrderByWithAggregationInput[]
    by: ProfesorScalarFieldEnum[] | ProfesorScalarFieldEnum
    having?: ProfesorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfesorCountAggregateInputType | true
    _avg?: ProfesorAvgAggregateInputType
    _sum?: ProfesorSumAggregateInputType
    _min?: ProfesorMinAggregateInputType
    _max?: ProfesorMaxAggregateInputType
  }

  export type ProfesorGroupByOutputType = {
    id: number
    nombre: string
    apellido: string
    dni: string
    fechaNacimiento: Date | null
    direccion: string | null
    cuit: string | null
    email: string | null
    telefono: string | null
    fechaIngreso: Date
    porcentajePorDefecto: number
    porcentajeClasesSueltasPorDefecto: number
    activo: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProfesorCountAggregateOutputType | null
    _avg: ProfesorAvgAggregateOutputType | null
    _sum: ProfesorSumAggregateOutputType | null
    _min: ProfesorMinAggregateOutputType | null
    _max: ProfesorMaxAggregateOutputType | null
  }

  type GetProfesorGroupByPayload<T extends ProfesorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfesorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfesorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfesorGroupByOutputType[P]>
            : GetScalarType<T[P], ProfesorGroupByOutputType[P]>
        }
      >
    >


  export type ProfesorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    dni?: boolean
    fechaNacimiento?: boolean
    direccion?: boolean
    cuit?: boolean
    email?: boolean
    telefono?: boolean
    fechaIngreso?: boolean
    porcentajePorDefecto?: boolean
    porcentajeClasesSueltasPorDefecto?: boolean
    activo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clases?: boolean | Profesor$clasesArgs<ExtArgs>
    estilos?: boolean | Profesor$estilosArgs<ExtArgs>
    liquidaciones?: boolean | Profesor$liquidacionesArgs<ExtArgs>
    _count?: boolean | ProfesorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profesor"]>

  export type ProfesorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    dni?: boolean
    fechaNacimiento?: boolean
    direccion?: boolean
    cuit?: boolean
    email?: boolean
    telefono?: boolean
    fechaIngreso?: boolean
    porcentajePorDefecto?: boolean
    porcentajeClasesSueltasPorDefecto?: boolean
    activo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["profesor"]>

  export type ProfesorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    dni?: boolean
    fechaNacimiento?: boolean
    direccion?: boolean
    cuit?: boolean
    email?: boolean
    telefono?: boolean
    fechaIngreso?: boolean
    porcentajePorDefecto?: boolean
    porcentajeClasesSueltasPorDefecto?: boolean
    activo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["profesor"]>

  export type ProfesorSelectScalar = {
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    dni?: boolean
    fechaNacimiento?: boolean
    direccion?: boolean
    cuit?: boolean
    email?: boolean
    telefono?: boolean
    fechaIngreso?: boolean
    porcentajePorDefecto?: boolean
    porcentajeClasesSueltasPorDefecto?: boolean
    activo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfesorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "apellido" | "dni" | "fechaNacimiento" | "direccion" | "cuit" | "email" | "telefono" | "fechaIngreso" | "porcentajePorDefecto" | "porcentajeClasesSueltasPorDefecto" | "activo" | "createdAt" | "updatedAt", ExtArgs["result"]["profesor"]>
  export type ProfesorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clases?: boolean | Profesor$clasesArgs<ExtArgs>
    estilos?: boolean | Profesor$estilosArgs<ExtArgs>
    liquidaciones?: boolean | Profesor$liquidacionesArgs<ExtArgs>
    _count?: boolean | ProfesorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProfesorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProfesorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProfesorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profesor"
    objects: {
      clases: Prisma.$ClasePayload<ExtArgs>[]
      estilos: Prisma.$EstiloPayload<ExtArgs>[]
      liquidaciones: Prisma.$LiquidacionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      apellido: string
      dni: string
      fechaNacimiento: Date | null
      direccion: string | null
      cuit: string | null
      email: string | null
      telefono: string | null
      fechaIngreso: Date
      porcentajePorDefecto: number
      porcentajeClasesSueltasPorDefecto: number
      activo: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profesor"]>
    composites: {}
  }

  type ProfesorGetPayload<S extends boolean | null | undefined | ProfesorDefaultArgs> = $Result.GetResult<Prisma.$ProfesorPayload, S>

  type ProfesorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfesorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfesorCountAggregateInputType | true
    }

  export interface ProfesorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profesor'], meta: { name: 'Profesor' } }
    /**
     * Find zero or one Profesor that matches the filter.
     * @param {ProfesorFindUniqueArgs} args - Arguments to find a Profesor
     * @example
     * // Get one Profesor
     * const profesor = await prisma.profesor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfesorFindUniqueArgs>(args: SelectSubset<T, ProfesorFindUniqueArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Profesor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfesorFindUniqueOrThrowArgs} args - Arguments to find a Profesor
     * @example
     * // Get one Profesor
     * const profesor = await prisma.profesor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfesorFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfesorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Profesor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesorFindFirstArgs} args - Arguments to find a Profesor
     * @example
     * // Get one Profesor
     * const profesor = await prisma.profesor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfesorFindFirstArgs>(args?: SelectSubset<T, ProfesorFindFirstArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Profesor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesorFindFirstOrThrowArgs} args - Arguments to find a Profesor
     * @example
     * // Get one Profesor
     * const profesor = await prisma.profesor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfesorFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfesorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Profesors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profesors
     * const profesors = await prisma.profesor.findMany()
     * 
     * // Get first 10 Profesors
     * const profesors = await prisma.profesor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profesorWithIdOnly = await prisma.profesor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfesorFindManyArgs>(args?: SelectSubset<T, ProfesorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Profesor.
     * @param {ProfesorCreateArgs} args - Arguments to create a Profesor.
     * @example
     * // Create one Profesor
     * const Profesor = await prisma.profesor.create({
     *   data: {
     *     // ... data to create a Profesor
     *   }
     * })
     * 
     */
    create<T extends ProfesorCreateArgs>(args: SelectSubset<T, ProfesorCreateArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Profesors.
     * @param {ProfesorCreateManyArgs} args - Arguments to create many Profesors.
     * @example
     * // Create many Profesors
     * const profesor = await prisma.profesor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfesorCreateManyArgs>(args?: SelectSubset<T, ProfesorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profesors and returns the data saved in the database.
     * @param {ProfesorCreateManyAndReturnArgs} args - Arguments to create many Profesors.
     * @example
     * // Create many Profesors
     * const profesor = await prisma.profesor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profesors and only return the `id`
     * const profesorWithIdOnly = await prisma.profesor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfesorCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfesorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Profesor.
     * @param {ProfesorDeleteArgs} args - Arguments to delete one Profesor.
     * @example
     * // Delete one Profesor
     * const Profesor = await prisma.profesor.delete({
     *   where: {
     *     // ... filter to delete one Profesor
     *   }
     * })
     * 
     */
    delete<T extends ProfesorDeleteArgs>(args: SelectSubset<T, ProfesorDeleteArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Profesor.
     * @param {ProfesorUpdateArgs} args - Arguments to update one Profesor.
     * @example
     * // Update one Profesor
     * const profesor = await prisma.profesor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfesorUpdateArgs>(args: SelectSubset<T, ProfesorUpdateArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Profesors.
     * @param {ProfesorDeleteManyArgs} args - Arguments to filter Profesors to delete.
     * @example
     * // Delete a few Profesors
     * const { count } = await prisma.profesor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfesorDeleteManyArgs>(args?: SelectSubset<T, ProfesorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profesors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profesors
     * const profesor = await prisma.profesor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfesorUpdateManyArgs>(args: SelectSubset<T, ProfesorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profesors and returns the data updated in the database.
     * @param {ProfesorUpdateManyAndReturnArgs} args - Arguments to update many Profesors.
     * @example
     * // Update many Profesors
     * const profesor = await prisma.profesor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Profesors and only return the `id`
     * const profesorWithIdOnly = await prisma.profesor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfesorUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfesorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Profesor.
     * @param {ProfesorUpsertArgs} args - Arguments to update or create a Profesor.
     * @example
     * // Update or create a Profesor
     * const profesor = await prisma.profesor.upsert({
     *   create: {
     *     // ... data to create a Profesor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profesor we want to update
     *   }
     * })
     */
    upsert<T extends ProfesorUpsertArgs>(args: SelectSubset<T, ProfesorUpsertArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Profesors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesorCountArgs} args - Arguments to filter Profesors to count.
     * @example
     * // Count the number of Profesors
     * const count = await prisma.profesor.count({
     *   where: {
     *     // ... the filter for the Profesors we want to count
     *   }
     * })
    **/
    count<T extends ProfesorCountArgs>(
      args?: Subset<T, ProfesorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfesorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profesor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfesorAggregateArgs>(args: Subset<T, ProfesorAggregateArgs>): Prisma.PrismaPromise<GetProfesorAggregateType<T>>

    /**
     * Group by Profesor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfesorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfesorGroupByArgs['orderBy'] }
        : { orderBy?: ProfesorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfesorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfesorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profesor model
   */
  readonly fields: ProfesorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profesor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfesorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clases<T extends Profesor$clasesArgs<ExtArgs> = {}>(args?: Subset<T, Profesor$clasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClasePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    estilos<T extends Profesor$estilosArgs<ExtArgs> = {}>(args?: Subset<T, Profesor$estilosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstiloPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    liquidaciones<T extends Profesor$liquidacionesArgs<ExtArgs> = {}>(args?: Subset<T, Profesor$liquidacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiquidacionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profesor model
   */ 
  interface ProfesorFieldRefs {
    readonly id: FieldRef<"Profesor", 'Int'>
    readonly nombre: FieldRef<"Profesor", 'String'>
    readonly apellido: FieldRef<"Profesor", 'String'>
    readonly dni: FieldRef<"Profesor", 'String'>
    readonly fechaNacimiento: FieldRef<"Profesor", 'DateTime'>
    readonly direccion: FieldRef<"Profesor", 'String'>
    readonly cuit: FieldRef<"Profesor", 'String'>
    readonly email: FieldRef<"Profesor", 'String'>
    readonly telefono: FieldRef<"Profesor", 'String'>
    readonly fechaIngreso: FieldRef<"Profesor", 'DateTime'>
    readonly porcentajePorDefecto: FieldRef<"Profesor", 'Float'>
    readonly porcentajeClasesSueltasPorDefecto: FieldRef<"Profesor", 'Float'>
    readonly activo: FieldRef<"Profesor", 'Boolean'>
    readonly createdAt: FieldRef<"Profesor", 'DateTime'>
    readonly updatedAt: FieldRef<"Profesor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Profesor findUnique
   */
  export type ProfesorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profesor
     */
    omit?: ProfesorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    /**
     * Filter, which Profesor to fetch.
     */
    where: ProfesorWhereUniqueInput
  }

  /**
   * Profesor findUniqueOrThrow
   */
  export type ProfesorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profesor
     */
    omit?: ProfesorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    /**
     * Filter, which Profesor to fetch.
     */
    where: ProfesorWhereUniqueInput
  }

  /**
   * Profesor findFirst
   */
  export type ProfesorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profesor
     */
    omit?: ProfesorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    /**
     * Filter, which Profesor to fetch.
     */
    where?: ProfesorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profesors to fetch.
     */
    orderBy?: ProfesorOrderByWithRelationInput | ProfesorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profesors.
     */
    cursor?: ProfesorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profesors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profesors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profesors.
     */
    distinct?: ProfesorScalarFieldEnum | ProfesorScalarFieldEnum[]
  }

  /**
   * Profesor findFirstOrThrow
   */
  export type ProfesorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profesor
     */
    omit?: ProfesorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    /**
     * Filter, which Profesor to fetch.
     */
    where?: ProfesorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profesors to fetch.
     */
    orderBy?: ProfesorOrderByWithRelationInput | ProfesorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profesors.
     */
    cursor?: ProfesorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profesors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profesors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profesors.
     */
    distinct?: ProfesorScalarFieldEnum | ProfesorScalarFieldEnum[]
  }

  /**
   * Profesor findMany
   */
  export type ProfesorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profesor
     */
    omit?: ProfesorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    /**
     * Filter, which Profesors to fetch.
     */
    where?: ProfesorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profesors to fetch.
     */
    orderBy?: ProfesorOrderByWithRelationInput | ProfesorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profesors.
     */
    cursor?: ProfesorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profesors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profesors.
     */
    skip?: number
    distinct?: ProfesorScalarFieldEnum | ProfesorScalarFieldEnum[]
  }

  /**
   * Profesor create
   */
  export type ProfesorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profesor
     */
    omit?: ProfesorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    /**
     * The data needed to create a Profesor.
     */
    data: XOR<ProfesorCreateInput, ProfesorUncheckedCreateInput>
  }

  /**
   * Profesor createMany
   */
  export type ProfesorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profesors.
     */
    data: ProfesorCreateManyInput | ProfesorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profesor createManyAndReturn
   */
  export type ProfesorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profesor
     */
    omit?: ProfesorOmit<ExtArgs> | null
    /**
     * The data used to create many Profesors.
     */
    data: ProfesorCreateManyInput | ProfesorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profesor update
   */
  export type ProfesorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profesor
     */
    omit?: ProfesorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    /**
     * The data needed to update a Profesor.
     */
    data: XOR<ProfesorUpdateInput, ProfesorUncheckedUpdateInput>
    /**
     * Choose, which Profesor to update.
     */
    where: ProfesorWhereUniqueInput
  }

  /**
   * Profesor updateMany
   */
  export type ProfesorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profesors.
     */
    data: XOR<ProfesorUpdateManyMutationInput, ProfesorUncheckedUpdateManyInput>
    /**
     * Filter which Profesors to update
     */
    where?: ProfesorWhereInput
  }

  /**
   * Profesor updateManyAndReturn
   */
  export type ProfesorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profesor
     */
    omit?: ProfesorOmit<ExtArgs> | null
    /**
     * The data used to update Profesors.
     */
    data: XOR<ProfesorUpdateManyMutationInput, ProfesorUncheckedUpdateManyInput>
    /**
     * Filter which Profesors to update
     */
    where?: ProfesorWhereInput
  }

  /**
   * Profesor upsert
   */
  export type ProfesorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profesor
     */
    omit?: ProfesorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    /**
     * The filter to search for the Profesor to update in case it exists.
     */
    where: ProfesorWhereUniqueInput
    /**
     * In case the Profesor found by the `where` argument doesn't exist, create a new Profesor with this data.
     */
    create: XOR<ProfesorCreateInput, ProfesorUncheckedCreateInput>
    /**
     * In case the Profesor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfesorUpdateInput, ProfesorUncheckedUpdateInput>
  }

  /**
   * Profesor delete
   */
  export type ProfesorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profesor
     */
    omit?: ProfesorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    /**
     * Filter which Profesor to delete.
     */
    where: ProfesorWhereUniqueInput
  }

  /**
   * Profesor deleteMany
   */
  export type ProfesorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profesors to delete
     */
    where?: ProfesorWhereInput
  }

  /**
   * Profesor.clases
   */
  export type Profesor$clasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clase
     */
    omit?: ClaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaseInclude<ExtArgs> | null
    where?: ClaseWhereInput
    orderBy?: ClaseOrderByWithRelationInput | ClaseOrderByWithRelationInput[]
    cursor?: ClaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaseScalarFieldEnum | ClaseScalarFieldEnum[]
  }

  /**
   * Profesor.estilos
   */
  export type Profesor$estilosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estilo
     */
    select?: EstiloSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estilo
     */
    omit?: EstiloOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstiloInclude<ExtArgs> | null
    where?: EstiloWhereInput
    orderBy?: EstiloOrderByWithRelationInput | EstiloOrderByWithRelationInput[]
    cursor?: EstiloWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EstiloScalarFieldEnum | EstiloScalarFieldEnum[]
  }

  /**
   * Profesor.liquidaciones
   */
  export type Profesor$liquidacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liquidacion
     */
    select?: LiquidacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liquidacion
     */
    omit?: LiquidacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiquidacionInclude<ExtArgs> | null
    where?: LiquidacionWhereInput
    orderBy?: LiquidacionOrderByWithRelationInput | LiquidacionOrderByWithRelationInput[]
    cursor?: LiquidacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiquidacionScalarFieldEnum | LiquidacionScalarFieldEnum[]
  }

  /**
   * Profesor without action
   */
  export type ProfesorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profesor
     */
    omit?: ProfesorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
  }


  /**
   * Model CtaCte
   */

  export type AggregateCtaCte = {
    _count: CtaCteCountAggregateOutputType | null
    _avg: CtaCteAvgAggregateOutputType | null
    _sum: CtaCteSumAggregateOutputType | null
    _min: CtaCteMinAggregateOutputType | null
    _max: CtaCteMaxAggregateOutputType | null
  }

  export type CtaCteAvgAggregateOutputType = {
    id: number | null
    saldo: number | null
    alumnoId: number | null
  }

  export type CtaCteSumAggregateOutputType = {
    id: number | null
    saldo: number | null
    alumnoId: number | null
  }

  export type CtaCteMinAggregateOutputType = {
    id: number | null
    saldo: number | null
    alumnoId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CtaCteMaxAggregateOutputType = {
    id: number | null
    saldo: number | null
    alumnoId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CtaCteCountAggregateOutputType = {
    id: number
    saldo: number
    alumnoId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CtaCteAvgAggregateInputType = {
    id?: true
    saldo?: true
    alumnoId?: true
  }

  export type CtaCteSumAggregateInputType = {
    id?: true
    saldo?: true
    alumnoId?: true
  }

  export type CtaCteMinAggregateInputType = {
    id?: true
    saldo?: true
    alumnoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CtaCteMaxAggregateInputType = {
    id?: true
    saldo?: true
    alumnoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CtaCteCountAggregateInputType = {
    id?: true
    saldo?: true
    alumnoId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CtaCteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CtaCte to aggregate.
     */
    where?: CtaCteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CtaCtes to fetch.
     */
    orderBy?: CtaCteOrderByWithRelationInput | CtaCteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CtaCteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CtaCtes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CtaCtes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CtaCtes
    **/
    _count?: true | CtaCteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CtaCteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CtaCteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CtaCteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CtaCteMaxAggregateInputType
  }

  export type GetCtaCteAggregateType<T extends CtaCteAggregateArgs> = {
        [P in keyof T & keyof AggregateCtaCte]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCtaCte[P]>
      : GetScalarType<T[P], AggregateCtaCte[P]>
  }




  export type CtaCteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CtaCteWhereInput
    orderBy?: CtaCteOrderByWithAggregationInput | CtaCteOrderByWithAggregationInput[]
    by: CtaCteScalarFieldEnum[] | CtaCteScalarFieldEnum
    having?: CtaCteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CtaCteCountAggregateInputType | true
    _avg?: CtaCteAvgAggregateInputType
    _sum?: CtaCteSumAggregateInputType
    _min?: CtaCteMinAggregateInputType
    _max?: CtaCteMaxAggregateInputType
  }

  export type CtaCteGroupByOutputType = {
    id: number
    saldo: number
    alumnoId: number
    createdAt: Date
    updatedAt: Date
    _count: CtaCteCountAggregateOutputType | null
    _avg: CtaCteAvgAggregateOutputType | null
    _sum: CtaCteSumAggregateOutputType | null
    _min: CtaCteMinAggregateOutputType | null
    _max: CtaCteMaxAggregateOutputType | null
  }

  type GetCtaCteGroupByPayload<T extends CtaCteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CtaCteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CtaCteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CtaCteGroupByOutputType[P]>
            : GetScalarType<T[P], CtaCteGroupByOutputType[P]>
        }
      >
    >


  export type CtaCteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saldo?: boolean
    alumnoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ctaCte"]>

  export type CtaCteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saldo?: boolean
    alumnoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ctaCte"]>

  export type CtaCteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saldo?: boolean
    alumnoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ctaCte"]>

  export type CtaCteSelectScalar = {
    id?: boolean
    saldo?: boolean
    alumnoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CtaCteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "saldo" | "alumnoId" | "createdAt" | "updatedAt", ExtArgs["result"]["ctaCte"]>
  export type CtaCteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
  }
  export type CtaCteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
  }
  export type CtaCteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
  }

  export type $CtaCtePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CtaCte"
    objects: {
      alumno: Prisma.$AlumnoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      saldo: number
      alumnoId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ctaCte"]>
    composites: {}
  }

  type CtaCteGetPayload<S extends boolean | null | undefined | CtaCteDefaultArgs> = $Result.GetResult<Prisma.$CtaCtePayload, S>

  type CtaCteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CtaCteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CtaCteCountAggregateInputType | true
    }

  export interface CtaCteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CtaCte'], meta: { name: 'CtaCte' } }
    /**
     * Find zero or one CtaCte that matches the filter.
     * @param {CtaCteFindUniqueArgs} args - Arguments to find a CtaCte
     * @example
     * // Get one CtaCte
     * const ctaCte = await prisma.ctaCte.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CtaCteFindUniqueArgs>(args: SelectSubset<T, CtaCteFindUniqueArgs<ExtArgs>>): Prisma__CtaCteClient<$Result.GetResult<Prisma.$CtaCtePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CtaCte that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CtaCteFindUniqueOrThrowArgs} args - Arguments to find a CtaCte
     * @example
     * // Get one CtaCte
     * const ctaCte = await prisma.ctaCte.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CtaCteFindUniqueOrThrowArgs>(args: SelectSubset<T, CtaCteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CtaCteClient<$Result.GetResult<Prisma.$CtaCtePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CtaCte that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CtaCteFindFirstArgs} args - Arguments to find a CtaCte
     * @example
     * // Get one CtaCte
     * const ctaCte = await prisma.ctaCte.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CtaCteFindFirstArgs>(args?: SelectSubset<T, CtaCteFindFirstArgs<ExtArgs>>): Prisma__CtaCteClient<$Result.GetResult<Prisma.$CtaCtePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CtaCte that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CtaCteFindFirstOrThrowArgs} args - Arguments to find a CtaCte
     * @example
     * // Get one CtaCte
     * const ctaCte = await prisma.ctaCte.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CtaCteFindFirstOrThrowArgs>(args?: SelectSubset<T, CtaCteFindFirstOrThrowArgs<ExtArgs>>): Prisma__CtaCteClient<$Result.GetResult<Prisma.$CtaCtePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CtaCtes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CtaCteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CtaCtes
     * const ctaCtes = await prisma.ctaCte.findMany()
     * 
     * // Get first 10 CtaCtes
     * const ctaCtes = await prisma.ctaCte.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ctaCteWithIdOnly = await prisma.ctaCte.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CtaCteFindManyArgs>(args?: SelectSubset<T, CtaCteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CtaCtePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CtaCte.
     * @param {CtaCteCreateArgs} args - Arguments to create a CtaCte.
     * @example
     * // Create one CtaCte
     * const CtaCte = await prisma.ctaCte.create({
     *   data: {
     *     // ... data to create a CtaCte
     *   }
     * })
     * 
     */
    create<T extends CtaCteCreateArgs>(args: SelectSubset<T, CtaCteCreateArgs<ExtArgs>>): Prisma__CtaCteClient<$Result.GetResult<Prisma.$CtaCtePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CtaCtes.
     * @param {CtaCteCreateManyArgs} args - Arguments to create many CtaCtes.
     * @example
     * // Create many CtaCtes
     * const ctaCte = await prisma.ctaCte.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CtaCteCreateManyArgs>(args?: SelectSubset<T, CtaCteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CtaCtes and returns the data saved in the database.
     * @param {CtaCteCreateManyAndReturnArgs} args - Arguments to create many CtaCtes.
     * @example
     * // Create many CtaCtes
     * const ctaCte = await prisma.ctaCte.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CtaCtes and only return the `id`
     * const ctaCteWithIdOnly = await prisma.ctaCte.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CtaCteCreateManyAndReturnArgs>(args?: SelectSubset<T, CtaCteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CtaCtePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a CtaCte.
     * @param {CtaCteDeleteArgs} args - Arguments to delete one CtaCte.
     * @example
     * // Delete one CtaCte
     * const CtaCte = await prisma.ctaCte.delete({
     *   where: {
     *     // ... filter to delete one CtaCte
     *   }
     * })
     * 
     */
    delete<T extends CtaCteDeleteArgs>(args: SelectSubset<T, CtaCteDeleteArgs<ExtArgs>>): Prisma__CtaCteClient<$Result.GetResult<Prisma.$CtaCtePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CtaCte.
     * @param {CtaCteUpdateArgs} args - Arguments to update one CtaCte.
     * @example
     * // Update one CtaCte
     * const ctaCte = await prisma.ctaCte.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CtaCteUpdateArgs>(args: SelectSubset<T, CtaCteUpdateArgs<ExtArgs>>): Prisma__CtaCteClient<$Result.GetResult<Prisma.$CtaCtePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CtaCtes.
     * @param {CtaCteDeleteManyArgs} args - Arguments to filter CtaCtes to delete.
     * @example
     * // Delete a few CtaCtes
     * const { count } = await prisma.ctaCte.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CtaCteDeleteManyArgs>(args?: SelectSubset<T, CtaCteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CtaCtes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CtaCteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CtaCtes
     * const ctaCte = await prisma.ctaCte.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CtaCteUpdateManyArgs>(args: SelectSubset<T, CtaCteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CtaCtes and returns the data updated in the database.
     * @param {CtaCteUpdateManyAndReturnArgs} args - Arguments to update many CtaCtes.
     * @example
     * // Update many CtaCtes
     * const ctaCte = await prisma.ctaCte.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CtaCtes and only return the `id`
     * const ctaCteWithIdOnly = await prisma.ctaCte.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CtaCteUpdateManyAndReturnArgs>(args: SelectSubset<T, CtaCteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CtaCtePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one CtaCte.
     * @param {CtaCteUpsertArgs} args - Arguments to update or create a CtaCte.
     * @example
     * // Update or create a CtaCte
     * const ctaCte = await prisma.ctaCte.upsert({
     *   create: {
     *     // ... data to create a CtaCte
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CtaCte we want to update
     *   }
     * })
     */
    upsert<T extends CtaCteUpsertArgs>(args: SelectSubset<T, CtaCteUpsertArgs<ExtArgs>>): Prisma__CtaCteClient<$Result.GetResult<Prisma.$CtaCtePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CtaCtes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CtaCteCountArgs} args - Arguments to filter CtaCtes to count.
     * @example
     * // Count the number of CtaCtes
     * const count = await prisma.ctaCte.count({
     *   where: {
     *     // ... the filter for the CtaCtes we want to count
     *   }
     * })
    **/
    count<T extends CtaCteCountArgs>(
      args?: Subset<T, CtaCteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CtaCteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CtaCte.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CtaCteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CtaCteAggregateArgs>(args: Subset<T, CtaCteAggregateArgs>): Prisma.PrismaPromise<GetCtaCteAggregateType<T>>

    /**
     * Group by CtaCte.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CtaCteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CtaCteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CtaCteGroupByArgs['orderBy'] }
        : { orderBy?: CtaCteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CtaCteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCtaCteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CtaCte model
   */
  readonly fields: CtaCteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CtaCte.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CtaCteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    alumno<T extends AlumnoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlumnoDefaultArgs<ExtArgs>>): Prisma__AlumnoClient<$Result.GetResult<Prisma.$AlumnoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CtaCte model
   */ 
  interface CtaCteFieldRefs {
    readonly id: FieldRef<"CtaCte", 'Int'>
    readonly saldo: FieldRef<"CtaCte", 'Float'>
    readonly alumnoId: FieldRef<"CtaCte", 'Int'>
    readonly createdAt: FieldRef<"CtaCte", 'DateTime'>
    readonly updatedAt: FieldRef<"CtaCte", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CtaCte findUnique
   */
  export type CtaCteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CtaCte
     */
    select?: CtaCteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CtaCte
     */
    omit?: CtaCteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CtaCteInclude<ExtArgs> | null
    /**
     * Filter, which CtaCte to fetch.
     */
    where: CtaCteWhereUniqueInput
  }

  /**
   * CtaCte findUniqueOrThrow
   */
  export type CtaCteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CtaCte
     */
    select?: CtaCteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CtaCte
     */
    omit?: CtaCteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CtaCteInclude<ExtArgs> | null
    /**
     * Filter, which CtaCte to fetch.
     */
    where: CtaCteWhereUniqueInput
  }

  /**
   * CtaCte findFirst
   */
  export type CtaCteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CtaCte
     */
    select?: CtaCteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CtaCte
     */
    omit?: CtaCteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CtaCteInclude<ExtArgs> | null
    /**
     * Filter, which CtaCte to fetch.
     */
    where?: CtaCteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CtaCtes to fetch.
     */
    orderBy?: CtaCteOrderByWithRelationInput | CtaCteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CtaCtes.
     */
    cursor?: CtaCteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CtaCtes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CtaCtes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CtaCtes.
     */
    distinct?: CtaCteScalarFieldEnum | CtaCteScalarFieldEnum[]
  }

  /**
   * CtaCte findFirstOrThrow
   */
  export type CtaCteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CtaCte
     */
    select?: CtaCteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CtaCte
     */
    omit?: CtaCteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CtaCteInclude<ExtArgs> | null
    /**
     * Filter, which CtaCte to fetch.
     */
    where?: CtaCteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CtaCtes to fetch.
     */
    orderBy?: CtaCteOrderByWithRelationInput | CtaCteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CtaCtes.
     */
    cursor?: CtaCteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CtaCtes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CtaCtes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CtaCtes.
     */
    distinct?: CtaCteScalarFieldEnum | CtaCteScalarFieldEnum[]
  }

  /**
   * CtaCte findMany
   */
  export type CtaCteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CtaCte
     */
    select?: CtaCteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CtaCte
     */
    omit?: CtaCteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CtaCteInclude<ExtArgs> | null
    /**
     * Filter, which CtaCtes to fetch.
     */
    where?: CtaCteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CtaCtes to fetch.
     */
    orderBy?: CtaCteOrderByWithRelationInput | CtaCteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CtaCtes.
     */
    cursor?: CtaCteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CtaCtes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CtaCtes.
     */
    skip?: number
    distinct?: CtaCteScalarFieldEnum | CtaCteScalarFieldEnum[]
  }

  /**
   * CtaCte create
   */
  export type CtaCteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CtaCte
     */
    select?: CtaCteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CtaCte
     */
    omit?: CtaCteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CtaCteInclude<ExtArgs> | null
    /**
     * The data needed to create a CtaCte.
     */
    data: XOR<CtaCteCreateInput, CtaCteUncheckedCreateInput>
  }

  /**
   * CtaCte createMany
   */
  export type CtaCteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CtaCtes.
     */
    data: CtaCteCreateManyInput | CtaCteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CtaCte createManyAndReturn
   */
  export type CtaCteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CtaCte
     */
    select?: CtaCteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CtaCte
     */
    omit?: CtaCteOmit<ExtArgs> | null
    /**
     * The data used to create many CtaCtes.
     */
    data: CtaCteCreateManyInput | CtaCteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CtaCteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CtaCte update
   */
  export type CtaCteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CtaCte
     */
    select?: CtaCteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CtaCte
     */
    omit?: CtaCteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CtaCteInclude<ExtArgs> | null
    /**
     * The data needed to update a CtaCte.
     */
    data: XOR<CtaCteUpdateInput, CtaCteUncheckedUpdateInput>
    /**
     * Choose, which CtaCte to update.
     */
    where: CtaCteWhereUniqueInput
  }

  /**
   * CtaCte updateMany
   */
  export type CtaCteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CtaCtes.
     */
    data: XOR<CtaCteUpdateManyMutationInput, CtaCteUncheckedUpdateManyInput>
    /**
     * Filter which CtaCtes to update
     */
    where?: CtaCteWhereInput
  }

  /**
   * CtaCte updateManyAndReturn
   */
  export type CtaCteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CtaCte
     */
    select?: CtaCteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CtaCte
     */
    omit?: CtaCteOmit<ExtArgs> | null
    /**
     * The data used to update CtaCtes.
     */
    data: XOR<CtaCteUpdateManyMutationInput, CtaCteUncheckedUpdateManyInput>
    /**
     * Filter which CtaCtes to update
     */
    where?: CtaCteWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CtaCteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CtaCte upsert
   */
  export type CtaCteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CtaCte
     */
    select?: CtaCteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CtaCte
     */
    omit?: CtaCteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CtaCteInclude<ExtArgs> | null
    /**
     * The filter to search for the CtaCte to update in case it exists.
     */
    where: CtaCteWhereUniqueInput
    /**
     * In case the CtaCte found by the `where` argument doesn't exist, create a new CtaCte with this data.
     */
    create: XOR<CtaCteCreateInput, CtaCteUncheckedCreateInput>
    /**
     * In case the CtaCte was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CtaCteUpdateInput, CtaCteUncheckedUpdateInput>
  }

  /**
   * CtaCte delete
   */
  export type CtaCteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CtaCte
     */
    select?: CtaCteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CtaCte
     */
    omit?: CtaCteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CtaCteInclude<ExtArgs> | null
    /**
     * Filter which CtaCte to delete.
     */
    where: CtaCteWhereUniqueInput
  }

  /**
   * CtaCte deleteMany
   */
  export type CtaCteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CtaCtes to delete
     */
    where?: CtaCteWhereInput
  }

  /**
   * CtaCte without action
   */
  export type CtaCteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CtaCte
     */
    select?: CtaCteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CtaCte
     */
    omit?: CtaCteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CtaCteInclude<ExtArgs> | null
  }


  /**
   * Model CajaDiaria
   */

  export type AggregateCajaDiaria = {
    _count: CajaDiariaCountAggregateOutputType | null
    _avg: CajaDiariaAvgAggregateOutputType | null
    _sum: CajaDiariaSumAggregateOutputType | null
    _min: CajaDiariaMinAggregateOutputType | null
    _max: CajaDiariaMaxAggregateOutputType | null
  }

  export type CajaDiariaAvgAggregateOutputType = {
    id: number | null
    apertura: number | null
    cierre: number | null
    diferencia: number | null
  }

  export type CajaDiariaSumAggregateOutputType = {
    id: number | null
    apertura: number | null
    cierre: number | null
    diferencia: number | null
  }

  export type CajaDiariaMinAggregateOutputType = {
    id: number | null
    fecha: Date | null
    apertura: number | null
    cierre: number | null
    diferencia: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CajaDiariaMaxAggregateOutputType = {
    id: number | null
    fecha: Date | null
    apertura: number | null
    cierre: number | null
    diferencia: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CajaDiariaCountAggregateOutputType = {
    id: number
    fecha: number
    apertura: number
    cierre: number
    diferencia: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CajaDiariaAvgAggregateInputType = {
    id?: true
    apertura?: true
    cierre?: true
    diferencia?: true
  }

  export type CajaDiariaSumAggregateInputType = {
    id?: true
    apertura?: true
    cierre?: true
    diferencia?: true
  }

  export type CajaDiariaMinAggregateInputType = {
    id?: true
    fecha?: true
    apertura?: true
    cierre?: true
    diferencia?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CajaDiariaMaxAggregateInputType = {
    id?: true
    fecha?: true
    apertura?: true
    cierre?: true
    diferencia?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CajaDiariaCountAggregateInputType = {
    id?: true
    fecha?: true
    apertura?: true
    cierre?: true
    diferencia?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CajaDiariaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CajaDiaria to aggregate.
     */
    where?: CajaDiariaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CajaDiarias to fetch.
     */
    orderBy?: CajaDiariaOrderByWithRelationInput | CajaDiariaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CajaDiariaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CajaDiarias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CajaDiarias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CajaDiarias
    **/
    _count?: true | CajaDiariaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CajaDiariaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CajaDiariaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CajaDiariaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CajaDiariaMaxAggregateInputType
  }

  export type GetCajaDiariaAggregateType<T extends CajaDiariaAggregateArgs> = {
        [P in keyof T & keyof AggregateCajaDiaria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCajaDiaria[P]>
      : GetScalarType<T[P], AggregateCajaDiaria[P]>
  }




  export type CajaDiariaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CajaDiariaWhereInput
    orderBy?: CajaDiariaOrderByWithAggregationInput | CajaDiariaOrderByWithAggregationInput[]
    by: CajaDiariaScalarFieldEnum[] | CajaDiariaScalarFieldEnum
    having?: CajaDiariaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CajaDiariaCountAggregateInputType | true
    _avg?: CajaDiariaAvgAggregateInputType
    _sum?: CajaDiariaSumAggregateInputType
    _min?: CajaDiariaMinAggregateInputType
    _max?: CajaDiariaMaxAggregateInputType
  }

  export type CajaDiariaGroupByOutputType = {
    id: number
    fecha: Date
    apertura: number
    cierre: number
    diferencia: number
    createdAt: Date
    updatedAt: Date
    _count: CajaDiariaCountAggregateOutputType | null
    _avg: CajaDiariaAvgAggregateOutputType | null
    _sum: CajaDiariaSumAggregateOutputType | null
    _min: CajaDiariaMinAggregateOutputType | null
    _max: CajaDiariaMaxAggregateOutputType | null
  }

  type GetCajaDiariaGroupByPayload<T extends CajaDiariaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CajaDiariaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CajaDiariaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CajaDiariaGroupByOutputType[P]>
            : GetScalarType<T[P], CajaDiariaGroupByOutputType[P]>
        }
      >
    >


  export type CajaDiariaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fecha?: boolean
    apertura?: boolean
    cierre?: boolean
    diferencia?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cajaDiaria"]>

  export type CajaDiariaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fecha?: boolean
    apertura?: boolean
    cierre?: boolean
    diferencia?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cajaDiaria"]>

  export type CajaDiariaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fecha?: boolean
    apertura?: boolean
    cierre?: boolean
    diferencia?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cajaDiaria"]>

  export type CajaDiariaSelectScalar = {
    id?: boolean
    fecha?: boolean
    apertura?: boolean
    cierre?: boolean
    diferencia?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CajaDiariaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fecha" | "apertura" | "cierre" | "diferencia" | "createdAt" | "updatedAt", ExtArgs["result"]["cajaDiaria"]>

  export type $CajaDiariaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CajaDiaria"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fecha: Date
      apertura: number
      cierre: number
      diferencia: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cajaDiaria"]>
    composites: {}
  }

  type CajaDiariaGetPayload<S extends boolean | null | undefined | CajaDiariaDefaultArgs> = $Result.GetResult<Prisma.$CajaDiariaPayload, S>

  type CajaDiariaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CajaDiariaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CajaDiariaCountAggregateInputType | true
    }

  export interface CajaDiariaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CajaDiaria'], meta: { name: 'CajaDiaria' } }
    /**
     * Find zero or one CajaDiaria that matches the filter.
     * @param {CajaDiariaFindUniqueArgs} args - Arguments to find a CajaDiaria
     * @example
     * // Get one CajaDiaria
     * const cajaDiaria = await prisma.cajaDiaria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CajaDiariaFindUniqueArgs>(args: SelectSubset<T, CajaDiariaFindUniqueArgs<ExtArgs>>): Prisma__CajaDiariaClient<$Result.GetResult<Prisma.$CajaDiariaPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CajaDiaria that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CajaDiariaFindUniqueOrThrowArgs} args - Arguments to find a CajaDiaria
     * @example
     * // Get one CajaDiaria
     * const cajaDiaria = await prisma.cajaDiaria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CajaDiariaFindUniqueOrThrowArgs>(args: SelectSubset<T, CajaDiariaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CajaDiariaClient<$Result.GetResult<Prisma.$CajaDiariaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CajaDiaria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CajaDiariaFindFirstArgs} args - Arguments to find a CajaDiaria
     * @example
     * // Get one CajaDiaria
     * const cajaDiaria = await prisma.cajaDiaria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CajaDiariaFindFirstArgs>(args?: SelectSubset<T, CajaDiariaFindFirstArgs<ExtArgs>>): Prisma__CajaDiariaClient<$Result.GetResult<Prisma.$CajaDiariaPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CajaDiaria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CajaDiariaFindFirstOrThrowArgs} args - Arguments to find a CajaDiaria
     * @example
     * // Get one CajaDiaria
     * const cajaDiaria = await prisma.cajaDiaria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CajaDiariaFindFirstOrThrowArgs>(args?: SelectSubset<T, CajaDiariaFindFirstOrThrowArgs<ExtArgs>>): Prisma__CajaDiariaClient<$Result.GetResult<Prisma.$CajaDiariaPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CajaDiarias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CajaDiariaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CajaDiarias
     * const cajaDiarias = await prisma.cajaDiaria.findMany()
     * 
     * // Get first 10 CajaDiarias
     * const cajaDiarias = await prisma.cajaDiaria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cajaDiariaWithIdOnly = await prisma.cajaDiaria.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CajaDiariaFindManyArgs>(args?: SelectSubset<T, CajaDiariaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CajaDiariaPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CajaDiaria.
     * @param {CajaDiariaCreateArgs} args - Arguments to create a CajaDiaria.
     * @example
     * // Create one CajaDiaria
     * const CajaDiaria = await prisma.cajaDiaria.create({
     *   data: {
     *     // ... data to create a CajaDiaria
     *   }
     * })
     * 
     */
    create<T extends CajaDiariaCreateArgs>(args: SelectSubset<T, CajaDiariaCreateArgs<ExtArgs>>): Prisma__CajaDiariaClient<$Result.GetResult<Prisma.$CajaDiariaPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CajaDiarias.
     * @param {CajaDiariaCreateManyArgs} args - Arguments to create many CajaDiarias.
     * @example
     * // Create many CajaDiarias
     * const cajaDiaria = await prisma.cajaDiaria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CajaDiariaCreateManyArgs>(args?: SelectSubset<T, CajaDiariaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CajaDiarias and returns the data saved in the database.
     * @param {CajaDiariaCreateManyAndReturnArgs} args - Arguments to create many CajaDiarias.
     * @example
     * // Create many CajaDiarias
     * const cajaDiaria = await prisma.cajaDiaria.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CajaDiarias and only return the `id`
     * const cajaDiariaWithIdOnly = await prisma.cajaDiaria.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CajaDiariaCreateManyAndReturnArgs>(args?: SelectSubset<T, CajaDiariaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CajaDiariaPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a CajaDiaria.
     * @param {CajaDiariaDeleteArgs} args - Arguments to delete one CajaDiaria.
     * @example
     * // Delete one CajaDiaria
     * const CajaDiaria = await prisma.cajaDiaria.delete({
     *   where: {
     *     // ... filter to delete one CajaDiaria
     *   }
     * })
     * 
     */
    delete<T extends CajaDiariaDeleteArgs>(args: SelectSubset<T, CajaDiariaDeleteArgs<ExtArgs>>): Prisma__CajaDiariaClient<$Result.GetResult<Prisma.$CajaDiariaPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CajaDiaria.
     * @param {CajaDiariaUpdateArgs} args - Arguments to update one CajaDiaria.
     * @example
     * // Update one CajaDiaria
     * const cajaDiaria = await prisma.cajaDiaria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CajaDiariaUpdateArgs>(args: SelectSubset<T, CajaDiariaUpdateArgs<ExtArgs>>): Prisma__CajaDiariaClient<$Result.GetResult<Prisma.$CajaDiariaPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CajaDiarias.
     * @param {CajaDiariaDeleteManyArgs} args - Arguments to filter CajaDiarias to delete.
     * @example
     * // Delete a few CajaDiarias
     * const { count } = await prisma.cajaDiaria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CajaDiariaDeleteManyArgs>(args?: SelectSubset<T, CajaDiariaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CajaDiarias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CajaDiariaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CajaDiarias
     * const cajaDiaria = await prisma.cajaDiaria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CajaDiariaUpdateManyArgs>(args: SelectSubset<T, CajaDiariaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CajaDiarias and returns the data updated in the database.
     * @param {CajaDiariaUpdateManyAndReturnArgs} args - Arguments to update many CajaDiarias.
     * @example
     * // Update many CajaDiarias
     * const cajaDiaria = await prisma.cajaDiaria.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CajaDiarias and only return the `id`
     * const cajaDiariaWithIdOnly = await prisma.cajaDiaria.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CajaDiariaUpdateManyAndReturnArgs>(args: SelectSubset<T, CajaDiariaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CajaDiariaPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one CajaDiaria.
     * @param {CajaDiariaUpsertArgs} args - Arguments to update or create a CajaDiaria.
     * @example
     * // Update or create a CajaDiaria
     * const cajaDiaria = await prisma.cajaDiaria.upsert({
     *   create: {
     *     // ... data to create a CajaDiaria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CajaDiaria we want to update
     *   }
     * })
     */
    upsert<T extends CajaDiariaUpsertArgs>(args: SelectSubset<T, CajaDiariaUpsertArgs<ExtArgs>>): Prisma__CajaDiariaClient<$Result.GetResult<Prisma.$CajaDiariaPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CajaDiarias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CajaDiariaCountArgs} args - Arguments to filter CajaDiarias to count.
     * @example
     * // Count the number of CajaDiarias
     * const count = await prisma.cajaDiaria.count({
     *   where: {
     *     // ... the filter for the CajaDiarias we want to count
     *   }
     * })
    **/
    count<T extends CajaDiariaCountArgs>(
      args?: Subset<T, CajaDiariaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CajaDiariaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CajaDiaria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CajaDiariaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CajaDiariaAggregateArgs>(args: Subset<T, CajaDiariaAggregateArgs>): Prisma.PrismaPromise<GetCajaDiariaAggregateType<T>>

    /**
     * Group by CajaDiaria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CajaDiariaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CajaDiariaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CajaDiariaGroupByArgs['orderBy'] }
        : { orderBy?: CajaDiariaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CajaDiariaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCajaDiariaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CajaDiaria model
   */
  readonly fields: CajaDiariaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CajaDiaria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CajaDiariaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CajaDiaria model
   */ 
  interface CajaDiariaFieldRefs {
    readonly id: FieldRef<"CajaDiaria", 'Int'>
    readonly fecha: FieldRef<"CajaDiaria", 'DateTime'>
    readonly apertura: FieldRef<"CajaDiaria", 'Float'>
    readonly cierre: FieldRef<"CajaDiaria", 'Float'>
    readonly diferencia: FieldRef<"CajaDiaria", 'Float'>
    readonly createdAt: FieldRef<"CajaDiaria", 'DateTime'>
    readonly updatedAt: FieldRef<"CajaDiaria", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CajaDiaria findUnique
   */
  export type CajaDiariaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CajaDiaria
     */
    select?: CajaDiariaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CajaDiaria
     */
    omit?: CajaDiariaOmit<ExtArgs> | null
    /**
     * Filter, which CajaDiaria to fetch.
     */
    where: CajaDiariaWhereUniqueInput
  }

  /**
   * CajaDiaria findUniqueOrThrow
   */
  export type CajaDiariaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CajaDiaria
     */
    select?: CajaDiariaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CajaDiaria
     */
    omit?: CajaDiariaOmit<ExtArgs> | null
    /**
     * Filter, which CajaDiaria to fetch.
     */
    where: CajaDiariaWhereUniqueInput
  }

  /**
   * CajaDiaria findFirst
   */
  export type CajaDiariaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CajaDiaria
     */
    select?: CajaDiariaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CajaDiaria
     */
    omit?: CajaDiariaOmit<ExtArgs> | null
    /**
     * Filter, which CajaDiaria to fetch.
     */
    where?: CajaDiariaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CajaDiarias to fetch.
     */
    orderBy?: CajaDiariaOrderByWithRelationInput | CajaDiariaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CajaDiarias.
     */
    cursor?: CajaDiariaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CajaDiarias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CajaDiarias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CajaDiarias.
     */
    distinct?: CajaDiariaScalarFieldEnum | CajaDiariaScalarFieldEnum[]
  }

  /**
   * CajaDiaria findFirstOrThrow
   */
  export type CajaDiariaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CajaDiaria
     */
    select?: CajaDiariaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CajaDiaria
     */
    omit?: CajaDiariaOmit<ExtArgs> | null
    /**
     * Filter, which CajaDiaria to fetch.
     */
    where?: CajaDiariaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CajaDiarias to fetch.
     */
    orderBy?: CajaDiariaOrderByWithRelationInput | CajaDiariaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CajaDiarias.
     */
    cursor?: CajaDiariaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CajaDiarias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CajaDiarias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CajaDiarias.
     */
    distinct?: CajaDiariaScalarFieldEnum | CajaDiariaScalarFieldEnum[]
  }

  /**
   * CajaDiaria findMany
   */
  export type CajaDiariaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CajaDiaria
     */
    select?: CajaDiariaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CajaDiaria
     */
    omit?: CajaDiariaOmit<ExtArgs> | null
    /**
     * Filter, which CajaDiarias to fetch.
     */
    where?: CajaDiariaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CajaDiarias to fetch.
     */
    orderBy?: CajaDiariaOrderByWithRelationInput | CajaDiariaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CajaDiarias.
     */
    cursor?: CajaDiariaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CajaDiarias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CajaDiarias.
     */
    skip?: number
    distinct?: CajaDiariaScalarFieldEnum | CajaDiariaScalarFieldEnum[]
  }

  /**
   * CajaDiaria create
   */
  export type CajaDiariaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CajaDiaria
     */
    select?: CajaDiariaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CajaDiaria
     */
    omit?: CajaDiariaOmit<ExtArgs> | null
    /**
     * The data needed to create a CajaDiaria.
     */
    data: XOR<CajaDiariaCreateInput, CajaDiariaUncheckedCreateInput>
  }

  /**
   * CajaDiaria createMany
   */
  export type CajaDiariaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CajaDiarias.
     */
    data: CajaDiariaCreateManyInput | CajaDiariaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CajaDiaria createManyAndReturn
   */
  export type CajaDiariaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CajaDiaria
     */
    select?: CajaDiariaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CajaDiaria
     */
    omit?: CajaDiariaOmit<ExtArgs> | null
    /**
     * The data used to create many CajaDiarias.
     */
    data: CajaDiariaCreateManyInput | CajaDiariaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CajaDiaria update
   */
  export type CajaDiariaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CajaDiaria
     */
    select?: CajaDiariaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CajaDiaria
     */
    omit?: CajaDiariaOmit<ExtArgs> | null
    /**
     * The data needed to update a CajaDiaria.
     */
    data: XOR<CajaDiariaUpdateInput, CajaDiariaUncheckedUpdateInput>
    /**
     * Choose, which CajaDiaria to update.
     */
    where: CajaDiariaWhereUniqueInput
  }

  /**
   * CajaDiaria updateMany
   */
  export type CajaDiariaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CajaDiarias.
     */
    data: XOR<CajaDiariaUpdateManyMutationInput, CajaDiariaUncheckedUpdateManyInput>
    /**
     * Filter which CajaDiarias to update
     */
    where?: CajaDiariaWhereInput
  }

  /**
   * CajaDiaria updateManyAndReturn
   */
  export type CajaDiariaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CajaDiaria
     */
    select?: CajaDiariaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CajaDiaria
     */
    omit?: CajaDiariaOmit<ExtArgs> | null
    /**
     * The data used to update CajaDiarias.
     */
    data: XOR<CajaDiariaUpdateManyMutationInput, CajaDiariaUncheckedUpdateManyInput>
    /**
     * Filter which CajaDiarias to update
     */
    where?: CajaDiariaWhereInput
  }

  /**
   * CajaDiaria upsert
   */
  export type CajaDiariaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CajaDiaria
     */
    select?: CajaDiariaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CajaDiaria
     */
    omit?: CajaDiariaOmit<ExtArgs> | null
    /**
     * The filter to search for the CajaDiaria to update in case it exists.
     */
    where: CajaDiariaWhereUniqueInput
    /**
     * In case the CajaDiaria found by the `where` argument doesn't exist, create a new CajaDiaria with this data.
     */
    create: XOR<CajaDiariaCreateInput, CajaDiariaUncheckedCreateInput>
    /**
     * In case the CajaDiaria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CajaDiariaUpdateInput, CajaDiariaUncheckedUpdateInput>
  }

  /**
   * CajaDiaria delete
   */
  export type CajaDiariaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CajaDiaria
     */
    select?: CajaDiariaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CajaDiaria
     */
    omit?: CajaDiariaOmit<ExtArgs> | null
    /**
     * Filter which CajaDiaria to delete.
     */
    where: CajaDiariaWhereUniqueInput
  }

  /**
   * CajaDiaria deleteMany
   */
  export type CajaDiariaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CajaDiarias to delete
     */
    where?: CajaDiariaWhereInput
  }

  /**
   * CajaDiaria without action
   */
  export type CajaDiariaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CajaDiaria
     */
    select?: CajaDiariaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CajaDiaria
     */
    omit?: CajaDiariaOmit<ExtArgs> | null
  }


  /**
   * Model Clase
   */

  export type AggregateClase = {
    _count: ClaseCountAggregateOutputType | null
    _avg: ClaseAvgAggregateOutputType | null
    _sum: ClaseSumAggregateOutputType | null
    _min: ClaseMinAggregateOutputType | null
    _max: ClaseMaxAggregateOutputType | null
  }

  export type ClaseAvgAggregateOutputType = {
    id: number | null
    profesorId: number | null
    estiloId: number | null
  }

  export type ClaseSumAggregateOutputType = {
    id: number | null
    profesorId: number | null
    estiloId: number | null
  }

  export type ClaseMinAggregateOutputType = {
    id: number | null
    fecha: Date | null
    profesorId: number | null
    estiloId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClaseMaxAggregateOutputType = {
    id: number | null
    fecha: Date | null
    profesorId: number | null
    estiloId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClaseCountAggregateOutputType = {
    id: number
    fecha: number
    profesorId: number
    estiloId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClaseAvgAggregateInputType = {
    id?: true
    profesorId?: true
    estiloId?: true
  }

  export type ClaseSumAggregateInputType = {
    id?: true
    profesorId?: true
    estiloId?: true
  }

  export type ClaseMinAggregateInputType = {
    id?: true
    fecha?: true
    profesorId?: true
    estiloId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClaseMaxAggregateInputType = {
    id?: true
    fecha?: true
    profesorId?: true
    estiloId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClaseCountAggregateInputType = {
    id?: true
    fecha?: true
    profesorId?: true
    estiloId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clase to aggregate.
     */
    where?: ClaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clases to fetch.
     */
    orderBy?: ClaseOrderByWithRelationInput | ClaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clases
    **/
    _count?: true | ClaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClaseMaxAggregateInputType
  }

  export type GetClaseAggregateType<T extends ClaseAggregateArgs> = {
        [P in keyof T & keyof AggregateClase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClase[P]>
      : GetScalarType<T[P], AggregateClase[P]>
  }




  export type ClaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaseWhereInput
    orderBy?: ClaseOrderByWithAggregationInput | ClaseOrderByWithAggregationInput[]
    by: ClaseScalarFieldEnum[] | ClaseScalarFieldEnum
    having?: ClaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClaseCountAggregateInputType | true
    _avg?: ClaseAvgAggregateInputType
    _sum?: ClaseSumAggregateInputType
    _min?: ClaseMinAggregateInputType
    _max?: ClaseMaxAggregateInputType
  }

  export type ClaseGroupByOutputType = {
    id: number
    fecha: Date
    profesorId: number
    estiloId: number
    createdAt: Date
    updatedAt: Date
    _count: ClaseCountAggregateOutputType | null
    _avg: ClaseAvgAggregateOutputType | null
    _sum: ClaseSumAggregateOutputType | null
    _min: ClaseMinAggregateOutputType | null
    _max: ClaseMaxAggregateOutputType | null
  }

  type GetClaseGroupByPayload<T extends ClaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClaseGroupByOutputType[P]>
            : GetScalarType<T[P], ClaseGroupByOutputType[P]>
        }
      >
    >


  export type ClaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fecha?: boolean
    profesorId?: boolean
    estiloId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profesor?: boolean | ProfesorDefaultArgs<ExtArgs>
    estilo?: boolean | EstiloDefaultArgs<ExtArgs>
    asistencias?: boolean | Clase$asistenciasArgs<ExtArgs>
    alumnosSueltos?: boolean | Clase$alumnosSueltosArgs<ExtArgs>
    recibos?: boolean | Clase$recibosArgs<ExtArgs>
    _count?: boolean | ClaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clase"]>

  export type ClaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fecha?: boolean
    profesorId?: boolean
    estiloId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profesor?: boolean | ProfesorDefaultArgs<ExtArgs>
    estilo?: boolean | EstiloDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clase"]>

  export type ClaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fecha?: boolean
    profesorId?: boolean
    estiloId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profesor?: boolean | ProfesorDefaultArgs<ExtArgs>
    estilo?: boolean | EstiloDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clase"]>

  export type ClaseSelectScalar = {
    id?: boolean
    fecha?: boolean
    profesorId?: boolean
    estiloId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fecha" | "profesorId" | "estiloId" | "createdAt" | "updatedAt", ExtArgs["result"]["clase"]>
  export type ClaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profesor?: boolean | ProfesorDefaultArgs<ExtArgs>
    estilo?: boolean | EstiloDefaultArgs<ExtArgs>
    asistencias?: boolean | Clase$asistenciasArgs<ExtArgs>
    alumnosSueltos?: boolean | Clase$alumnosSueltosArgs<ExtArgs>
    recibos?: boolean | Clase$recibosArgs<ExtArgs>
    _count?: boolean | ClaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profesor?: boolean | ProfesorDefaultArgs<ExtArgs>
    estilo?: boolean | EstiloDefaultArgs<ExtArgs>
  }
  export type ClaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profesor?: boolean | ProfesorDefaultArgs<ExtArgs>
    estilo?: boolean | EstiloDefaultArgs<ExtArgs>
  }

  export type $ClasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Clase"
    objects: {
      profesor: Prisma.$ProfesorPayload<ExtArgs>
      estilo: Prisma.$EstiloPayload<ExtArgs>
      asistencias: Prisma.$AsistenciaPayload<ExtArgs>[]
      alumnosSueltos: Prisma.$AlumnoSueltoPayload<ExtArgs>[]
      recibos: Prisma.$ReciboPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fecha: Date
      profesorId: number
      estiloId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clase"]>
    composites: {}
  }

  type ClaseGetPayload<S extends boolean | null | undefined | ClaseDefaultArgs> = $Result.GetResult<Prisma.$ClasePayload, S>

  type ClaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClaseCountAggregateInputType | true
    }

  export interface ClaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Clase'], meta: { name: 'Clase' } }
    /**
     * Find zero or one Clase that matches the filter.
     * @param {ClaseFindUniqueArgs} args - Arguments to find a Clase
     * @example
     * // Get one Clase
     * const clase = await prisma.clase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClaseFindUniqueArgs>(args: SelectSubset<T, ClaseFindUniqueArgs<ExtArgs>>): Prisma__ClaseClient<$Result.GetResult<Prisma.$ClasePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Clase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClaseFindUniqueOrThrowArgs} args - Arguments to find a Clase
     * @example
     * // Get one Clase
     * const clase = await prisma.clase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClaseFindUniqueOrThrowArgs>(args: SelectSubset<T, ClaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClaseClient<$Result.GetResult<Prisma.$ClasePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Clase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaseFindFirstArgs} args - Arguments to find a Clase
     * @example
     * // Get one Clase
     * const clase = await prisma.clase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClaseFindFirstArgs>(args?: SelectSubset<T, ClaseFindFirstArgs<ExtArgs>>): Prisma__ClaseClient<$Result.GetResult<Prisma.$ClasePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Clase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaseFindFirstOrThrowArgs} args - Arguments to find a Clase
     * @example
     * // Get one Clase
     * const clase = await prisma.clase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClaseFindFirstOrThrowArgs>(args?: SelectSubset<T, ClaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClaseClient<$Result.GetResult<Prisma.$ClasePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Clases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clases
     * const clases = await prisma.clase.findMany()
     * 
     * // Get first 10 Clases
     * const clases = await prisma.clase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const claseWithIdOnly = await prisma.clase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClaseFindManyArgs>(args?: SelectSubset<T, ClaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClasePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Clase.
     * @param {ClaseCreateArgs} args - Arguments to create a Clase.
     * @example
     * // Create one Clase
     * const Clase = await prisma.clase.create({
     *   data: {
     *     // ... data to create a Clase
     *   }
     * })
     * 
     */
    create<T extends ClaseCreateArgs>(args: SelectSubset<T, ClaseCreateArgs<ExtArgs>>): Prisma__ClaseClient<$Result.GetResult<Prisma.$ClasePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Clases.
     * @param {ClaseCreateManyArgs} args - Arguments to create many Clases.
     * @example
     * // Create many Clases
     * const clase = await prisma.clase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClaseCreateManyArgs>(args?: SelectSubset<T, ClaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clases and returns the data saved in the database.
     * @param {ClaseCreateManyAndReturnArgs} args - Arguments to create many Clases.
     * @example
     * // Create many Clases
     * const clase = await prisma.clase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clases and only return the `id`
     * const claseWithIdOnly = await prisma.clase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClaseCreateManyAndReturnArgs>(args?: SelectSubset<T, ClaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClasePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Clase.
     * @param {ClaseDeleteArgs} args - Arguments to delete one Clase.
     * @example
     * // Delete one Clase
     * const Clase = await prisma.clase.delete({
     *   where: {
     *     // ... filter to delete one Clase
     *   }
     * })
     * 
     */
    delete<T extends ClaseDeleteArgs>(args: SelectSubset<T, ClaseDeleteArgs<ExtArgs>>): Prisma__ClaseClient<$Result.GetResult<Prisma.$ClasePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Clase.
     * @param {ClaseUpdateArgs} args - Arguments to update one Clase.
     * @example
     * // Update one Clase
     * const clase = await prisma.clase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClaseUpdateArgs>(args: SelectSubset<T, ClaseUpdateArgs<ExtArgs>>): Prisma__ClaseClient<$Result.GetResult<Prisma.$ClasePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Clases.
     * @param {ClaseDeleteManyArgs} args - Arguments to filter Clases to delete.
     * @example
     * // Delete a few Clases
     * const { count } = await prisma.clase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClaseDeleteManyArgs>(args?: SelectSubset<T, ClaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clases
     * const clase = await prisma.clase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClaseUpdateManyArgs>(args: SelectSubset<T, ClaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clases and returns the data updated in the database.
     * @param {ClaseUpdateManyAndReturnArgs} args - Arguments to update many Clases.
     * @example
     * // Update many Clases
     * const clase = await prisma.clase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clases and only return the `id`
     * const claseWithIdOnly = await prisma.clase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClaseUpdateManyAndReturnArgs>(args: SelectSubset<T, ClaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClasePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Clase.
     * @param {ClaseUpsertArgs} args - Arguments to update or create a Clase.
     * @example
     * // Update or create a Clase
     * const clase = await prisma.clase.upsert({
     *   create: {
     *     // ... data to create a Clase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clase we want to update
     *   }
     * })
     */
    upsert<T extends ClaseUpsertArgs>(args: SelectSubset<T, ClaseUpsertArgs<ExtArgs>>): Prisma__ClaseClient<$Result.GetResult<Prisma.$ClasePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Clases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaseCountArgs} args - Arguments to filter Clases to count.
     * @example
     * // Count the number of Clases
     * const count = await prisma.clase.count({
     *   where: {
     *     // ... the filter for the Clases we want to count
     *   }
     * })
    **/
    count<T extends ClaseCountArgs>(
      args?: Subset<T, ClaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClaseAggregateArgs>(args: Subset<T, ClaseAggregateArgs>): Prisma.PrismaPromise<GetClaseAggregateType<T>>

    /**
     * Group by Clase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClaseGroupByArgs['orderBy'] }
        : { orderBy?: ClaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Clase model
   */
  readonly fields: ClaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Clase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profesor<T extends ProfesorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfesorDefaultArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    estilo<T extends EstiloDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EstiloDefaultArgs<ExtArgs>>): Prisma__EstiloClient<$Result.GetResult<Prisma.$EstiloPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    asistencias<T extends Clase$asistenciasArgs<ExtArgs> = {}>(args?: Subset<T, Clase$asistenciasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AsistenciaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    alumnosSueltos<T extends Clase$alumnosSueltosArgs<ExtArgs> = {}>(args?: Subset<T, Clase$alumnosSueltosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlumnoSueltoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    recibos<T extends Clase$recibosArgs<ExtArgs> = {}>(args?: Subset<T, Clase$recibosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReciboPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Clase model
   */ 
  interface ClaseFieldRefs {
    readonly id: FieldRef<"Clase", 'Int'>
    readonly fecha: FieldRef<"Clase", 'DateTime'>
    readonly profesorId: FieldRef<"Clase", 'Int'>
    readonly estiloId: FieldRef<"Clase", 'Int'>
    readonly createdAt: FieldRef<"Clase", 'DateTime'>
    readonly updatedAt: FieldRef<"Clase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Clase findUnique
   */
  export type ClaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clase
     */
    omit?: ClaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaseInclude<ExtArgs> | null
    /**
     * Filter, which Clase to fetch.
     */
    where: ClaseWhereUniqueInput
  }

  /**
   * Clase findUniqueOrThrow
   */
  export type ClaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clase
     */
    omit?: ClaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaseInclude<ExtArgs> | null
    /**
     * Filter, which Clase to fetch.
     */
    where: ClaseWhereUniqueInput
  }

  /**
   * Clase findFirst
   */
  export type ClaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clase
     */
    omit?: ClaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaseInclude<ExtArgs> | null
    /**
     * Filter, which Clase to fetch.
     */
    where?: ClaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clases to fetch.
     */
    orderBy?: ClaseOrderByWithRelationInput | ClaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clases.
     */
    cursor?: ClaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clases.
     */
    distinct?: ClaseScalarFieldEnum | ClaseScalarFieldEnum[]
  }

  /**
   * Clase findFirstOrThrow
   */
  export type ClaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clase
     */
    omit?: ClaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaseInclude<ExtArgs> | null
    /**
     * Filter, which Clase to fetch.
     */
    where?: ClaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clases to fetch.
     */
    orderBy?: ClaseOrderByWithRelationInput | ClaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clases.
     */
    cursor?: ClaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clases.
     */
    distinct?: ClaseScalarFieldEnum | ClaseScalarFieldEnum[]
  }

  /**
   * Clase findMany
   */
  export type ClaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clase
     */
    omit?: ClaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaseInclude<ExtArgs> | null
    /**
     * Filter, which Clases to fetch.
     */
    where?: ClaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clases to fetch.
     */
    orderBy?: ClaseOrderByWithRelationInput | ClaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clases.
     */
    cursor?: ClaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clases.
     */
    skip?: number
    distinct?: ClaseScalarFieldEnum | ClaseScalarFieldEnum[]
  }

  /**
   * Clase create
   */
  export type ClaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clase
     */
    omit?: ClaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Clase.
     */
    data: XOR<ClaseCreateInput, ClaseUncheckedCreateInput>
  }

  /**
   * Clase createMany
   */
  export type ClaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clases.
     */
    data: ClaseCreateManyInput | ClaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Clase createManyAndReturn
   */
  export type ClaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Clase
     */
    omit?: ClaseOmit<ExtArgs> | null
    /**
     * The data used to create many Clases.
     */
    data: ClaseCreateManyInput | ClaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Clase update
   */
  export type ClaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clase
     */
    omit?: ClaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Clase.
     */
    data: XOR<ClaseUpdateInput, ClaseUncheckedUpdateInput>
    /**
     * Choose, which Clase to update.
     */
    where: ClaseWhereUniqueInput
  }

  /**
   * Clase updateMany
   */
  export type ClaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clases.
     */
    data: XOR<ClaseUpdateManyMutationInput, ClaseUncheckedUpdateManyInput>
    /**
     * Filter which Clases to update
     */
    where?: ClaseWhereInput
  }

  /**
   * Clase updateManyAndReturn
   */
  export type ClaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Clase
     */
    omit?: ClaseOmit<ExtArgs> | null
    /**
     * The data used to update Clases.
     */
    data: XOR<ClaseUpdateManyMutationInput, ClaseUncheckedUpdateManyInput>
    /**
     * Filter which Clases to update
     */
    where?: ClaseWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Clase upsert
   */
  export type ClaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clase
     */
    omit?: ClaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Clase to update in case it exists.
     */
    where: ClaseWhereUniqueInput
    /**
     * In case the Clase found by the `where` argument doesn't exist, create a new Clase with this data.
     */
    create: XOR<ClaseCreateInput, ClaseUncheckedCreateInput>
    /**
     * In case the Clase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClaseUpdateInput, ClaseUncheckedUpdateInput>
  }

  /**
   * Clase delete
   */
  export type ClaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clase
     */
    omit?: ClaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaseInclude<ExtArgs> | null
    /**
     * Filter which Clase to delete.
     */
    where: ClaseWhereUniqueInput
  }

  /**
   * Clase deleteMany
   */
  export type ClaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clases to delete
     */
    where?: ClaseWhereInput
  }

  /**
   * Clase.asistencias
   */
  export type Clase$asistenciasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asistencia
     */
    select?: AsistenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asistencia
     */
    omit?: AsistenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsistenciaInclude<ExtArgs> | null
    where?: AsistenciaWhereInput
    orderBy?: AsistenciaOrderByWithRelationInput | AsistenciaOrderByWithRelationInput[]
    cursor?: AsistenciaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AsistenciaScalarFieldEnum | AsistenciaScalarFieldEnum[]
  }

  /**
   * Clase.alumnosSueltos
   */
  export type Clase$alumnosSueltosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoSuelto
     */
    select?: AlumnoSueltoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoSuelto
     */
    omit?: AlumnoSueltoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoSueltoInclude<ExtArgs> | null
    where?: AlumnoSueltoWhereInput
    orderBy?: AlumnoSueltoOrderByWithRelationInput | AlumnoSueltoOrderByWithRelationInput[]
    cursor?: AlumnoSueltoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlumnoSueltoScalarFieldEnum | AlumnoSueltoScalarFieldEnum[]
  }

  /**
   * Clase.recibos
   */
  export type Clase$recibosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recibo
     */
    select?: ReciboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recibo
     */
    omit?: ReciboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReciboInclude<ExtArgs> | null
    where?: ReciboWhereInput
    orderBy?: ReciboOrderByWithRelationInput | ReciboOrderByWithRelationInput[]
    cursor?: ReciboWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReciboScalarFieldEnum | ReciboScalarFieldEnum[]
  }

  /**
   * Clase without action
   */
  export type ClaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clase
     */
    omit?: ClaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaseInclude<ExtArgs> | null
  }


  /**
   * Model Asistencia
   */

  export type AggregateAsistencia = {
    _count: AsistenciaCountAggregateOutputType | null
    _avg: AsistenciaAvgAggregateOutputType | null
    _sum: AsistenciaSumAggregateOutputType | null
    _min: AsistenciaMinAggregateOutputType | null
    _max: AsistenciaMaxAggregateOutputType | null
  }

  export type AsistenciaAvgAggregateOutputType = {
    id: number | null
    claseId: number | null
    alumnoId: number | null
  }

  export type AsistenciaSumAggregateOutputType = {
    id: number | null
    claseId: number | null
    alumnoId: number | null
  }

  export type AsistenciaMinAggregateOutputType = {
    id: number | null
    claseId: number | null
    alumnoId: number | null
    asistio: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AsistenciaMaxAggregateOutputType = {
    id: number | null
    claseId: number | null
    alumnoId: number | null
    asistio: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AsistenciaCountAggregateOutputType = {
    id: number
    claseId: number
    alumnoId: number
    asistio: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AsistenciaAvgAggregateInputType = {
    id?: true
    claseId?: true
    alumnoId?: true
  }

  export type AsistenciaSumAggregateInputType = {
    id?: true
    claseId?: true
    alumnoId?: true
  }

  export type AsistenciaMinAggregateInputType = {
    id?: true
    claseId?: true
    alumnoId?: true
    asistio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AsistenciaMaxAggregateInputType = {
    id?: true
    claseId?: true
    alumnoId?: true
    asistio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AsistenciaCountAggregateInputType = {
    id?: true
    claseId?: true
    alumnoId?: true
    asistio?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AsistenciaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Asistencia to aggregate.
     */
    where?: AsistenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Asistencias to fetch.
     */
    orderBy?: AsistenciaOrderByWithRelationInput | AsistenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AsistenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Asistencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Asistencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Asistencias
    **/
    _count?: true | AsistenciaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AsistenciaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AsistenciaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AsistenciaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AsistenciaMaxAggregateInputType
  }

  export type GetAsistenciaAggregateType<T extends AsistenciaAggregateArgs> = {
        [P in keyof T & keyof AggregateAsistencia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAsistencia[P]>
      : GetScalarType<T[P], AggregateAsistencia[P]>
  }




  export type AsistenciaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AsistenciaWhereInput
    orderBy?: AsistenciaOrderByWithAggregationInput | AsistenciaOrderByWithAggregationInput[]
    by: AsistenciaScalarFieldEnum[] | AsistenciaScalarFieldEnum
    having?: AsistenciaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AsistenciaCountAggregateInputType | true
    _avg?: AsistenciaAvgAggregateInputType
    _sum?: AsistenciaSumAggregateInputType
    _min?: AsistenciaMinAggregateInputType
    _max?: AsistenciaMaxAggregateInputType
  }

  export type AsistenciaGroupByOutputType = {
    id: number
    claseId: number
    alumnoId: number
    asistio: boolean
    createdAt: Date
    updatedAt: Date
    _count: AsistenciaCountAggregateOutputType | null
    _avg: AsistenciaAvgAggregateOutputType | null
    _sum: AsistenciaSumAggregateOutputType | null
    _min: AsistenciaMinAggregateOutputType | null
    _max: AsistenciaMaxAggregateOutputType | null
  }

  type GetAsistenciaGroupByPayload<T extends AsistenciaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AsistenciaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AsistenciaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AsistenciaGroupByOutputType[P]>
            : GetScalarType<T[P], AsistenciaGroupByOutputType[P]>
        }
      >
    >


  export type AsistenciaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claseId?: boolean
    alumnoId?: boolean
    asistio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clase?: boolean | ClaseDefaultArgs<ExtArgs>
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asistencia"]>

  export type AsistenciaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claseId?: boolean
    alumnoId?: boolean
    asistio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clase?: boolean | ClaseDefaultArgs<ExtArgs>
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asistencia"]>

  export type AsistenciaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claseId?: boolean
    alumnoId?: boolean
    asistio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clase?: boolean | ClaseDefaultArgs<ExtArgs>
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asistencia"]>

  export type AsistenciaSelectScalar = {
    id?: boolean
    claseId?: boolean
    alumnoId?: boolean
    asistio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AsistenciaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "claseId" | "alumnoId" | "asistio" | "createdAt" | "updatedAt", ExtArgs["result"]["asistencia"]>
  export type AsistenciaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clase?: boolean | ClaseDefaultArgs<ExtArgs>
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
  }
  export type AsistenciaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clase?: boolean | ClaseDefaultArgs<ExtArgs>
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
  }
  export type AsistenciaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clase?: boolean | ClaseDefaultArgs<ExtArgs>
    alumno?: boolean | AlumnoDefaultArgs<ExtArgs>
  }

  export type $AsistenciaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Asistencia"
    objects: {
      clase: Prisma.$ClasePayload<ExtArgs>
      alumno: Prisma.$AlumnoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      claseId: number
      alumnoId: number
      asistio: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["asistencia"]>
    composites: {}
  }

  type AsistenciaGetPayload<S extends boolean | null | undefined | AsistenciaDefaultArgs> = $Result.GetResult<Prisma.$AsistenciaPayload, S>

  type AsistenciaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AsistenciaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AsistenciaCountAggregateInputType | true
    }

  export interface AsistenciaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Asistencia'], meta: { name: 'Asistencia' } }
    /**
     * Find zero or one Asistencia that matches the filter.
     * @param {AsistenciaFindUniqueArgs} args - Arguments to find a Asistencia
     * @example
     * // Get one Asistencia
     * const asistencia = await prisma.asistencia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AsistenciaFindUniqueArgs>(args: SelectSubset<T, AsistenciaFindUniqueArgs<ExtArgs>>): Prisma__AsistenciaClient<$Result.GetResult<Prisma.$AsistenciaPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Asistencia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AsistenciaFindUniqueOrThrowArgs} args - Arguments to find a Asistencia
     * @example
     * // Get one Asistencia
     * const asistencia = await prisma.asistencia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AsistenciaFindUniqueOrThrowArgs>(args: SelectSubset<T, AsistenciaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AsistenciaClient<$Result.GetResult<Prisma.$AsistenciaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Asistencia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsistenciaFindFirstArgs} args - Arguments to find a Asistencia
     * @example
     * // Get one Asistencia
     * const asistencia = await prisma.asistencia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AsistenciaFindFirstArgs>(args?: SelectSubset<T, AsistenciaFindFirstArgs<ExtArgs>>): Prisma__AsistenciaClient<$Result.GetResult<Prisma.$AsistenciaPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Asistencia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsistenciaFindFirstOrThrowArgs} args - Arguments to find a Asistencia
     * @example
     * // Get one Asistencia
     * const asistencia = await prisma.asistencia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AsistenciaFindFirstOrThrowArgs>(args?: SelectSubset<T, AsistenciaFindFirstOrThrowArgs<ExtArgs>>): Prisma__AsistenciaClient<$Result.GetResult<Prisma.$AsistenciaPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Asistencias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsistenciaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Asistencias
     * const asistencias = await prisma.asistencia.findMany()
     * 
     * // Get first 10 Asistencias
     * const asistencias = await prisma.asistencia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const asistenciaWithIdOnly = await prisma.asistencia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AsistenciaFindManyArgs>(args?: SelectSubset<T, AsistenciaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AsistenciaPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Asistencia.
     * @param {AsistenciaCreateArgs} args - Arguments to create a Asistencia.
     * @example
     * // Create one Asistencia
     * const Asistencia = await prisma.asistencia.create({
     *   data: {
     *     // ... data to create a Asistencia
     *   }
     * })
     * 
     */
    create<T extends AsistenciaCreateArgs>(args: SelectSubset<T, AsistenciaCreateArgs<ExtArgs>>): Prisma__AsistenciaClient<$Result.GetResult<Prisma.$AsistenciaPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Asistencias.
     * @param {AsistenciaCreateManyArgs} args - Arguments to create many Asistencias.
     * @example
     * // Create many Asistencias
     * const asistencia = await prisma.asistencia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AsistenciaCreateManyArgs>(args?: SelectSubset<T, AsistenciaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Asistencias and returns the data saved in the database.
     * @param {AsistenciaCreateManyAndReturnArgs} args - Arguments to create many Asistencias.
     * @example
     * // Create many Asistencias
     * const asistencia = await prisma.asistencia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Asistencias and only return the `id`
     * const asistenciaWithIdOnly = await prisma.asistencia.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AsistenciaCreateManyAndReturnArgs>(args?: SelectSubset<T, AsistenciaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AsistenciaPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Asistencia.
     * @param {AsistenciaDeleteArgs} args - Arguments to delete one Asistencia.
     * @example
     * // Delete one Asistencia
     * const Asistencia = await prisma.asistencia.delete({
     *   where: {
     *     // ... filter to delete one Asistencia
     *   }
     * })
     * 
     */
    delete<T extends AsistenciaDeleteArgs>(args: SelectSubset<T, AsistenciaDeleteArgs<ExtArgs>>): Prisma__AsistenciaClient<$Result.GetResult<Prisma.$AsistenciaPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Asistencia.
     * @param {AsistenciaUpdateArgs} args - Arguments to update one Asistencia.
     * @example
     * // Update one Asistencia
     * const asistencia = await prisma.asistencia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AsistenciaUpdateArgs>(args: SelectSubset<T, AsistenciaUpdateArgs<ExtArgs>>): Prisma__AsistenciaClient<$Result.GetResult<Prisma.$AsistenciaPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Asistencias.
     * @param {AsistenciaDeleteManyArgs} args - Arguments to filter Asistencias to delete.
     * @example
     * // Delete a few Asistencias
     * const { count } = await prisma.asistencia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AsistenciaDeleteManyArgs>(args?: SelectSubset<T, AsistenciaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Asistencias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsistenciaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Asistencias
     * const asistencia = await prisma.asistencia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AsistenciaUpdateManyArgs>(args: SelectSubset<T, AsistenciaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Asistencias and returns the data updated in the database.
     * @param {AsistenciaUpdateManyAndReturnArgs} args - Arguments to update many Asistencias.
     * @example
     * // Update many Asistencias
     * const asistencia = await prisma.asistencia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Asistencias and only return the `id`
     * const asistenciaWithIdOnly = await prisma.asistencia.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AsistenciaUpdateManyAndReturnArgs>(args: SelectSubset<T, AsistenciaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AsistenciaPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Asistencia.
     * @param {AsistenciaUpsertArgs} args - Arguments to update or create a Asistencia.
     * @example
     * // Update or create a Asistencia
     * const asistencia = await prisma.asistencia.upsert({
     *   create: {
     *     // ... data to create a Asistencia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Asistencia we want to update
     *   }
     * })
     */
    upsert<T extends AsistenciaUpsertArgs>(args: SelectSubset<T, AsistenciaUpsertArgs<ExtArgs>>): Prisma__AsistenciaClient<$Result.GetResult<Prisma.$AsistenciaPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Asistencias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsistenciaCountArgs} args - Arguments to filter Asistencias to count.
     * @example
     * // Count the number of Asistencias
     * const count = await prisma.asistencia.count({
     *   where: {
     *     // ... the filter for the Asistencias we want to count
     *   }
     * })
    **/
    count<T extends AsistenciaCountArgs>(
      args?: Subset<T, AsistenciaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AsistenciaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Asistencia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsistenciaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AsistenciaAggregateArgs>(args: Subset<T, AsistenciaAggregateArgs>): Prisma.PrismaPromise<GetAsistenciaAggregateType<T>>

    /**
     * Group by Asistencia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsistenciaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AsistenciaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AsistenciaGroupByArgs['orderBy'] }
        : { orderBy?: AsistenciaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AsistenciaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAsistenciaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Asistencia model
   */
  readonly fields: AsistenciaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Asistencia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AsistenciaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clase<T extends ClaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClaseDefaultArgs<ExtArgs>>): Prisma__ClaseClient<$Result.GetResult<Prisma.$ClasePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    alumno<T extends AlumnoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlumnoDefaultArgs<ExtArgs>>): Prisma__AlumnoClient<$Result.GetResult<Prisma.$AlumnoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Asistencia model
   */ 
  interface AsistenciaFieldRefs {
    readonly id: FieldRef<"Asistencia", 'Int'>
    readonly claseId: FieldRef<"Asistencia", 'Int'>
    readonly alumnoId: FieldRef<"Asistencia", 'Int'>
    readonly asistio: FieldRef<"Asistencia", 'Boolean'>
    readonly createdAt: FieldRef<"Asistencia", 'DateTime'>
    readonly updatedAt: FieldRef<"Asistencia", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Asistencia findUnique
   */
  export type AsistenciaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asistencia
     */
    select?: AsistenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asistencia
     */
    omit?: AsistenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsistenciaInclude<ExtArgs> | null
    /**
     * Filter, which Asistencia to fetch.
     */
    where: AsistenciaWhereUniqueInput
  }

  /**
   * Asistencia findUniqueOrThrow
   */
  export type AsistenciaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asistencia
     */
    select?: AsistenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asistencia
     */
    omit?: AsistenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsistenciaInclude<ExtArgs> | null
    /**
     * Filter, which Asistencia to fetch.
     */
    where: AsistenciaWhereUniqueInput
  }

  /**
   * Asistencia findFirst
   */
  export type AsistenciaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asistencia
     */
    select?: AsistenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asistencia
     */
    omit?: AsistenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsistenciaInclude<ExtArgs> | null
    /**
     * Filter, which Asistencia to fetch.
     */
    where?: AsistenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Asistencias to fetch.
     */
    orderBy?: AsistenciaOrderByWithRelationInput | AsistenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Asistencias.
     */
    cursor?: AsistenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Asistencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Asistencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Asistencias.
     */
    distinct?: AsistenciaScalarFieldEnum | AsistenciaScalarFieldEnum[]
  }

  /**
   * Asistencia findFirstOrThrow
   */
  export type AsistenciaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asistencia
     */
    select?: AsistenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asistencia
     */
    omit?: AsistenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsistenciaInclude<ExtArgs> | null
    /**
     * Filter, which Asistencia to fetch.
     */
    where?: AsistenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Asistencias to fetch.
     */
    orderBy?: AsistenciaOrderByWithRelationInput | AsistenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Asistencias.
     */
    cursor?: AsistenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Asistencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Asistencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Asistencias.
     */
    distinct?: AsistenciaScalarFieldEnum | AsistenciaScalarFieldEnum[]
  }

  /**
   * Asistencia findMany
   */
  export type AsistenciaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asistencia
     */
    select?: AsistenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asistencia
     */
    omit?: AsistenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsistenciaInclude<ExtArgs> | null
    /**
     * Filter, which Asistencias to fetch.
     */
    where?: AsistenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Asistencias to fetch.
     */
    orderBy?: AsistenciaOrderByWithRelationInput | AsistenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Asistencias.
     */
    cursor?: AsistenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Asistencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Asistencias.
     */
    skip?: number
    distinct?: AsistenciaScalarFieldEnum | AsistenciaScalarFieldEnum[]
  }

  /**
   * Asistencia create
   */
  export type AsistenciaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asistencia
     */
    select?: AsistenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asistencia
     */
    omit?: AsistenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsistenciaInclude<ExtArgs> | null
    /**
     * The data needed to create a Asistencia.
     */
    data: XOR<AsistenciaCreateInput, AsistenciaUncheckedCreateInput>
  }

  /**
   * Asistencia createMany
   */
  export type AsistenciaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Asistencias.
     */
    data: AsistenciaCreateManyInput | AsistenciaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Asistencia createManyAndReturn
   */
  export type AsistenciaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asistencia
     */
    select?: AsistenciaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Asistencia
     */
    omit?: AsistenciaOmit<ExtArgs> | null
    /**
     * The data used to create many Asistencias.
     */
    data: AsistenciaCreateManyInput | AsistenciaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsistenciaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Asistencia update
   */
  export type AsistenciaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asistencia
     */
    select?: AsistenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asistencia
     */
    omit?: AsistenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsistenciaInclude<ExtArgs> | null
    /**
     * The data needed to update a Asistencia.
     */
    data: XOR<AsistenciaUpdateInput, AsistenciaUncheckedUpdateInput>
    /**
     * Choose, which Asistencia to update.
     */
    where: AsistenciaWhereUniqueInput
  }

  /**
   * Asistencia updateMany
   */
  export type AsistenciaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Asistencias.
     */
    data: XOR<AsistenciaUpdateManyMutationInput, AsistenciaUncheckedUpdateManyInput>
    /**
     * Filter which Asistencias to update
     */
    where?: AsistenciaWhereInput
  }

  /**
   * Asistencia updateManyAndReturn
   */
  export type AsistenciaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asistencia
     */
    select?: AsistenciaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Asistencia
     */
    omit?: AsistenciaOmit<ExtArgs> | null
    /**
     * The data used to update Asistencias.
     */
    data: XOR<AsistenciaUpdateManyMutationInput, AsistenciaUncheckedUpdateManyInput>
    /**
     * Filter which Asistencias to update
     */
    where?: AsistenciaWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsistenciaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Asistencia upsert
   */
  export type AsistenciaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asistencia
     */
    select?: AsistenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asistencia
     */
    omit?: AsistenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsistenciaInclude<ExtArgs> | null
    /**
     * The filter to search for the Asistencia to update in case it exists.
     */
    where: AsistenciaWhereUniqueInput
    /**
     * In case the Asistencia found by the `where` argument doesn't exist, create a new Asistencia with this data.
     */
    create: XOR<AsistenciaCreateInput, AsistenciaUncheckedCreateInput>
    /**
     * In case the Asistencia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AsistenciaUpdateInput, AsistenciaUncheckedUpdateInput>
  }

  /**
   * Asistencia delete
   */
  export type AsistenciaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asistencia
     */
    select?: AsistenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asistencia
     */
    omit?: AsistenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsistenciaInclude<ExtArgs> | null
    /**
     * Filter which Asistencia to delete.
     */
    where: AsistenciaWhereUniqueInput
  }

  /**
   * Asistencia deleteMany
   */
  export type AsistenciaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Asistencias to delete
     */
    where?: AsistenciaWhereInput
  }

  /**
   * Asistencia without action
   */
  export type AsistenciaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asistencia
     */
    select?: AsistenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asistencia
     */
    omit?: AsistenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsistenciaInclude<ExtArgs> | null
  }


  /**
   * Model AlumnoSuelto
   */

  export type AggregateAlumnoSuelto = {
    _count: AlumnoSueltoCountAggregateOutputType | null
    _avg: AlumnoSueltoAvgAggregateOutputType | null
    _sum: AlumnoSueltoSumAggregateOutputType | null
    _min: AlumnoSueltoMinAggregateOutputType | null
    _max: AlumnoSueltoMaxAggregateOutputType | null
  }

  export type AlumnoSueltoAvgAggregateOutputType = {
    id: number | null
    alumnoRegularId: number | null
  }

  export type AlumnoSueltoSumAggregateOutputType = {
    id: number | null
    alumnoRegularId: number | null
  }

  export type AlumnoSueltoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellido: string | null
    dni: string | null
    telefono: string | null
    email: string | null
    alumnoRegularId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlumnoSueltoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellido: string | null
    dni: string | null
    telefono: string | null
    email: string | null
    alumnoRegularId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlumnoSueltoCountAggregateOutputType = {
    id: number
    nombre: number
    apellido: number
    dni: number
    telefono: number
    email: number
    alumnoRegularId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AlumnoSueltoAvgAggregateInputType = {
    id?: true
    alumnoRegularId?: true
  }

  export type AlumnoSueltoSumAggregateInputType = {
    id?: true
    alumnoRegularId?: true
  }

  export type AlumnoSueltoMinAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    dni?: true
    telefono?: true
    email?: true
    alumnoRegularId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlumnoSueltoMaxAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    dni?: true
    telefono?: true
    email?: true
    alumnoRegularId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlumnoSueltoCountAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    dni?: true
    telefono?: true
    email?: true
    alumnoRegularId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AlumnoSueltoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlumnoSuelto to aggregate.
     */
    where?: AlumnoSueltoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlumnoSueltos to fetch.
     */
    orderBy?: AlumnoSueltoOrderByWithRelationInput | AlumnoSueltoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlumnoSueltoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlumnoSueltos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlumnoSueltos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AlumnoSueltos
    **/
    _count?: true | AlumnoSueltoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlumnoSueltoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlumnoSueltoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlumnoSueltoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlumnoSueltoMaxAggregateInputType
  }

  export type GetAlumnoSueltoAggregateType<T extends AlumnoSueltoAggregateArgs> = {
        [P in keyof T & keyof AggregateAlumnoSuelto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlumnoSuelto[P]>
      : GetScalarType<T[P], AggregateAlumnoSuelto[P]>
  }




  export type AlumnoSueltoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlumnoSueltoWhereInput
    orderBy?: AlumnoSueltoOrderByWithAggregationInput | AlumnoSueltoOrderByWithAggregationInput[]
    by: AlumnoSueltoScalarFieldEnum[] | AlumnoSueltoScalarFieldEnum
    having?: AlumnoSueltoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlumnoSueltoCountAggregateInputType | true
    _avg?: AlumnoSueltoAvgAggregateInputType
    _sum?: AlumnoSueltoSumAggregateInputType
    _min?: AlumnoSueltoMinAggregateInputType
    _max?: AlumnoSueltoMaxAggregateInputType
  }

  export type AlumnoSueltoGroupByOutputType = {
    id: number
    nombre: string
    apellido: string
    dni: string
    telefono: string | null
    email: string | null
    alumnoRegularId: number | null
    createdAt: Date
    updatedAt: Date
    _count: AlumnoSueltoCountAggregateOutputType | null
    _avg: AlumnoSueltoAvgAggregateOutputType | null
    _sum: AlumnoSueltoSumAggregateOutputType | null
    _min: AlumnoSueltoMinAggregateOutputType | null
    _max: AlumnoSueltoMaxAggregateOutputType | null
  }

  type GetAlumnoSueltoGroupByPayload<T extends AlumnoSueltoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlumnoSueltoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlumnoSueltoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlumnoSueltoGroupByOutputType[P]>
            : GetScalarType<T[P], AlumnoSueltoGroupByOutputType[P]>
        }
      >
    >


  export type AlumnoSueltoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    dni?: boolean
    telefono?: boolean
    email?: boolean
    alumnoRegularId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    recibos?: boolean | AlumnoSuelto$recibosArgs<ExtArgs>
    clases?: boolean | AlumnoSuelto$clasesArgs<ExtArgs>
    alumnoRegular?: boolean | AlumnoSuelto$alumnoRegularArgs<ExtArgs>
    _count?: boolean | AlumnoSueltoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alumnoSuelto"]>

  export type AlumnoSueltoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    dni?: boolean
    telefono?: boolean
    email?: boolean
    alumnoRegularId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    alumnoRegular?: boolean | AlumnoSuelto$alumnoRegularArgs<ExtArgs>
  }, ExtArgs["result"]["alumnoSuelto"]>

  export type AlumnoSueltoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    dni?: boolean
    telefono?: boolean
    email?: boolean
    alumnoRegularId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    alumnoRegular?: boolean | AlumnoSuelto$alumnoRegularArgs<ExtArgs>
  }, ExtArgs["result"]["alumnoSuelto"]>

  export type AlumnoSueltoSelectScalar = {
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    dni?: boolean
    telefono?: boolean
    email?: boolean
    alumnoRegularId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AlumnoSueltoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "apellido" | "dni" | "telefono" | "email" | "alumnoRegularId" | "createdAt" | "updatedAt", ExtArgs["result"]["alumnoSuelto"]>
  export type AlumnoSueltoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recibos?: boolean | AlumnoSuelto$recibosArgs<ExtArgs>
    clases?: boolean | AlumnoSuelto$clasesArgs<ExtArgs>
    alumnoRegular?: boolean | AlumnoSuelto$alumnoRegularArgs<ExtArgs>
    _count?: boolean | AlumnoSueltoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AlumnoSueltoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alumnoRegular?: boolean | AlumnoSuelto$alumnoRegularArgs<ExtArgs>
  }
  export type AlumnoSueltoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alumnoRegular?: boolean | AlumnoSuelto$alumnoRegularArgs<ExtArgs>
  }

  export type $AlumnoSueltoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AlumnoSuelto"
    objects: {
      recibos: Prisma.$ReciboPayload<ExtArgs>[]
      clases: Prisma.$ClasePayload<ExtArgs>[]
      alumnoRegular: Prisma.$AlumnoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      apellido: string
      dni: string
      telefono: string | null
      email: string | null
      alumnoRegularId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["alumnoSuelto"]>
    composites: {}
  }

  type AlumnoSueltoGetPayload<S extends boolean | null | undefined | AlumnoSueltoDefaultArgs> = $Result.GetResult<Prisma.$AlumnoSueltoPayload, S>

  type AlumnoSueltoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlumnoSueltoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlumnoSueltoCountAggregateInputType | true
    }

  export interface AlumnoSueltoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AlumnoSuelto'], meta: { name: 'AlumnoSuelto' } }
    /**
     * Find zero or one AlumnoSuelto that matches the filter.
     * @param {AlumnoSueltoFindUniqueArgs} args - Arguments to find a AlumnoSuelto
     * @example
     * // Get one AlumnoSuelto
     * const alumnoSuelto = await prisma.alumnoSuelto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlumnoSueltoFindUniqueArgs>(args: SelectSubset<T, AlumnoSueltoFindUniqueArgs<ExtArgs>>): Prisma__AlumnoSueltoClient<$Result.GetResult<Prisma.$AlumnoSueltoPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AlumnoSuelto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlumnoSueltoFindUniqueOrThrowArgs} args - Arguments to find a AlumnoSuelto
     * @example
     * // Get one AlumnoSuelto
     * const alumnoSuelto = await prisma.alumnoSuelto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlumnoSueltoFindUniqueOrThrowArgs>(args: SelectSubset<T, AlumnoSueltoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlumnoSueltoClient<$Result.GetResult<Prisma.$AlumnoSueltoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AlumnoSuelto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoSueltoFindFirstArgs} args - Arguments to find a AlumnoSuelto
     * @example
     * // Get one AlumnoSuelto
     * const alumnoSuelto = await prisma.alumnoSuelto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlumnoSueltoFindFirstArgs>(args?: SelectSubset<T, AlumnoSueltoFindFirstArgs<ExtArgs>>): Prisma__AlumnoSueltoClient<$Result.GetResult<Prisma.$AlumnoSueltoPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AlumnoSuelto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoSueltoFindFirstOrThrowArgs} args - Arguments to find a AlumnoSuelto
     * @example
     * // Get one AlumnoSuelto
     * const alumnoSuelto = await prisma.alumnoSuelto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlumnoSueltoFindFirstOrThrowArgs>(args?: SelectSubset<T, AlumnoSueltoFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlumnoSueltoClient<$Result.GetResult<Prisma.$AlumnoSueltoPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AlumnoSueltos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoSueltoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AlumnoSueltos
     * const alumnoSueltos = await prisma.alumnoSuelto.findMany()
     * 
     * // Get first 10 AlumnoSueltos
     * const alumnoSueltos = await prisma.alumnoSuelto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alumnoSueltoWithIdOnly = await prisma.alumnoSuelto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlumnoSueltoFindManyArgs>(args?: SelectSubset<T, AlumnoSueltoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlumnoSueltoPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AlumnoSuelto.
     * @param {AlumnoSueltoCreateArgs} args - Arguments to create a AlumnoSuelto.
     * @example
     * // Create one AlumnoSuelto
     * const AlumnoSuelto = await prisma.alumnoSuelto.create({
     *   data: {
     *     // ... data to create a AlumnoSuelto
     *   }
     * })
     * 
     */
    create<T extends AlumnoSueltoCreateArgs>(args: SelectSubset<T, AlumnoSueltoCreateArgs<ExtArgs>>): Prisma__AlumnoSueltoClient<$Result.GetResult<Prisma.$AlumnoSueltoPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AlumnoSueltos.
     * @param {AlumnoSueltoCreateManyArgs} args - Arguments to create many AlumnoSueltos.
     * @example
     * // Create many AlumnoSueltos
     * const alumnoSuelto = await prisma.alumnoSuelto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlumnoSueltoCreateManyArgs>(args?: SelectSubset<T, AlumnoSueltoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AlumnoSueltos and returns the data saved in the database.
     * @param {AlumnoSueltoCreateManyAndReturnArgs} args - Arguments to create many AlumnoSueltos.
     * @example
     * // Create many AlumnoSueltos
     * const alumnoSuelto = await prisma.alumnoSuelto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AlumnoSueltos and only return the `id`
     * const alumnoSueltoWithIdOnly = await prisma.alumnoSuelto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlumnoSueltoCreateManyAndReturnArgs>(args?: SelectSubset<T, AlumnoSueltoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlumnoSueltoPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AlumnoSuelto.
     * @param {AlumnoSueltoDeleteArgs} args - Arguments to delete one AlumnoSuelto.
     * @example
     * // Delete one AlumnoSuelto
     * const AlumnoSuelto = await prisma.alumnoSuelto.delete({
     *   where: {
     *     // ... filter to delete one AlumnoSuelto
     *   }
     * })
     * 
     */
    delete<T extends AlumnoSueltoDeleteArgs>(args: SelectSubset<T, AlumnoSueltoDeleteArgs<ExtArgs>>): Prisma__AlumnoSueltoClient<$Result.GetResult<Prisma.$AlumnoSueltoPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AlumnoSuelto.
     * @param {AlumnoSueltoUpdateArgs} args - Arguments to update one AlumnoSuelto.
     * @example
     * // Update one AlumnoSuelto
     * const alumnoSuelto = await prisma.alumnoSuelto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlumnoSueltoUpdateArgs>(args: SelectSubset<T, AlumnoSueltoUpdateArgs<ExtArgs>>): Prisma__AlumnoSueltoClient<$Result.GetResult<Prisma.$AlumnoSueltoPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AlumnoSueltos.
     * @param {AlumnoSueltoDeleteManyArgs} args - Arguments to filter AlumnoSueltos to delete.
     * @example
     * // Delete a few AlumnoSueltos
     * const { count } = await prisma.alumnoSuelto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlumnoSueltoDeleteManyArgs>(args?: SelectSubset<T, AlumnoSueltoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlumnoSueltos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoSueltoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AlumnoSueltos
     * const alumnoSuelto = await prisma.alumnoSuelto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlumnoSueltoUpdateManyArgs>(args: SelectSubset<T, AlumnoSueltoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlumnoSueltos and returns the data updated in the database.
     * @param {AlumnoSueltoUpdateManyAndReturnArgs} args - Arguments to update many AlumnoSueltos.
     * @example
     * // Update many AlumnoSueltos
     * const alumnoSuelto = await prisma.alumnoSuelto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AlumnoSueltos and only return the `id`
     * const alumnoSueltoWithIdOnly = await prisma.alumnoSuelto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlumnoSueltoUpdateManyAndReturnArgs>(args: SelectSubset<T, AlumnoSueltoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlumnoSueltoPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AlumnoSuelto.
     * @param {AlumnoSueltoUpsertArgs} args - Arguments to update or create a AlumnoSuelto.
     * @example
     * // Update or create a AlumnoSuelto
     * const alumnoSuelto = await prisma.alumnoSuelto.upsert({
     *   create: {
     *     // ... data to create a AlumnoSuelto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AlumnoSuelto we want to update
     *   }
     * })
     */
    upsert<T extends AlumnoSueltoUpsertArgs>(args: SelectSubset<T, AlumnoSueltoUpsertArgs<ExtArgs>>): Prisma__AlumnoSueltoClient<$Result.GetResult<Prisma.$AlumnoSueltoPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AlumnoSueltos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoSueltoCountArgs} args - Arguments to filter AlumnoSueltos to count.
     * @example
     * // Count the number of AlumnoSueltos
     * const count = await prisma.alumnoSuelto.count({
     *   where: {
     *     // ... the filter for the AlumnoSueltos we want to count
     *   }
     * })
    **/
    count<T extends AlumnoSueltoCountArgs>(
      args?: Subset<T, AlumnoSueltoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlumnoSueltoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AlumnoSuelto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoSueltoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlumnoSueltoAggregateArgs>(args: Subset<T, AlumnoSueltoAggregateArgs>): Prisma.PrismaPromise<GetAlumnoSueltoAggregateType<T>>

    /**
     * Group by AlumnoSuelto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoSueltoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlumnoSueltoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlumnoSueltoGroupByArgs['orderBy'] }
        : { orderBy?: AlumnoSueltoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlumnoSueltoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlumnoSueltoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AlumnoSuelto model
   */
  readonly fields: AlumnoSueltoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AlumnoSuelto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlumnoSueltoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recibos<T extends AlumnoSuelto$recibosArgs<ExtArgs> = {}>(args?: Subset<T, AlumnoSuelto$recibosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReciboPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    clases<T extends AlumnoSuelto$clasesArgs<ExtArgs> = {}>(args?: Subset<T, AlumnoSuelto$clasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClasePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    alumnoRegular<T extends AlumnoSuelto$alumnoRegularArgs<ExtArgs> = {}>(args?: Subset<T, AlumnoSuelto$alumnoRegularArgs<ExtArgs>>): Prisma__AlumnoClient<$Result.GetResult<Prisma.$AlumnoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AlumnoSuelto model
   */ 
  interface AlumnoSueltoFieldRefs {
    readonly id: FieldRef<"AlumnoSuelto", 'Int'>
    readonly nombre: FieldRef<"AlumnoSuelto", 'String'>
    readonly apellido: FieldRef<"AlumnoSuelto", 'String'>
    readonly dni: FieldRef<"AlumnoSuelto", 'String'>
    readonly telefono: FieldRef<"AlumnoSuelto", 'String'>
    readonly email: FieldRef<"AlumnoSuelto", 'String'>
    readonly alumnoRegularId: FieldRef<"AlumnoSuelto", 'Int'>
    readonly createdAt: FieldRef<"AlumnoSuelto", 'DateTime'>
    readonly updatedAt: FieldRef<"AlumnoSuelto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AlumnoSuelto findUnique
   */
  export type AlumnoSueltoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoSuelto
     */
    select?: AlumnoSueltoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoSuelto
     */
    omit?: AlumnoSueltoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoSueltoInclude<ExtArgs> | null
    /**
     * Filter, which AlumnoSuelto to fetch.
     */
    where: AlumnoSueltoWhereUniqueInput
  }

  /**
   * AlumnoSuelto findUniqueOrThrow
   */
  export type AlumnoSueltoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoSuelto
     */
    select?: AlumnoSueltoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoSuelto
     */
    omit?: AlumnoSueltoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoSueltoInclude<ExtArgs> | null
    /**
     * Filter, which AlumnoSuelto to fetch.
     */
    where: AlumnoSueltoWhereUniqueInput
  }

  /**
   * AlumnoSuelto findFirst
   */
  export type AlumnoSueltoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoSuelto
     */
    select?: AlumnoSueltoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoSuelto
     */
    omit?: AlumnoSueltoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoSueltoInclude<ExtArgs> | null
    /**
     * Filter, which AlumnoSuelto to fetch.
     */
    where?: AlumnoSueltoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlumnoSueltos to fetch.
     */
    orderBy?: AlumnoSueltoOrderByWithRelationInput | AlumnoSueltoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlumnoSueltos.
     */
    cursor?: AlumnoSueltoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlumnoSueltos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlumnoSueltos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlumnoSueltos.
     */
    distinct?: AlumnoSueltoScalarFieldEnum | AlumnoSueltoScalarFieldEnum[]
  }

  /**
   * AlumnoSuelto findFirstOrThrow
   */
  export type AlumnoSueltoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoSuelto
     */
    select?: AlumnoSueltoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoSuelto
     */
    omit?: AlumnoSueltoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoSueltoInclude<ExtArgs> | null
    /**
     * Filter, which AlumnoSuelto to fetch.
     */
    where?: AlumnoSueltoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlumnoSueltos to fetch.
     */
    orderBy?: AlumnoSueltoOrderByWithRelationInput | AlumnoSueltoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlumnoSueltos.
     */
    cursor?: AlumnoSueltoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlumnoSueltos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlumnoSueltos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlumnoSueltos.
     */
    distinct?: AlumnoSueltoScalarFieldEnum | AlumnoSueltoScalarFieldEnum[]
  }

  /**
   * AlumnoSuelto findMany
   */
  export type AlumnoSueltoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoSuelto
     */
    select?: AlumnoSueltoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoSuelto
     */
    omit?: AlumnoSueltoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoSueltoInclude<ExtArgs> | null
    /**
     * Filter, which AlumnoSueltos to fetch.
     */
    where?: AlumnoSueltoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlumnoSueltos to fetch.
     */
    orderBy?: AlumnoSueltoOrderByWithRelationInput | AlumnoSueltoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AlumnoSueltos.
     */
    cursor?: AlumnoSueltoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlumnoSueltos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlumnoSueltos.
     */
    skip?: number
    distinct?: AlumnoSueltoScalarFieldEnum | AlumnoSueltoScalarFieldEnum[]
  }

  /**
   * AlumnoSuelto create
   */
  export type AlumnoSueltoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoSuelto
     */
    select?: AlumnoSueltoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoSuelto
     */
    omit?: AlumnoSueltoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoSueltoInclude<ExtArgs> | null
    /**
     * The data needed to create a AlumnoSuelto.
     */
    data: XOR<AlumnoSueltoCreateInput, AlumnoSueltoUncheckedCreateInput>
  }

  /**
   * AlumnoSuelto createMany
   */
  export type AlumnoSueltoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AlumnoSueltos.
     */
    data: AlumnoSueltoCreateManyInput | AlumnoSueltoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AlumnoSuelto createManyAndReturn
   */
  export type AlumnoSueltoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoSuelto
     */
    select?: AlumnoSueltoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoSuelto
     */
    omit?: AlumnoSueltoOmit<ExtArgs> | null
    /**
     * The data used to create many AlumnoSueltos.
     */
    data: AlumnoSueltoCreateManyInput | AlumnoSueltoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoSueltoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AlumnoSuelto update
   */
  export type AlumnoSueltoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoSuelto
     */
    select?: AlumnoSueltoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoSuelto
     */
    omit?: AlumnoSueltoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoSueltoInclude<ExtArgs> | null
    /**
     * The data needed to update a AlumnoSuelto.
     */
    data: XOR<AlumnoSueltoUpdateInput, AlumnoSueltoUncheckedUpdateInput>
    /**
     * Choose, which AlumnoSuelto to update.
     */
    where: AlumnoSueltoWhereUniqueInput
  }

  /**
   * AlumnoSuelto updateMany
   */
  export type AlumnoSueltoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AlumnoSueltos.
     */
    data: XOR<AlumnoSueltoUpdateManyMutationInput, AlumnoSueltoUncheckedUpdateManyInput>
    /**
     * Filter which AlumnoSueltos to update
     */
    where?: AlumnoSueltoWhereInput
  }

  /**
   * AlumnoSuelto updateManyAndReturn
   */
  export type AlumnoSueltoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoSuelto
     */
    select?: AlumnoSueltoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoSuelto
     */
    omit?: AlumnoSueltoOmit<ExtArgs> | null
    /**
     * The data used to update AlumnoSueltos.
     */
    data: XOR<AlumnoSueltoUpdateManyMutationInput, AlumnoSueltoUncheckedUpdateManyInput>
    /**
     * Filter which AlumnoSueltos to update
     */
    where?: AlumnoSueltoWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoSueltoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AlumnoSuelto upsert
   */
  export type AlumnoSueltoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoSuelto
     */
    select?: AlumnoSueltoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoSuelto
     */
    omit?: AlumnoSueltoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoSueltoInclude<ExtArgs> | null
    /**
     * The filter to search for the AlumnoSuelto to update in case it exists.
     */
    where: AlumnoSueltoWhereUniqueInput
    /**
     * In case the AlumnoSuelto found by the `where` argument doesn't exist, create a new AlumnoSuelto with this data.
     */
    create: XOR<AlumnoSueltoCreateInput, AlumnoSueltoUncheckedCreateInput>
    /**
     * In case the AlumnoSuelto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlumnoSueltoUpdateInput, AlumnoSueltoUncheckedUpdateInput>
  }

  /**
   * AlumnoSuelto delete
   */
  export type AlumnoSueltoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoSuelto
     */
    select?: AlumnoSueltoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoSuelto
     */
    omit?: AlumnoSueltoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoSueltoInclude<ExtArgs> | null
    /**
     * Filter which AlumnoSuelto to delete.
     */
    where: AlumnoSueltoWhereUniqueInput
  }

  /**
   * AlumnoSuelto deleteMany
   */
  export type AlumnoSueltoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlumnoSueltos to delete
     */
    where?: AlumnoSueltoWhereInput
  }

  /**
   * AlumnoSuelto.recibos
   */
  export type AlumnoSuelto$recibosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recibo
     */
    select?: ReciboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recibo
     */
    omit?: ReciboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReciboInclude<ExtArgs> | null
    where?: ReciboWhereInput
    orderBy?: ReciboOrderByWithRelationInput | ReciboOrderByWithRelationInput[]
    cursor?: ReciboWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReciboScalarFieldEnum | ReciboScalarFieldEnum[]
  }

  /**
   * AlumnoSuelto.clases
   */
  export type AlumnoSuelto$clasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clase
     */
    select?: ClaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clase
     */
    omit?: ClaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaseInclude<ExtArgs> | null
    where?: ClaseWhereInput
    orderBy?: ClaseOrderByWithRelationInput | ClaseOrderByWithRelationInput[]
    cursor?: ClaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaseScalarFieldEnum | ClaseScalarFieldEnum[]
  }

  /**
   * AlumnoSuelto.alumnoRegular
   */
  export type AlumnoSuelto$alumnoRegularArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alumno
     */
    select?: AlumnoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alumno
     */
    omit?: AlumnoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoInclude<ExtArgs> | null
    where?: AlumnoWhereInput
  }

  /**
   * AlumnoSuelto without action
   */
  export type AlumnoSueltoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoSuelto
     */
    select?: AlumnoSueltoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlumnoSuelto
     */
    omit?: AlumnoSueltoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlumnoSueltoInclude<ExtArgs> | null
  }


  /**
   * Model Liquidacion
   */

  export type AggregateLiquidacion = {
    _count: LiquidacionCountAggregateOutputType | null
    _avg: LiquidacionAvgAggregateOutputType | null
    _sum: LiquidacionSumAggregateOutputType | null
    _min: LiquidacionMinAggregateOutputType | null
    _max: LiquidacionMaxAggregateOutputType | null
  }

  export type LiquidacionAvgAggregateOutputType = {
    id: number | null
    mes: number | null
    anio: number | null
    profesorId: number | null
    montoTotal: number | null
    montoCursos: number | null
    montoClasesSueltas: number | null
    porcentajeCursos: number | null
    porcentajeClasesSueltas: number | null
  }

  export type LiquidacionSumAggregateOutputType = {
    id: number | null
    mes: number | null
    anio: number | null
    profesorId: number | null
    montoTotal: number | null
    montoCursos: number | null
    montoClasesSueltas: number | null
    porcentajeCursos: number | null
    porcentajeClasesSueltas: number | null
  }

  export type LiquidacionMinAggregateOutputType = {
    id: number | null
    fecha: Date | null
    mes: number | null
    anio: number | null
    profesorId: number | null
    montoTotal: number | null
    montoCursos: number | null
    montoClasesSueltas: number | null
    porcentajeCursos: number | null
    porcentajeClasesSueltas: number | null
    estado: $Enums.EstadoLiquidacion | null
    metodoPago: $Enums.TipoPago | null
    fechaPago: Date | null
    observaciones: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LiquidacionMaxAggregateOutputType = {
    id: number | null
    fecha: Date | null
    mes: number | null
    anio: number | null
    profesorId: number | null
    montoTotal: number | null
    montoCursos: number | null
    montoClasesSueltas: number | null
    porcentajeCursos: number | null
    porcentajeClasesSueltas: number | null
    estado: $Enums.EstadoLiquidacion | null
    metodoPago: $Enums.TipoPago | null
    fechaPago: Date | null
    observaciones: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LiquidacionCountAggregateOutputType = {
    id: number
    fecha: number
    mes: number
    anio: number
    profesorId: number
    montoTotal: number
    montoCursos: number
    montoClasesSueltas: number
    porcentajeCursos: number
    porcentajeClasesSueltas: number
    estado: number
    metodoPago: number
    fechaPago: number
    observaciones: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LiquidacionAvgAggregateInputType = {
    id?: true
    mes?: true
    anio?: true
    profesorId?: true
    montoTotal?: true
    montoCursos?: true
    montoClasesSueltas?: true
    porcentajeCursos?: true
    porcentajeClasesSueltas?: true
  }

  export type LiquidacionSumAggregateInputType = {
    id?: true
    mes?: true
    anio?: true
    profesorId?: true
    montoTotal?: true
    montoCursos?: true
    montoClasesSueltas?: true
    porcentajeCursos?: true
    porcentajeClasesSueltas?: true
  }

  export type LiquidacionMinAggregateInputType = {
    id?: true
    fecha?: true
    mes?: true
    anio?: true
    profesorId?: true
    montoTotal?: true
    montoCursos?: true
    montoClasesSueltas?: true
    porcentajeCursos?: true
    porcentajeClasesSueltas?: true
    estado?: true
    metodoPago?: true
    fechaPago?: true
    observaciones?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LiquidacionMaxAggregateInputType = {
    id?: true
    fecha?: true
    mes?: true
    anio?: true
    profesorId?: true
    montoTotal?: true
    montoCursos?: true
    montoClasesSueltas?: true
    porcentajeCursos?: true
    porcentajeClasesSueltas?: true
    estado?: true
    metodoPago?: true
    fechaPago?: true
    observaciones?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LiquidacionCountAggregateInputType = {
    id?: true
    fecha?: true
    mes?: true
    anio?: true
    profesorId?: true
    montoTotal?: true
    montoCursos?: true
    montoClasesSueltas?: true
    porcentajeCursos?: true
    porcentajeClasesSueltas?: true
    estado?: true
    metodoPago?: true
    fechaPago?: true
    observaciones?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LiquidacionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Liquidacion to aggregate.
     */
    where?: LiquidacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Liquidacions to fetch.
     */
    orderBy?: LiquidacionOrderByWithRelationInput | LiquidacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LiquidacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Liquidacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Liquidacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Liquidacions
    **/
    _count?: true | LiquidacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LiquidacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LiquidacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LiquidacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LiquidacionMaxAggregateInputType
  }

  export type GetLiquidacionAggregateType<T extends LiquidacionAggregateArgs> = {
        [P in keyof T & keyof AggregateLiquidacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLiquidacion[P]>
      : GetScalarType<T[P], AggregateLiquidacion[P]>
  }




  export type LiquidacionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiquidacionWhereInput
    orderBy?: LiquidacionOrderByWithAggregationInput | LiquidacionOrderByWithAggregationInput[]
    by: LiquidacionScalarFieldEnum[] | LiquidacionScalarFieldEnum
    having?: LiquidacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LiquidacionCountAggregateInputType | true
    _avg?: LiquidacionAvgAggregateInputType
    _sum?: LiquidacionSumAggregateInputType
    _min?: LiquidacionMinAggregateInputType
    _max?: LiquidacionMaxAggregateInputType
  }

  export type LiquidacionGroupByOutputType = {
    id: number
    fecha: Date
    mes: number
    anio: number
    profesorId: number | null
    montoTotal: number
    montoCursos: number
    montoClasesSueltas: number
    porcentajeCursos: number
    porcentajeClasesSueltas: number
    estado: $Enums.EstadoLiquidacion
    metodoPago: $Enums.TipoPago | null
    fechaPago: Date | null
    observaciones: string | null
    createdAt: Date
    updatedAt: Date
    _count: LiquidacionCountAggregateOutputType | null
    _avg: LiquidacionAvgAggregateOutputType | null
    _sum: LiquidacionSumAggregateOutputType | null
    _min: LiquidacionMinAggregateOutputType | null
    _max: LiquidacionMaxAggregateOutputType | null
  }

  type GetLiquidacionGroupByPayload<T extends LiquidacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LiquidacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LiquidacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LiquidacionGroupByOutputType[P]>
            : GetScalarType<T[P], LiquidacionGroupByOutputType[P]>
        }
      >
    >


  export type LiquidacionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fecha?: boolean
    mes?: boolean
    anio?: boolean
    profesorId?: boolean
    montoTotal?: boolean
    montoCursos?: boolean
    montoClasesSueltas?: boolean
    porcentajeCursos?: boolean
    porcentajeClasesSueltas?: boolean
    estado?: boolean
    metodoPago?: boolean
    fechaPago?: boolean
    observaciones?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profesor?: boolean | Liquidacion$profesorArgs<ExtArgs>
    detalles?: boolean | Liquidacion$detallesArgs<ExtArgs>
    _count?: boolean | LiquidacionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["liquidacion"]>

  export type LiquidacionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fecha?: boolean
    mes?: boolean
    anio?: boolean
    profesorId?: boolean
    montoTotal?: boolean
    montoCursos?: boolean
    montoClasesSueltas?: boolean
    porcentajeCursos?: boolean
    porcentajeClasesSueltas?: boolean
    estado?: boolean
    metodoPago?: boolean
    fechaPago?: boolean
    observaciones?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profesor?: boolean | Liquidacion$profesorArgs<ExtArgs>
  }, ExtArgs["result"]["liquidacion"]>

  export type LiquidacionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fecha?: boolean
    mes?: boolean
    anio?: boolean
    profesorId?: boolean
    montoTotal?: boolean
    montoCursos?: boolean
    montoClasesSueltas?: boolean
    porcentajeCursos?: boolean
    porcentajeClasesSueltas?: boolean
    estado?: boolean
    metodoPago?: boolean
    fechaPago?: boolean
    observaciones?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profesor?: boolean | Liquidacion$profesorArgs<ExtArgs>
  }, ExtArgs["result"]["liquidacion"]>

  export type LiquidacionSelectScalar = {
    id?: boolean
    fecha?: boolean
    mes?: boolean
    anio?: boolean
    profesorId?: boolean
    montoTotal?: boolean
    montoCursos?: boolean
    montoClasesSueltas?: boolean
    porcentajeCursos?: boolean
    porcentajeClasesSueltas?: boolean
    estado?: boolean
    metodoPago?: boolean
    fechaPago?: boolean
    observaciones?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LiquidacionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fecha" | "mes" | "anio" | "profesorId" | "montoTotal" | "montoCursos" | "montoClasesSueltas" | "porcentajeCursos" | "porcentajeClasesSueltas" | "estado" | "metodoPago" | "fechaPago" | "observaciones" | "createdAt" | "updatedAt", ExtArgs["result"]["liquidacion"]>
  export type LiquidacionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profesor?: boolean | Liquidacion$profesorArgs<ExtArgs>
    detalles?: boolean | Liquidacion$detallesArgs<ExtArgs>
    _count?: boolean | LiquidacionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LiquidacionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profesor?: boolean | Liquidacion$profesorArgs<ExtArgs>
  }
  export type LiquidacionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profesor?: boolean | Liquidacion$profesorArgs<ExtArgs>
  }

  export type $LiquidacionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Liquidacion"
    objects: {
      profesor: Prisma.$ProfesorPayload<ExtArgs> | null
      detalles: Prisma.$DetalleLiquidacionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fecha: Date
      mes: number
      anio: number
      profesorId: number | null
      montoTotal: number
      montoCursos: number
      montoClasesSueltas: number
      porcentajeCursos: number
      porcentajeClasesSueltas: number
      estado: $Enums.EstadoLiquidacion
      metodoPago: $Enums.TipoPago | null
      fechaPago: Date | null
      observaciones: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["liquidacion"]>
    composites: {}
  }

  type LiquidacionGetPayload<S extends boolean | null | undefined | LiquidacionDefaultArgs> = $Result.GetResult<Prisma.$LiquidacionPayload, S>

  type LiquidacionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LiquidacionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LiquidacionCountAggregateInputType | true
    }

  export interface LiquidacionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Liquidacion'], meta: { name: 'Liquidacion' } }
    /**
     * Find zero or one Liquidacion that matches the filter.
     * @param {LiquidacionFindUniqueArgs} args - Arguments to find a Liquidacion
     * @example
     * // Get one Liquidacion
     * const liquidacion = await prisma.liquidacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LiquidacionFindUniqueArgs>(args: SelectSubset<T, LiquidacionFindUniqueArgs<ExtArgs>>): Prisma__LiquidacionClient<$Result.GetResult<Prisma.$LiquidacionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Liquidacion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LiquidacionFindUniqueOrThrowArgs} args - Arguments to find a Liquidacion
     * @example
     * // Get one Liquidacion
     * const liquidacion = await prisma.liquidacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LiquidacionFindUniqueOrThrowArgs>(args: SelectSubset<T, LiquidacionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LiquidacionClient<$Result.GetResult<Prisma.$LiquidacionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Liquidacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiquidacionFindFirstArgs} args - Arguments to find a Liquidacion
     * @example
     * // Get one Liquidacion
     * const liquidacion = await prisma.liquidacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LiquidacionFindFirstArgs>(args?: SelectSubset<T, LiquidacionFindFirstArgs<ExtArgs>>): Prisma__LiquidacionClient<$Result.GetResult<Prisma.$LiquidacionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Liquidacion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiquidacionFindFirstOrThrowArgs} args - Arguments to find a Liquidacion
     * @example
     * // Get one Liquidacion
     * const liquidacion = await prisma.liquidacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LiquidacionFindFirstOrThrowArgs>(args?: SelectSubset<T, LiquidacionFindFirstOrThrowArgs<ExtArgs>>): Prisma__LiquidacionClient<$Result.GetResult<Prisma.$LiquidacionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Liquidacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiquidacionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Liquidacions
     * const liquidacions = await prisma.liquidacion.findMany()
     * 
     * // Get first 10 Liquidacions
     * const liquidacions = await prisma.liquidacion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const liquidacionWithIdOnly = await prisma.liquidacion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LiquidacionFindManyArgs>(args?: SelectSubset<T, LiquidacionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiquidacionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Liquidacion.
     * @param {LiquidacionCreateArgs} args - Arguments to create a Liquidacion.
     * @example
     * // Create one Liquidacion
     * const Liquidacion = await prisma.liquidacion.create({
     *   data: {
     *     // ... data to create a Liquidacion
     *   }
     * })
     * 
     */
    create<T extends LiquidacionCreateArgs>(args: SelectSubset<T, LiquidacionCreateArgs<ExtArgs>>): Prisma__LiquidacionClient<$Result.GetResult<Prisma.$LiquidacionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Liquidacions.
     * @param {LiquidacionCreateManyArgs} args - Arguments to create many Liquidacions.
     * @example
     * // Create many Liquidacions
     * const liquidacion = await prisma.liquidacion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LiquidacionCreateManyArgs>(args?: SelectSubset<T, LiquidacionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Liquidacions and returns the data saved in the database.
     * @param {LiquidacionCreateManyAndReturnArgs} args - Arguments to create many Liquidacions.
     * @example
     * // Create many Liquidacions
     * const liquidacion = await prisma.liquidacion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Liquidacions and only return the `id`
     * const liquidacionWithIdOnly = await prisma.liquidacion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LiquidacionCreateManyAndReturnArgs>(args?: SelectSubset<T, LiquidacionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiquidacionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Liquidacion.
     * @param {LiquidacionDeleteArgs} args - Arguments to delete one Liquidacion.
     * @example
     * // Delete one Liquidacion
     * const Liquidacion = await prisma.liquidacion.delete({
     *   where: {
     *     // ... filter to delete one Liquidacion
     *   }
     * })
     * 
     */
    delete<T extends LiquidacionDeleteArgs>(args: SelectSubset<T, LiquidacionDeleteArgs<ExtArgs>>): Prisma__LiquidacionClient<$Result.GetResult<Prisma.$LiquidacionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Liquidacion.
     * @param {LiquidacionUpdateArgs} args - Arguments to update one Liquidacion.
     * @example
     * // Update one Liquidacion
     * const liquidacion = await prisma.liquidacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LiquidacionUpdateArgs>(args: SelectSubset<T, LiquidacionUpdateArgs<ExtArgs>>): Prisma__LiquidacionClient<$Result.GetResult<Prisma.$LiquidacionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Liquidacions.
     * @param {LiquidacionDeleteManyArgs} args - Arguments to filter Liquidacions to delete.
     * @example
     * // Delete a few Liquidacions
     * const { count } = await prisma.liquidacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LiquidacionDeleteManyArgs>(args?: SelectSubset<T, LiquidacionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Liquidacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiquidacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Liquidacions
     * const liquidacion = await prisma.liquidacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LiquidacionUpdateManyArgs>(args: SelectSubset<T, LiquidacionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Liquidacions and returns the data updated in the database.
     * @param {LiquidacionUpdateManyAndReturnArgs} args - Arguments to update many Liquidacions.
     * @example
     * // Update many Liquidacions
     * const liquidacion = await prisma.liquidacion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Liquidacions and only return the `id`
     * const liquidacionWithIdOnly = await prisma.liquidacion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LiquidacionUpdateManyAndReturnArgs>(args: SelectSubset<T, LiquidacionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiquidacionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Liquidacion.
     * @param {LiquidacionUpsertArgs} args - Arguments to update or create a Liquidacion.
     * @example
     * // Update or create a Liquidacion
     * const liquidacion = await prisma.liquidacion.upsert({
     *   create: {
     *     // ... data to create a Liquidacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Liquidacion we want to update
     *   }
     * })
     */
    upsert<T extends LiquidacionUpsertArgs>(args: SelectSubset<T, LiquidacionUpsertArgs<ExtArgs>>): Prisma__LiquidacionClient<$Result.GetResult<Prisma.$LiquidacionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Liquidacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiquidacionCountArgs} args - Arguments to filter Liquidacions to count.
     * @example
     * // Count the number of Liquidacions
     * const count = await prisma.liquidacion.count({
     *   where: {
     *     // ... the filter for the Liquidacions we want to count
     *   }
     * })
    **/
    count<T extends LiquidacionCountArgs>(
      args?: Subset<T, LiquidacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LiquidacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Liquidacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiquidacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LiquidacionAggregateArgs>(args: Subset<T, LiquidacionAggregateArgs>): Prisma.PrismaPromise<GetLiquidacionAggregateType<T>>

    /**
     * Group by Liquidacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiquidacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LiquidacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LiquidacionGroupByArgs['orderBy'] }
        : { orderBy?: LiquidacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LiquidacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiquidacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Liquidacion model
   */
  readonly fields: LiquidacionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Liquidacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LiquidacionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profesor<T extends Liquidacion$profesorArgs<ExtArgs> = {}>(args?: Subset<T, Liquidacion$profesorArgs<ExtArgs>>): Prisma__ProfesorClient<$Result.GetResult<Prisma.$ProfesorPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    detalles<T extends Liquidacion$detallesArgs<ExtArgs> = {}>(args?: Subset<T, Liquidacion$detallesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetalleLiquidacionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Liquidacion model
   */ 
  interface LiquidacionFieldRefs {
    readonly id: FieldRef<"Liquidacion", 'Int'>
    readonly fecha: FieldRef<"Liquidacion", 'DateTime'>
    readonly mes: FieldRef<"Liquidacion", 'Int'>
    readonly anio: FieldRef<"Liquidacion", 'Int'>
    readonly profesorId: FieldRef<"Liquidacion", 'Int'>
    readonly montoTotal: FieldRef<"Liquidacion", 'Float'>
    readonly montoCursos: FieldRef<"Liquidacion", 'Float'>
    readonly montoClasesSueltas: FieldRef<"Liquidacion", 'Float'>
    readonly porcentajeCursos: FieldRef<"Liquidacion", 'Float'>
    readonly porcentajeClasesSueltas: FieldRef<"Liquidacion", 'Float'>
    readonly estado: FieldRef<"Liquidacion", 'EstadoLiquidacion'>
    readonly metodoPago: FieldRef<"Liquidacion", 'TipoPago'>
    readonly fechaPago: FieldRef<"Liquidacion", 'DateTime'>
    readonly observaciones: FieldRef<"Liquidacion", 'String'>
    readonly createdAt: FieldRef<"Liquidacion", 'DateTime'>
    readonly updatedAt: FieldRef<"Liquidacion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Liquidacion findUnique
   */
  export type LiquidacionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liquidacion
     */
    select?: LiquidacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liquidacion
     */
    omit?: LiquidacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiquidacionInclude<ExtArgs> | null
    /**
     * Filter, which Liquidacion to fetch.
     */
    where: LiquidacionWhereUniqueInput
  }

  /**
   * Liquidacion findUniqueOrThrow
   */
  export type LiquidacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liquidacion
     */
    select?: LiquidacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liquidacion
     */
    omit?: LiquidacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiquidacionInclude<ExtArgs> | null
    /**
     * Filter, which Liquidacion to fetch.
     */
    where: LiquidacionWhereUniqueInput
  }

  /**
   * Liquidacion findFirst
   */
  export type LiquidacionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liquidacion
     */
    select?: LiquidacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liquidacion
     */
    omit?: LiquidacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiquidacionInclude<ExtArgs> | null
    /**
     * Filter, which Liquidacion to fetch.
     */
    where?: LiquidacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Liquidacions to fetch.
     */
    orderBy?: LiquidacionOrderByWithRelationInput | LiquidacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Liquidacions.
     */
    cursor?: LiquidacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Liquidacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Liquidacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Liquidacions.
     */
    distinct?: LiquidacionScalarFieldEnum | LiquidacionScalarFieldEnum[]
  }

  /**
   * Liquidacion findFirstOrThrow
   */
  export type LiquidacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liquidacion
     */
    select?: LiquidacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liquidacion
     */
    omit?: LiquidacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiquidacionInclude<ExtArgs> | null
    /**
     * Filter, which Liquidacion to fetch.
     */
    where?: LiquidacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Liquidacions to fetch.
     */
    orderBy?: LiquidacionOrderByWithRelationInput | LiquidacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Liquidacions.
     */
    cursor?: LiquidacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Liquidacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Liquidacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Liquidacions.
     */
    distinct?: LiquidacionScalarFieldEnum | LiquidacionScalarFieldEnum[]
  }

  /**
   * Liquidacion findMany
   */
  export type LiquidacionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liquidacion
     */
    select?: LiquidacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liquidacion
     */
    omit?: LiquidacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiquidacionInclude<ExtArgs> | null
    /**
     * Filter, which Liquidacions to fetch.
     */
    where?: LiquidacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Liquidacions to fetch.
     */
    orderBy?: LiquidacionOrderByWithRelationInput | LiquidacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Liquidacions.
     */
    cursor?: LiquidacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Liquidacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Liquidacions.
     */
    skip?: number
    distinct?: LiquidacionScalarFieldEnum | LiquidacionScalarFieldEnum[]
  }

  /**
   * Liquidacion create
   */
  export type LiquidacionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liquidacion
     */
    select?: LiquidacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liquidacion
     */
    omit?: LiquidacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiquidacionInclude<ExtArgs> | null
    /**
     * The data needed to create a Liquidacion.
     */
    data: XOR<LiquidacionCreateInput, LiquidacionUncheckedCreateInput>
  }

  /**
   * Liquidacion createMany
   */
  export type LiquidacionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Liquidacions.
     */
    data: LiquidacionCreateManyInput | LiquidacionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Liquidacion createManyAndReturn
   */
  export type LiquidacionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liquidacion
     */
    select?: LiquidacionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Liquidacion
     */
    omit?: LiquidacionOmit<ExtArgs> | null
    /**
     * The data used to create many Liquidacions.
     */
    data: LiquidacionCreateManyInput | LiquidacionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiquidacionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Liquidacion update
   */
  export type LiquidacionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liquidacion
     */
    select?: LiquidacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liquidacion
     */
    omit?: LiquidacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiquidacionInclude<ExtArgs> | null
    /**
     * The data needed to update a Liquidacion.
     */
    data: XOR<LiquidacionUpdateInput, LiquidacionUncheckedUpdateInput>
    /**
     * Choose, which Liquidacion to update.
     */
    where: LiquidacionWhereUniqueInput
  }

  /**
   * Liquidacion updateMany
   */
  export type LiquidacionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Liquidacions.
     */
    data: XOR<LiquidacionUpdateManyMutationInput, LiquidacionUncheckedUpdateManyInput>
    /**
     * Filter which Liquidacions to update
     */
    where?: LiquidacionWhereInput
  }

  /**
   * Liquidacion updateManyAndReturn
   */
  export type LiquidacionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liquidacion
     */
    select?: LiquidacionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Liquidacion
     */
    omit?: LiquidacionOmit<ExtArgs> | null
    /**
     * The data used to update Liquidacions.
     */
    data: XOR<LiquidacionUpdateManyMutationInput, LiquidacionUncheckedUpdateManyInput>
    /**
     * Filter which Liquidacions to update
     */
    where?: LiquidacionWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiquidacionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Liquidacion upsert
   */
  export type LiquidacionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liquidacion
     */
    select?: LiquidacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liquidacion
     */
    omit?: LiquidacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiquidacionInclude<ExtArgs> | null
    /**
     * The filter to search for the Liquidacion to update in case it exists.
     */
    where: LiquidacionWhereUniqueInput
    /**
     * In case the Liquidacion found by the `where` argument doesn't exist, create a new Liquidacion with this data.
     */
    create: XOR<LiquidacionCreateInput, LiquidacionUncheckedCreateInput>
    /**
     * In case the Liquidacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LiquidacionUpdateInput, LiquidacionUncheckedUpdateInput>
  }

  /**
   * Liquidacion delete
   */
  export type LiquidacionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liquidacion
     */
    select?: LiquidacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liquidacion
     */
    omit?: LiquidacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiquidacionInclude<ExtArgs> | null
    /**
     * Filter which Liquidacion to delete.
     */
    where: LiquidacionWhereUniqueInput
  }

  /**
   * Liquidacion deleteMany
   */
  export type LiquidacionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Liquidacions to delete
     */
    where?: LiquidacionWhereInput
  }

  /**
   * Liquidacion.profesor
   */
  export type Liquidacion$profesorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesor
     */
    select?: ProfesorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profesor
     */
    omit?: ProfesorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesorInclude<ExtArgs> | null
    where?: ProfesorWhereInput
  }

  /**
   * Liquidacion.detalles
   */
  export type Liquidacion$detallesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleLiquidacion
     */
    select?: DetalleLiquidacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetalleLiquidacion
     */
    omit?: DetalleLiquidacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetalleLiquidacionInclude<ExtArgs> | null
    where?: DetalleLiquidacionWhereInput
    orderBy?: DetalleLiquidacionOrderByWithRelationInput | DetalleLiquidacionOrderByWithRelationInput[]
    cursor?: DetalleLiquidacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetalleLiquidacionScalarFieldEnum | DetalleLiquidacionScalarFieldEnum[]
  }

  /**
   * Liquidacion without action
   */
  export type LiquidacionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liquidacion
     */
    select?: LiquidacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liquidacion
     */
    omit?: LiquidacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiquidacionInclude<ExtArgs> | null
  }


  /**
   * Model DetalleLiquidacion
   */

  export type AggregateDetalleLiquidacion = {
    _count: DetalleLiquidacionCountAggregateOutputType | null
    _avg: DetalleLiquidacionAvgAggregateOutputType | null
    _sum: DetalleLiquidacionSumAggregateOutputType | null
    _min: DetalleLiquidacionMinAggregateOutputType | null
    _max: DetalleLiquidacionMaxAggregateOutputType | null
  }

  export type DetalleLiquidacionAvgAggregateOutputType = {
    id: number | null
    liquidacionId: number | null
    reciboId: number | null
    montoOriginal: number | null
    porcentaje: number | null
    montoLiquidado: number | null
  }

  export type DetalleLiquidacionSumAggregateOutputType = {
    id: number | null
    liquidacionId: number | null
    reciboId: number | null
    montoOriginal: number | null
    porcentaje: number | null
    montoLiquidado: number | null
  }

  export type DetalleLiquidacionMinAggregateOutputType = {
    id: number | null
    liquidacionId: number | null
    reciboId: number | null
    montoOriginal: number | null
    porcentaje: number | null
    montoLiquidado: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DetalleLiquidacionMaxAggregateOutputType = {
    id: number | null
    liquidacionId: number | null
    reciboId: number | null
    montoOriginal: number | null
    porcentaje: number | null
    montoLiquidado: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DetalleLiquidacionCountAggregateOutputType = {
    id: number
    liquidacionId: number
    reciboId: number
    montoOriginal: number
    porcentaje: number
    montoLiquidado: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DetalleLiquidacionAvgAggregateInputType = {
    id?: true
    liquidacionId?: true
    reciboId?: true
    montoOriginal?: true
    porcentaje?: true
    montoLiquidado?: true
  }

  export type DetalleLiquidacionSumAggregateInputType = {
    id?: true
    liquidacionId?: true
    reciboId?: true
    montoOriginal?: true
    porcentaje?: true
    montoLiquidado?: true
  }

  export type DetalleLiquidacionMinAggregateInputType = {
    id?: true
    liquidacionId?: true
    reciboId?: true
    montoOriginal?: true
    porcentaje?: true
    montoLiquidado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DetalleLiquidacionMaxAggregateInputType = {
    id?: true
    liquidacionId?: true
    reciboId?: true
    montoOriginal?: true
    porcentaje?: true
    montoLiquidado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DetalleLiquidacionCountAggregateInputType = {
    id?: true
    liquidacionId?: true
    reciboId?: true
    montoOriginal?: true
    porcentaje?: true
    montoLiquidado?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DetalleLiquidacionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetalleLiquidacion to aggregate.
     */
    where?: DetalleLiquidacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetalleLiquidacions to fetch.
     */
    orderBy?: DetalleLiquidacionOrderByWithRelationInput | DetalleLiquidacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DetalleLiquidacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetalleLiquidacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetalleLiquidacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DetalleLiquidacions
    **/
    _count?: true | DetalleLiquidacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DetalleLiquidacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DetalleLiquidacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DetalleLiquidacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DetalleLiquidacionMaxAggregateInputType
  }

  export type GetDetalleLiquidacionAggregateType<T extends DetalleLiquidacionAggregateArgs> = {
        [P in keyof T & keyof AggregateDetalleLiquidacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetalleLiquidacion[P]>
      : GetScalarType<T[P], AggregateDetalleLiquidacion[P]>
  }




  export type DetalleLiquidacionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetalleLiquidacionWhereInput
    orderBy?: DetalleLiquidacionOrderByWithAggregationInput | DetalleLiquidacionOrderByWithAggregationInput[]
    by: DetalleLiquidacionScalarFieldEnum[] | DetalleLiquidacionScalarFieldEnum
    having?: DetalleLiquidacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DetalleLiquidacionCountAggregateInputType | true
    _avg?: DetalleLiquidacionAvgAggregateInputType
    _sum?: DetalleLiquidacionSumAggregateInputType
    _min?: DetalleLiquidacionMinAggregateInputType
    _max?: DetalleLiquidacionMaxAggregateInputType
  }

  export type DetalleLiquidacionGroupByOutputType = {
    id: number
    liquidacionId: number
    reciboId: number | null
    montoOriginal: number
    porcentaje: number
    montoLiquidado: number
    createdAt: Date
    updatedAt: Date
    _count: DetalleLiquidacionCountAggregateOutputType | null
    _avg: DetalleLiquidacionAvgAggregateOutputType | null
    _sum: DetalleLiquidacionSumAggregateOutputType | null
    _min: DetalleLiquidacionMinAggregateOutputType | null
    _max: DetalleLiquidacionMaxAggregateOutputType | null
  }

  type GetDetalleLiquidacionGroupByPayload<T extends DetalleLiquidacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DetalleLiquidacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DetalleLiquidacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DetalleLiquidacionGroupByOutputType[P]>
            : GetScalarType<T[P], DetalleLiquidacionGroupByOutputType[P]>
        }
      >
    >


  export type DetalleLiquidacionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    liquidacionId?: boolean
    reciboId?: boolean
    montoOriginal?: boolean
    porcentaje?: boolean
    montoLiquidado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    liquidacion?: boolean | LiquidacionDefaultArgs<ExtArgs>
    recibo?: boolean | DetalleLiquidacion$reciboArgs<ExtArgs>
  }, ExtArgs["result"]["detalleLiquidacion"]>

  export type DetalleLiquidacionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    liquidacionId?: boolean
    reciboId?: boolean
    montoOriginal?: boolean
    porcentaje?: boolean
    montoLiquidado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    liquidacion?: boolean | LiquidacionDefaultArgs<ExtArgs>
    recibo?: boolean | DetalleLiquidacion$reciboArgs<ExtArgs>
  }, ExtArgs["result"]["detalleLiquidacion"]>

  export type DetalleLiquidacionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    liquidacionId?: boolean
    reciboId?: boolean
    montoOriginal?: boolean
    porcentaje?: boolean
    montoLiquidado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    liquidacion?: boolean | LiquidacionDefaultArgs<ExtArgs>
    recibo?: boolean | DetalleLiquidacion$reciboArgs<ExtArgs>
  }, ExtArgs["result"]["detalleLiquidacion"]>

  export type DetalleLiquidacionSelectScalar = {
    id?: boolean
    liquidacionId?: boolean
    reciboId?: boolean
    montoOriginal?: boolean
    porcentaje?: boolean
    montoLiquidado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DetalleLiquidacionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "liquidacionId" | "reciboId" | "montoOriginal" | "porcentaje" | "montoLiquidado" | "createdAt" | "updatedAt", ExtArgs["result"]["detalleLiquidacion"]>
  export type DetalleLiquidacionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    liquidacion?: boolean | LiquidacionDefaultArgs<ExtArgs>
    recibo?: boolean | DetalleLiquidacion$reciboArgs<ExtArgs>
  }
  export type DetalleLiquidacionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    liquidacion?: boolean | LiquidacionDefaultArgs<ExtArgs>
    recibo?: boolean | DetalleLiquidacion$reciboArgs<ExtArgs>
  }
  export type DetalleLiquidacionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    liquidacion?: boolean | LiquidacionDefaultArgs<ExtArgs>
    recibo?: boolean | DetalleLiquidacion$reciboArgs<ExtArgs>
  }

  export type $DetalleLiquidacionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DetalleLiquidacion"
    objects: {
      liquidacion: Prisma.$LiquidacionPayload<ExtArgs>
      recibo: Prisma.$ReciboPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      liquidacionId: number
      reciboId: number | null
      montoOriginal: number
      porcentaje: number
      montoLiquidado: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["detalleLiquidacion"]>
    composites: {}
  }

  type DetalleLiquidacionGetPayload<S extends boolean | null | undefined | DetalleLiquidacionDefaultArgs> = $Result.GetResult<Prisma.$DetalleLiquidacionPayload, S>

  type DetalleLiquidacionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DetalleLiquidacionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DetalleLiquidacionCountAggregateInputType | true
    }

  export interface DetalleLiquidacionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DetalleLiquidacion'], meta: { name: 'DetalleLiquidacion' } }
    /**
     * Find zero or one DetalleLiquidacion that matches the filter.
     * @param {DetalleLiquidacionFindUniqueArgs} args - Arguments to find a DetalleLiquidacion
     * @example
     * // Get one DetalleLiquidacion
     * const detalleLiquidacion = await prisma.detalleLiquidacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DetalleLiquidacionFindUniqueArgs>(args: SelectSubset<T, DetalleLiquidacionFindUniqueArgs<ExtArgs>>): Prisma__DetalleLiquidacionClient<$Result.GetResult<Prisma.$DetalleLiquidacionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DetalleLiquidacion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DetalleLiquidacionFindUniqueOrThrowArgs} args - Arguments to find a DetalleLiquidacion
     * @example
     * // Get one DetalleLiquidacion
     * const detalleLiquidacion = await prisma.detalleLiquidacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DetalleLiquidacionFindUniqueOrThrowArgs>(args: SelectSubset<T, DetalleLiquidacionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DetalleLiquidacionClient<$Result.GetResult<Prisma.$DetalleLiquidacionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DetalleLiquidacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleLiquidacionFindFirstArgs} args - Arguments to find a DetalleLiquidacion
     * @example
     * // Get one DetalleLiquidacion
     * const detalleLiquidacion = await prisma.detalleLiquidacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DetalleLiquidacionFindFirstArgs>(args?: SelectSubset<T, DetalleLiquidacionFindFirstArgs<ExtArgs>>): Prisma__DetalleLiquidacionClient<$Result.GetResult<Prisma.$DetalleLiquidacionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DetalleLiquidacion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleLiquidacionFindFirstOrThrowArgs} args - Arguments to find a DetalleLiquidacion
     * @example
     * // Get one DetalleLiquidacion
     * const detalleLiquidacion = await prisma.detalleLiquidacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DetalleLiquidacionFindFirstOrThrowArgs>(args?: SelectSubset<T, DetalleLiquidacionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DetalleLiquidacionClient<$Result.GetResult<Prisma.$DetalleLiquidacionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DetalleLiquidacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleLiquidacionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DetalleLiquidacions
     * const detalleLiquidacions = await prisma.detalleLiquidacion.findMany()
     * 
     * // Get first 10 DetalleLiquidacions
     * const detalleLiquidacions = await prisma.detalleLiquidacion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const detalleLiquidacionWithIdOnly = await prisma.detalleLiquidacion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DetalleLiquidacionFindManyArgs>(args?: SelectSubset<T, DetalleLiquidacionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetalleLiquidacionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DetalleLiquidacion.
     * @param {DetalleLiquidacionCreateArgs} args - Arguments to create a DetalleLiquidacion.
     * @example
     * // Create one DetalleLiquidacion
     * const DetalleLiquidacion = await prisma.detalleLiquidacion.create({
     *   data: {
     *     // ... data to create a DetalleLiquidacion
     *   }
     * })
     * 
     */
    create<T extends DetalleLiquidacionCreateArgs>(args: SelectSubset<T, DetalleLiquidacionCreateArgs<ExtArgs>>): Prisma__DetalleLiquidacionClient<$Result.GetResult<Prisma.$DetalleLiquidacionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DetalleLiquidacions.
     * @param {DetalleLiquidacionCreateManyArgs} args - Arguments to create many DetalleLiquidacions.
     * @example
     * // Create many DetalleLiquidacions
     * const detalleLiquidacion = await prisma.detalleLiquidacion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DetalleLiquidacionCreateManyArgs>(args?: SelectSubset<T, DetalleLiquidacionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DetalleLiquidacions and returns the data saved in the database.
     * @param {DetalleLiquidacionCreateManyAndReturnArgs} args - Arguments to create many DetalleLiquidacions.
     * @example
     * // Create many DetalleLiquidacions
     * const detalleLiquidacion = await prisma.detalleLiquidacion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DetalleLiquidacions and only return the `id`
     * const detalleLiquidacionWithIdOnly = await prisma.detalleLiquidacion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DetalleLiquidacionCreateManyAndReturnArgs>(args?: SelectSubset<T, DetalleLiquidacionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetalleLiquidacionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a DetalleLiquidacion.
     * @param {DetalleLiquidacionDeleteArgs} args - Arguments to delete one DetalleLiquidacion.
     * @example
     * // Delete one DetalleLiquidacion
     * const DetalleLiquidacion = await prisma.detalleLiquidacion.delete({
     *   where: {
     *     // ... filter to delete one DetalleLiquidacion
     *   }
     * })
     * 
     */
    delete<T extends DetalleLiquidacionDeleteArgs>(args: SelectSubset<T, DetalleLiquidacionDeleteArgs<ExtArgs>>): Prisma__DetalleLiquidacionClient<$Result.GetResult<Prisma.$DetalleLiquidacionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DetalleLiquidacion.
     * @param {DetalleLiquidacionUpdateArgs} args - Arguments to update one DetalleLiquidacion.
     * @example
     * // Update one DetalleLiquidacion
     * const detalleLiquidacion = await prisma.detalleLiquidacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DetalleLiquidacionUpdateArgs>(args: SelectSubset<T, DetalleLiquidacionUpdateArgs<ExtArgs>>): Prisma__DetalleLiquidacionClient<$Result.GetResult<Prisma.$DetalleLiquidacionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DetalleLiquidacions.
     * @param {DetalleLiquidacionDeleteManyArgs} args - Arguments to filter DetalleLiquidacions to delete.
     * @example
     * // Delete a few DetalleLiquidacions
     * const { count } = await prisma.detalleLiquidacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DetalleLiquidacionDeleteManyArgs>(args?: SelectSubset<T, DetalleLiquidacionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DetalleLiquidacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleLiquidacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DetalleLiquidacions
     * const detalleLiquidacion = await prisma.detalleLiquidacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DetalleLiquidacionUpdateManyArgs>(args: SelectSubset<T, DetalleLiquidacionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DetalleLiquidacions and returns the data updated in the database.
     * @param {DetalleLiquidacionUpdateManyAndReturnArgs} args - Arguments to update many DetalleLiquidacions.
     * @example
     * // Update many DetalleLiquidacions
     * const detalleLiquidacion = await prisma.detalleLiquidacion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DetalleLiquidacions and only return the `id`
     * const detalleLiquidacionWithIdOnly = await prisma.detalleLiquidacion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DetalleLiquidacionUpdateManyAndReturnArgs>(args: SelectSubset<T, DetalleLiquidacionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetalleLiquidacionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one DetalleLiquidacion.
     * @param {DetalleLiquidacionUpsertArgs} args - Arguments to update or create a DetalleLiquidacion.
     * @example
     * // Update or create a DetalleLiquidacion
     * const detalleLiquidacion = await prisma.detalleLiquidacion.upsert({
     *   create: {
     *     // ... data to create a DetalleLiquidacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DetalleLiquidacion we want to update
     *   }
     * })
     */
    upsert<T extends DetalleLiquidacionUpsertArgs>(args: SelectSubset<T, DetalleLiquidacionUpsertArgs<ExtArgs>>): Prisma__DetalleLiquidacionClient<$Result.GetResult<Prisma.$DetalleLiquidacionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of DetalleLiquidacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleLiquidacionCountArgs} args - Arguments to filter DetalleLiquidacions to count.
     * @example
     * // Count the number of DetalleLiquidacions
     * const count = await prisma.detalleLiquidacion.count({
     *   where: {
     *     // ... the filter for the DetalleLiquidacions we want to count
     *   }
     * })
    **/
    count<T extends DetalleLiquidacionCountArgs>(
      args?: Subset<T, DetalleLiquidacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DetalleLiquidacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DetalleLiquidacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleLiquidacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DetalleLiquidacionAggregateArgs>(args: Subset<T, DetalleLiquidacionAggregateArgs>): Prisma.PrismaPromise<GetDetalleLiquidacionAggregateType<T>>

    /**
     * Group by DetalleLiquidacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleLiquidacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DetalleLiquidacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DetalleLiquidacionGroupByArgs['orderBy'] }
        : { orderBy?: DetalleLiquidacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DetalleLiquidacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetalleLiquidacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DetalleLiquidacion model
   */
  readonly fields: DetalleLiquidacionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DetalleLiquidacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DetalleLiquidacionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    liquidacion<T extends LiquidacionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LiquidacionDefaultArgs<ExtArgs>>): Prisma__LiquidacionClient<$Result.GetResult<Prisma.$LiquidacionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    recibo<T extends DetalleLiquidacion$reciboArgs<ExtArgs> = {}>(args?: Subset<T, DetalleLiquidacion$reciboArgs<ExtArgs>>): Prisma__ReciboClient<$Result.GetResult<Prisma.$ReciboPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DetalleLiquidacion model
   */ 
  interface DetalleLiquidacionFieldRefs {
    readonly id: FieldRef<"DetalleLiquidacion", 'Int'>
    readonly liquidacionId: FieldRef<"DetalleLiquidacion", 'Int'>
    readonly reciboId: FieldRef<"DetalleLiquidacion", 'Int'>
    readonly montoOriginal: FieldRef<"DetalleLiquidacion", 'Float'>
    readonly porcentaje: FieldRef<"DetalleLiquidacion", 'Float'>
    readonly montoLiquidado: FieldRef<"DetalleLiquidacion", 'Float'>
    readonly createdAt: FieldRef<"DetalleLiquidacion", 'DateTime'>
    readonly updatedAt: FieldRef<"DetalleLiquidacion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DetalleLiquidacion findUnique
   */
  export type DetalleLiquidacionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleLiquidacion
     */
    select?: DetalleLiquidacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetalleLiquidacion
     */
    omit?: DetalleLiquidacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetalleLiquidacionInclude<ExtArgs> | null
    /**
     * Filter, which DetalleLiquidacion to fetch.
     */
    where: DetalleLiquidacionWhereUniqueInput
  }

  /**
   * DetalleLiquidacion findUniqueOrThrow
   */
  export type DetalleLiquidacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleLiquidacion
     */
    select?: DetalleLiquidacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetalleLiquidacion
     */
    omit?: DetalleLiquidacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetalleLiquidacionInclude<ExtArgs> | null
    /**
     * Filter, which DetalleLiquidacion to fetch.
     */
    where: DetalleLiquidacionWhereUniqueInput
  }

  /**
   * DetalleLiquidacion findFirst
   */
  export type DetalleLiquidacionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleLiquidacion
     */
    select?: DetalleLiquidacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetalleLiquidacion
     */
    omit?: DetalleLiquidacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetalleLiquidacionInclude<ExtArgs> | null
    /**
     * Filter, which DetalleLiquidacion to fetch.
     */
    where?: DetalleLiquidacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetalleLiquidacions to fetch.
     */
    orderBy?: DetalleLiquidacionOrderByWithRelationInput | DetalleLiquidacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetalleLiquidacions.
     */
    cursor?: DetalleLiquidacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetalleLiquidacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetalleLiquidacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetalleLiquidacions.
     */
    distinct?: DetalleLiquidacionScalarFieldEnum | DetalleLiquidacionScalarFieldEnum[]
  }

  /**
   * DetalleLiquidacion findFirstOrThrow
   */
  export type DetalleLiquidacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleLiquidacion
     */
    select?: DetalleLiquidacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetalleLiquidacion
     */
    omit?: DetalleLiquidacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetalleLiquidacionInclude<ExtArgs> | null
    /**
     * Filter, which DetalleLiquidacion to fetch.
     */
    where?: DetalleLiquidacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetalleLiquidacions to fetch.
     */
    orderBy?: DetalleLiquidacionOrderByWithRelationInput | DetalleLiquidacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetalleLiquidacions.
     */
    cursor?: DetalleLiquidacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetalleLiquidacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetalleLiquidacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetalleLiquidacions.
     */
    distinct?: DetalleLiquidacionScalarFieldEnum | DetalleLiquidacionScalarFieldEnum[]
  }

  /**
   * DetalleLiquidacion findMany
   */
  export type DetalleLiquidacionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleLiquidacion
     */
    select?: DetalleLiquidacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetalleLiquidacion
     */
    omit?: DetalleLiquidacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetalleLiquidacionInclude<ExtArgs> | null
    /**
     * Filter, which DetalleLiquidacions to fetch.
     */
    where?: DetalleLiquidacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetalleLiquidacions to fetch.
     */
    orderBy?: DetalleLiquidacionOrderByWithRelationInput | DetalleLiquidacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DetalleLiquidacions.
     */
    cursor?: DetalleLiquidacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetalleLiquidacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetalleLiquidacions.
     */
    skip?: number
    distinct?: DetalleLiquidacionScalarFieldEnum | DetalleLiquidacionScalarFieldEnum[]
  }

  /**
   * DetalleLiquidacion create
   */
  export type DetalleLiquidacionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleLiquidacion
     */
    select?: DetalleLiquidacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetalleLiquidacion
     */
    omit?: DetalleLiquidacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetalleLiquidacionInclude<ExtArgs> | null
    /**
     * The data needed to create a DetalleLiquidacion.
     */
    data: XOR<DetalleLiquidacionCreateInput, DetalleLiquidacionUncheckedCreateInput>
  }

  /**
   * DetalleLiquidacion createMany
   */
  export type DetalleLiquidacionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DetalleLiquidacions.
     */
    data: DetalleLiquidacionCreateManyInput | DetalleLiquidacionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DetalleLiquidacion createManyAndReturn
   */
  export type DetalleLiquidacionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleLiquidacion
     */
    select?: DetalleLiquidacionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DetalleLiquidacion
     */
    omit?: DetalleLiquidacionOmit<ExtArgs> | null
    /**
     * The data used to create many DetalleLiquidacions.
     */
    data: DetalleLiquidacionCreateManyInput | DetalleLiquidacionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetalleLiquidacionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DetalleLiquidacion update
   */
  export type DetalleLiquidacionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleLiquidacion
     */
    select?: DetalleLiquidacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetalleLiquidacion
     */
    omit?: DetalleLiquidacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetalleLiquidacionInclude<ExtArgs> | null
    /**
     * The data needed to update a DetalleLiquidacion.
     */
    data: XOR<DetalleLiquidacionUpdateInput, DetalleLiquidacionUncheckedUpdateInput>
    /**
     * Choose, which DetalleLiquidacion to update.
     */
    where: DetalleLiquidacionWhereUniqueInput
  }

  /**
   * DetalleLiquidacion updateMany
   */
  export type DetalleLiquidacionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DetalleLiquidacions.
     */
    data: XOR<DetalleLiquidacionUpdateManyMutationInput, DetalleLiquidacionUncheckedUpdateManyInput>
    /**
     * Filter which DetalleLiquidacions to update
     */
    where?: DetalleLiquidacionWhereInput
  }

  /**
   * DetalleLiquidacion updateManyAndReturn
   */
  export type DetalleLiquidacionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleLiquidacion
     */
    select?: DetalleLiquidacionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DetalleLiquidacion
     */
    omit?: DetalleLiquidacionOmit<ExtArgs> | null
    /**
     * The data used to update DetalleLiquidacions.
     */
    data: XOR<DetalleLiquidacionUpdateManyMutationInput, DetalleLiquidacionUncheckedUpdateManyInput>
    /**
     * Filter which DetalleLiquidacions to update
     */
    where?: DetalleLiquidacionWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetalleLiquidacionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DetalleLiquidacion upsert
   */
  export type DetalleLiquidacionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleLiquidacion
     */
    select?: DetalleLiquidacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetalleLiquidacion
     */
    omit?: DetalleLiquidacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetalleLiquidacionInclude<ExtArgs> | null
    /**
     * The filter to search for the DetalleLiquidacion to update in case it exists.
     */
    where: DetalleLiquidacionWhereUniqueInput
    /**
     * In case the DetalleLiquidacion found by the `where` argument doesn't exist, create a new DetalleLiquidacion with this data.
     */
    create: XOR<DetalleLiquidacionCreateInput, DetalleLiquidacionUncheckedCreateInput>
    /**
     * In case the DetalleLiquidacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DetalleLiquidacionUpdateInput, DetalleLiquidacionUncheckedUpdateInput>
  }

  /**
   * DetalleLiquidacion delete
   */
  export type DetalleLiquidacionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleLiquidacion
     */
    select?: DetalleLiquidacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetalleLiquidacion
     */
    omit?: DetalleLiquidacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetalleLiquidacionInclude<ExtArgs> | null
    /**
     * Filter which DetalleLiquidacion to delete.
     */
    where: DetalleLiquidacionWhereUniqueInput
  }

  /**
   * DetalleLiquidacion deleteMany
   */
  export type DetalleLiquidacionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetalleLiquidacions to delete
     */
    where?: DetalleLiquidacionWhereInput
  }

  /**
   * DetalleLiquidacion.recibo
   */
  export type DetalleLiquidacion$reciboArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recibo
     */
    select?: ReciboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recibo
     */
    omit?: ReciboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReciboInclude<ExtArgs> | null
    where?: ReciboWhereInput
  }

  /**
   * DetalleLiquidacion without action
   */
  export type DetalleLiquidacionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleLiquidacion
     */
    select?: DetalleLiquidacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetalleLiquidacion
     */
    omit?: DetalleLiquidacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetalleLiquidacionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AlumnoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    apellido: 'apellido',
    dni: 'dni',
    activo: 'activo',
    fechaNacimiento: 'fechaNacimiento',
    email: 'email',
    telefono: 'telefono',
    numeroEmergencia: 'numeroEmergencia',
    direccion: 'direccion',
    obraSocial: 'obraSocial',
    nombreTutor: 'nombreTutor',
    dniTutor: 'dniTutor',
    notas: 'notas',
    fechaIngreso: 'fechaIngreso',
    fechaBaja: 'fechaBaja',
    motivoBaja: 'motivoBaja',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AlumnoScalarFieldEnum = (typeof AlumnoScalarFieldEnum)[keyof typeof AlumnoScalarFieldEnum]


  export const ConfiguracionPagoAlumnoScalarFieldEnum: {
    id: 'id',
    alumnoId: 'alumnoId',
    diaPago: 'diaPago',
    metodoPago: 'metodoPago',
    descuentoFijo: 'descuentoFijo',
    observaciones: 'observaciones',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConfiguracionPagoAlumnoScalarFieldEnum = (typeof ConfiguracionPagoAlumnoScalarFieldEnum)[keyof typeof ConfiguracionPagoAlumnoScalarFieldEnum]


  export const DescuentoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    porcentaje: 'porcentaje',
    activo: 'activo',
    esAutomatico: 'esAutomatico',
    minEstilos: 'minEstilos',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DescuentoScalarFieldEnum = (typeof DescuentoScalarFieldEnum)[keyof typeof DescuentoScalarFieldEnum]


  export const DescuentoAplicadoScalarFieldEnum: {
    id: 'id',
    descuentoId: 'descuentoId',
    alumnoId: 'alumnoId',
    fechaInicio: 'fechaInicio',
    fechaFin: 'fechaFin',
    activo: 'activo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DescuentoAplicadoScalarFieldEnum = (typeof DescuentoAplicadoScalarFieldEnum)[keyof typeof DescuentoAplicadoScalarFieldEnum]


  export const DeudaScalarFieldEnum: {
    id: 'id',
    alumnoId: 'alumnoId',
    monto: 'monto',
    montoOriginal: 'montoOriginal',
    mes: 'mes',
    anio: 'anio',
    estiloId: 'estiloId',
    pagada: 'pagada',
    fechaPago: 'fechaPago',
    fechaVencimiento: 'fechaVencimiento',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeudaScalarFieldEnum = (typeof DeudaScalarFieldEnum)[keyof typeof DeudaScalarFieldEnum]


  export const PagoDeudaScalarFieldEnum: {
    id: 'id',
    deudaId: 'deudaId',
    reciboId: 'reciboId',
    monto: 'monto',
    fecha: 'fecha',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PagoDeudaScalarFieldEnum = (typeof PagoDeudaScalarFieldEnum)[keyof typeof PagoDeudaScalarFieldEnum]


  export const ConceptoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    monto: 'monto',
    estiloId: 'estiloId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConceptoScalarFieldEnum = (typeof ConceptoScalarFieldEnum)[keyof typeof ConceptoScalarFieldEnum]


  export const ReciboScalarFieldEnum: {
    id: 'id',
    numeroRecibo: 'numeroRecibo',
    fecha: 'fecha',
    fechaEfecto: 'fechaEfecto',
    monto: 'monto',
    montoOriginal: 'montoOriginal',
    descuento: 'descuento',
    periodoPago: 'periodoPago',
    tipoPago: 'tipoPago',
    fueraDeTermino: 'fueraDeTermino',
    esClaseSuelta: 'esClaseSuelta',
    esMesCompleto: 'esMesCompleto',
    alumnoId: 'alumnoId',
    alumnoSueltoId: 'alumnoSueltoId',
    conceptoId: 'conceptoId',
    claseId: 'claseId',
    anulado: 'anulado',
    motivoAnulacion: 'motivoAnulacion',
    referenciaRecibo: 'referenciaRecibo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReciboScalarFieldEnum = (typeof ReciboScalarFieldEnum)[keyof typeof ReciboScalarFieldEnum]


  export const EstiloScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    monto: 'monto',
    descripcion: 'descripcion',
    importe: 'importe',
    profesorId: 'profesorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EstiloScalarFieldEnum = (typeof EstiloScalarFieldEnum)[keyof typeof EstiloScalarFieldEnum]


  export const AlumnoEstilosScalarFieldEnum: {
    id: 'id',
    alumnoId: 'alumnoId',
    estiloId: 'estiloId',
    activo: 'activo',
    fechaInicio: 'fechaInicio',
    fechaFin: 'fechaFin',
    montoPersonalizado: 'montoPersonalizado',
    descuentoPersonalizado: 'descuentoPersonalizado',
    observaciones: 'observaciones'
  };

  export type AlumnoEstilosScalarFieldEnum = (typeof AlumnoEstilosScalarFieldEnum)[keyof typeof AlumnoEstilosScalarFieldEnum]


  export const ProfesorScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    apellido: 'apellido',
    dni: 'dni',
    fechaNacimiento: 'fechaNacimiento',
    direccion: 'direccion',
    cuit: 'cuit',
    email: 'email',
    telefono: 'telefono',
    fechaIngreso: 'fechaIngreso',
    porcentajePorDefecto: 'porcentajePorDefecto',
    porcentajeClasesSueltasPorDefecto: 'porcentajeClasesSueltasPorDefecto',
    activo: 'activo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfesorScalarFieldEnum = (typeof ProfesorScalarFieldEnum)[keyof typeof ProfesorScalarFieldEnum]


  export const CtaCteScalarFieldEnum: {
    id: 'id',
    saldo: 'saldo',
    alumnoId: 'alumnoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CtaCteScalarFieldEnum = (typeof CtaCteScalarFieldEnum)[keyof typeof CtaCteScalarFieldEnum]


  export const CajaDiariaScalarFieldEnum: {
    id: 'id',
    fecha: 'fecha',
    apertura: 'apertura',
    cierre: 'cierre',
    diferencia: 'diferencia',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CajaDiariaScalarFieldEnum = (typeof CajaDiariaScalarFieldEnum)[keyof typeof CajaDiariaScalarFieldEnum]


  export const ClaseScalarFieldEnum: {
    id: 'id',
    fecha: 'fecha',
    profesorId: 'profesorId',
    estiloId: 'estiloId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClaseScalarFieldEnum = (typeof ClaseScalarFieldEnum)[keyof typeof ClaseScalarFieldEnum]


  export const AsistenciaScalarFieldEnum: {
    id: 'id',
    claseId: 'claseId',
    alumnoId: 'alumnoId',
    asistio: 'asistio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AsistenciaScalarFieldEnum = (typeof AsistenciaScalarFieldEnum)[keyof typeof AsistenciaScalarFieldEnum]


  export const AlumnoSueltoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    apellido: 'apellido',
    dni: 'dni',
    telefono: 'telefono',
    email: 'email',
    alumnoRegularId: 'alumnoRegularId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AlumnoSueltoScalarFieldEnum = (typeof AlumnoSueltoScalarFieldEnum)[keyof typeof AlumnoSueltoScalarFieldEnum]


  export const LiquidacionScalarFieldEnum: {
    id: 'id',
    fecha: 'fecha',
    mes: 'mes',
    anio: 'anio',
    profesorId: 'profesorId',
    montoTotal: 'montoTotal',
    montoCursos: 'montoCursos',
    montoClasesSueltas: 'montoClasesSueltas',
    porcentajeCursos: 'porcentajeCursos',
    porcentajeClasesSueltas: 'porcentajeClasesSueltas',
    estado: 'estado',
    metodoPago: 'metodoPago',
    fechaPago: 'fechaPago',
    observaciones: 'observaciones',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LiquidacionScalarFieldEnum = (typeof LiquidacionScalarFieldEnum)[keyof typeof LiquidacionScalarFieldEnum]


  export const DetalleLiquidacionScalarFieldEnum: {
    id: 'id',
    liquidacionId: 'liquidacionId',
    reciboId: 'reciboId',
    montoOriginal: 'montoOriginal',
    porcentaje: 'porcentaje',
    montoLiquidado: 'montoLiquidado',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DetalleLiquidacionScalarFieldEnum = (typeof DetalleLiquidacionScalarFieldEnum)[keyof typeof DetalleLiquidacionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'TipoPago'
   */
  export type EnumTipoPagoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoPago'>
    


  /**
   * Reference to a field of type 'TipoPago[]'
   */
  export type ListEnumTipoPagoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoPago[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'EstadoLiquidacion'
   */
  export type EnumEstadoLiquidacionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoLiquidacion'>
    


  /**
   * Reference to a field of type 'EstadoLiquidacion[]'
   */
  export type ListEnumEstadoLiquidacionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoLiquidacion[]'>
    
  /**
   * Deep Input Types
   */


  export type AlumnoWhereInput = {
    AND?: AlumnoWhereInput | AlumnoWhereInput[]
    OR?: AlumnoWhereInput[]
    NOT?: AlumnoWhereInput | AlumnoWhereInput[]
    id?: IntFilter<"Alumno"> | number
    nombre?: StringFilter<"Alumno"> | string
    apellido?: StringFilter<"Alumno"> | string
    dni?: StringFilter<"Alumno"> | string
    activo?: BoolFilter<"Alumno"> | boolean
    fechaNacimiento?: DateTimeFilter<"Alumno"> | Date | string
    email?: StringNullableFilter<"Alumno"> | string | null
    telefono?: StringNullableFilter<"Alumno"> | string | null
    numeroEmergencia?: StringNullableFilter<"Alumno"> | string | null
    direccion?: StringNullableFilter<"Alumno"> | string | null
    obraSocial?: StringNullableFilter<"Alumno"> | string | null
    nombreTutor?: StringNullableFilter<"Alumno"> | string | null
    dniTutor?: StringNullableFilter<"Alumno"> | string | null
    notas?: StringNullableFilter<"Alumno"> | string | null
    fechaIngreso?: DateTimeFilter<"Alumno"> | Date | string
    fechaBaja?: DateTimeNullableFilter<"Alumno"> | Date | string | null
    motivoBaja?: StringNullableFilter<"Alumno"> | string | null
    createdAt?: DateTimeFilter<"Alumno"> | Date | string
    updatedAt?: DateTimeFilter<"Alumno"> | Date | string
    recibos?: ReciboListRelationFilter
    alumnosSueltosAnteriores?: AlumnoSueltoListRelationFilter
    ctaCte?: XOR<CtaCteNullableScalarRelationFilter, CtaCteWhereInput> | null
    estilos?: EstiloListRelationFilter
    asistencias?: AsistenciaListRelationFilter
    alumnoEstilos?: AlumnoEstilosListRelationFilter
    deudas?: DeudaListRelationFilter
    descuentosVigentes?: DescuentoAplicadoListRelationFilter
    configuracionPago?: XOR<ConfiguracionPagoAlumnoNullableScalarRelationFilter, ConfiguracionPagoAlumnoWhereInput> | null
  }

  export type AlumnoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    activo?: SortOrder
    fechaNacimiento?: SortOrder
    email?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    numeroEmergencia?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    obraSocial?: SortOrderInput | SortOrder
    nombreTutor?: SortOrderInput | SortOrder
    dniTutor?: SortOrderInput | SortOrder
    notas?: SortOrderInput | SortOrder
    fechaIngreso?: SortOrder
    fechaBaja?: SortOrderInput | SortOrder
    motivoBaja?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    recibos?: ReciboOrderByRelationAggregateInput
    alumnosSueltosAnteriores?: AlumnoSueltoOrderByRelationAggregateInput
    ctaCte?: CtaCteOrderByWithRelationInput
    estilos?: EstiloOrderByRelationAggregateInput
    asistencias?: AsistenciaOrderByRelationAggregateInput
    alumnoEstilos?: AlumnoEstilosOrderByRelationAggregateInput
    deudas?: DeudaOrderByRelationAggregateInput
    descuentosVigentes?: DescuentoAplicadoOrderByRelationAggregateInput
    configuracionPago?: ConfiguracionPagoAlumnoOrderByWithRelationInput
  }

  export type AlumnoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    dni?: string
    AND?: AlumnoWhereInput | AlumnoWhereInput[]
    OR?: AlumnoWhereInput[]
    NOT?: AlumnoWhereInput | AlumnoWhereInput[]
    nombre?: StringFilter<"Alumno"> | string
    apellido?: StringFilter<"Alumno"> | string
    activo?: BoolFilter<"Alumno"> | boolean
    fechaNacimiento?: DateTimeFilter<"Alumno"> | Date | string
    email?: StringNullableFilter<"Alumno"> | string | null
    telefono?: StringNullableFilter<"Alumno"> | string | null
    numeroEmergencia?: StringNullableFilter<"Alumno"> | string | null
    direccion?: StringNullableFilter<"Alumno"> | string | null
    obraSocial?: StringNullableFilter<"Alumno"> | string | null
    nombreTutor?: StringNullableFilter<"Alumno"> | string | null
    dniTutor?: StringNullableFilter<"Alumno"> | string | null
    notas?: StringNullableFilter<"Alumno"> | string | null
    fechaIngreso?: DateTimeFilter<"Alumno"> | Date | string
    fechaBaja?: DateTimeNullableFilter<"Alumno"> | Date | string | null
    motivoBaja?: StringNullableFilter<"Alumno"> | string | null
    createdAt?: DateTimeFilter<"Alumno"> | Date | string
    updatedAt?: DateTimeFilter<"Alumno"> | Date | string
    recibos?: ReciboListRelationFilter
    alumnosSueltosAnteriores?: AlumnoSueltoListRelationFilter
    ctaCte?: XOR<CtaCteNullableScalarRelationFilter, CtaCteWhereInput> | null
    estilos?: EstiloListRelationFilter
    asistencias?: AsistenciaListRelationFilter
    alumnoEstilos?: AlumnoEstilosListRelationFilter
    deudas?: DeudaListRelationFilter
    descuentosVigentes?: DescuentoAplicadoListRelationFilter
    configuracionPago?: XOR<ConfiguracionPagoAlumnoNullableScalarRelationFilter, ConfiguracionPagoAlumnoWhereInput> | null
  }, "id" | "dni">

  export type AlumnoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    activo?: SortOrder
    fechaNacimiento?: SortOrder
    email?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    numeroEmergencia?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    obraSocial?: SortOrderInput | SortOrder
    nombreTutor?: SortOrderInput | SortOrder
    dniTutor?: SortOrderInput | SortOrder
    notas?: SortOrderInput | SortOrder
    fechaIngreso?: SortOrder
    fechaBaja?: SortOrderInput | SortOrder
    motivoBaja?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AlumnoCountOrderByAggregateInput
    _avg?: AlumnoAvgOrderByAggregateInput
    _max?: AlumnoMaxOrderByAggregateInput
    _min?: AlumnoMinOrderByAggregateInput
    _sum?: AlumnoSumOrderByAggregateInput
  }

  export type AlumnoScalarWhereWithAggregatesInput = {
    AND?: AlumnoScalarWhereWithAggregatesInput | AlumnoScalarWhereWithAggregatesInput[]
    OR?: AlumnoScalarWhereWithAggregatesInput[]
    NOT?: AlumnoScalarWhereWithAggregatesInput | AlumnoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Alumno"> | number
    nombre?: StringWithAggregatesFilter<"Alumno"> | string
    apellido?: StringWithAggregatesFilter<"Alumno"> | string
    dni?: StringWithAggregatesFilter<"Alumno"> | string
    activo?: BoolWithAggregatesFilter<"Alumno"> | boolean
    fechaNacimiento?: DateTimeWithAggregatesFilter<"Alumno"> | Date | string
    email?: StringNullableWithAggregatesFilter<"Alumno"> | string | null
    telefono?: StringNullableWithAggregatesFilter<"Alumno"> | string | null
    numeroEmergencia?: StringNullableWithAggregatesFilter<"Alumno"> | string | null
    direccion?: StringNullableWithAggregatesFilter<"Alumno"> | string | null
    obraSocial?: StringNullableWithAggregatesFilter<"Alumno"> | string | null
    nombreTutor?: StringNullableWithAggregatesFilter<"Alumno"> | string | null
    dniTutor?: StringNullableWithAggregatesFilter<"Alumno"> | string | null
    notas?: StringNullableWithAggregatesFilter<"Alumno"> | string | null
    fechaIngreso?: DateTimeWithAggregatesFilter<"Alumno"> | Date | string
    fechaBaja?: DateTimeNullableWithAggregatesFilter<"Alumno"> | Date | string | null
    motivoBaja?: StringNullableWithAggregatesFilter<"Alumno"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Alumno"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Alumno"> | Date | string
  }

  export type ConfiguracionPagoAlumnoWhereInput = {
    AND?: ConfiguracionPagoAlumnoWhereInput | ConfiguracionPagoAlumnoWhereInput[]
    OR?: ConfiguracionPagoAlumnoWhereInput[]
    NOT?: ConfiguracionPagoAlumnoWhereInput | ConfiguracionPagoAlumnoWhereInput[]
    id?: IntFilter<"ConfiguracionPagoAlumno"> | number
    alumnoId?: IntFilter<"ConfiguracionPagoAlumno"> | number
    diaPago?: IntNullableFilter<"ConfiguracionPagoAlumno"> | number | null
    metodoPago?: EnumTipoPagoFilter<"ConfiguracionPagoAlumno"> | $Enums.TipoPago
    descuentoFijo?: FloatNullableFilter<"ConfiguracionPagoAlumno"> | number | null
    observaciones?: StringNullableFilter<"ConfiguracionPagoAlumno"> | string | null
    createdAt?: DateTimeFilter<"ConfiguracionPagoAlumno"> | Date | string
    updatedAt?: DateTimeFilter<"ConfiguracionPagoAlumno"> | Date | string
    alumno?: XOR<AlumnoScalarRelationFilter, AlumnoWhereInput>
  }

  export type ConfiguracionPagoAlumnoOrderByWithRelationInput = {
    id?: SortOrder
    alumnoId?: SortOrder
    diaPago?: SortOrderInput | SortOrder
    metodoPago?: SortOrder
    descuentoFijo?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    alumno?: AlumnoOrderByWithRelationInput
  }

  export type ConfiguracionPagoAlumnoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    alumnoId?: number
    AND?: ConfiguracionPagoAlumnoWhereInput | ConfiguracionPagoAlumnoWhereInput[]
    OR?: ConfiguracionPagoAlumnoWhereInput[]
    NOT?: ConfiguracionPagoAlumnoWhereInput | ConfiguracionPagoAlumnoWhereInput[]
    diaPago?: IntNullableFilter<"ConfiguracionPagoAlumno"> | number | null
    metodoPago?: EnumTipoPagoFilter<"ConfiguracionPagoAlumno"> | $Enums.TipoPago
    descuentoFijo?: FloatNullableFilter<"ConfiguracionPagoAlumno"> | number | null
    observaciones?: StringNullableFilter<"ConfiguracionPagoAlumno"> | string | null
    createdAt?: DateTimeFilter<"ConfiguracionPagoAlumno"> | Date | string
    updatedAt?: DateTimeFilter<"ConfiguracionPagoAlumno"> | Date | string
    alumno?: XOR<AlumnoScalarRelationFilter, AlumnoWhereInput>
  }, "id" | "alumnoId">

  export type ConfiguracionPagoAlumnoOrderByWithAggregationInput = {
    id?: SortOrder
    alumnoId?: SortOrder
    diaPago?: SortOrderInput | SortOrder
    metodoPago?: SortOrder
    descuentoFijo?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConfiguracionPagoAlumnoCountOrderByAggregateInput
    _avg?: ConfiguracionPagoAlumnoAvgOrderByAggregateInput
    _max?: ConfiguracionPagoAlumnoMaxOrderByAggregateInput
    _min?: ConfiguracionPagoAlumnoMinOrderByAggregateInput
    _sum?: ConfiguracionPagoAlumnoSumOrderByAggregateInput
  }

  export type ConfiguracionPagoAlumnoScalarWhereWithAggregatesInput = {
    AND?: ConfiguracionPagoAlumnoScalarWhereWithAggregatesInput | ConfiguracionPagoAlumnoScalarWhereWithAggregatesInput[]
    OR?: ConfiguracionPagoAlumnoScalarWhereWithAggregatesInput[]
    NOT?: ConfiguracionPagoAlumnoScalarWhereWithAggregatesInput | ConfiguracionPagoAlumnoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ConfiguracionPagoAlumno"> | number
    alumnoId?: IntWithAggregatesFilter<"ConfiguracionPagoAlumno"> | number
    diaPago?: IntNullableWithAggregatesFilter<"ConfiguracionPagoAlumno"> | number | null
    metodoPago?: EnumTipoPagoWithAggregatesFilter<"ConfiguracionPagoAlumno"> | $Enums.TipoPago
    descuentoFijo?: FloatNullableWithAggregatesFilter<"ConfiguracionPagoAlumno"> | number | null
    observaciones?: StringNullableWithAggregatesFilter<"ConfiguracionPagoAlumno"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ConfiguracionPagoAlumno"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConfiguracionPagoAlumno"> | Date | string
  }

  export type DescuentoWhereInput = {
    AND?: DescuentoWhereInput | DescuentoWhereInput[]
    OR?: DescuentoWhereInput[]
    NOT?: DescuentoWhereInput | DescuentoWhereInput[]
    id?: IntFilter<"Descuento"> | number
    nombre?: StringFilter<"Descuento"> | string
    porcentaje?: FloatFilter<"Descuento"> | number
    activo?: BoolFilter<"Descuento"> | boolean
    esAutomatico?: BoolFilter<"Descuento"> | boolean
    minEstilos?: IntNullableFilter<"Descuento"> | number | null
    createdAt?: DateTimeFilter<"Descuento"> | Date | string
    updatedAt?: DateTimeFilter<"Descuento"> | Date | string
    aplicadoA?: DescuentoAplicadoListRelationFilter
  }

  export type DescuentoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    porcentaje?: SortOrder
    activo?: SortOrder
    esAutomatico?: SortOrder
    minEstilos?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aplicadoA?: DescuentoAplicadoOrderByRelationAggregateInput
  }

  export type DescuentoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DescuentoWhereInput | DescuentoWhereInput[]
    OR?: DescuentoWhereInput[]
    NOT?: DescuentoWhereInput | DescuentoWhereInput[]
    nombre?: StringFilter<"Descuento"> | string
    porcentaje?: FloatFilter<"Descuento"> | number
    activo?: BoolFilter<"Descuento"> | boolean
    esAutomatico?: BoolFilter<"Descuento"> | boolean
    minEstilos?: IntNullableFilter<"Descuento"> | number | null
    createdAt?: DateTimeFilter<"Descuento"> | Date | string
    updatedAt?: DateTimeFilter<"Descuento"> | Date | string
    aplicadoA?: DescuentoAplicadoListRelationFilter
  }, "id">

  export type DescuentoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    porcentaje?: SortOrder
    activo?: SortOrder
    esAutomatico?: SortOrder
    minEstilos?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DescuentoCountOrderByAggregateInput
    _avg?: DescuentoAvgOrderByAggregateInput
    _max?: DescuentoMaxOrderByAggregateInput
    _min?: DescuentoMinOrderByAggregateInput
    _sum?: DescuentoSumOrderByAggregateInput
  }

  export type DescuentoScalarWhereWithAggregatesInput = {
    AND?: DescuentoScalarWhereWithAggregatesInput | DescuentoScalarWhereWithAggregatesInput[]
    OR?: DescuentoScalarWhereWithAggregatesInput[]
    NOT?: DescuentoScalarWhereWithAggregatesInput | DescuentoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Descuento"> | number
    nombre?: StringWithAggregatesFilter<"Descuento"> | string
    porcentaje?: FloatWithAggregatesFilter<"Descuento"> | number
    activo?: BoolWithAggregatesFilter<"Descuento"> | boolean
    esAutomatico?: BoolWithAggregatesFilter<"Descuento"> | boolean
    minEstilos?: IntNullableWithAggregatesFilter<"Descuento"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Descuento"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Descuento"> | Date | string
  }

  export type DescuentoAplicadoWhereInput = {
    AND?: DescuentoAplicadoWhereInput | DescuentoAplicadoWhereInput[]
    OR?: DescuentoAplicadoWhereInput[]
    NOT?: DescuentoAplicadoWhereInput | DescuentoAplicadoWhereInput[]
    id?: IntFilter<"DescuentoAplicado"> | number
    descuentoId?: IntFilter<"DescuentoAplicado"> | number
    alumnoId?: IntFilter<"DescuentoAplicado"> | number
    fechaInicio?: DateTimeFilter<"DescuentoAplicado"> | Date | string
    fechaFin?: DateTimeNullableFilter<"DescuentoAplicado"> | Date | string | null
    activo?: BoolFilter<"DescuentoAplicado"> | boolean
    createdAt?: DateTimeFilter<"DescuentoAplicado"> | Date | string
    updatedAt?: DateTimeFilter<"DescuentoAplicado"> | Date | string
    descuento?: XOR<DescuentoScalarRelationFilter, DescuentoWhereInput>
    alumno?: XOR<AlumnoScalarRelationFilter, AlumnoWhereInput>
  }

  export type DescuentoAplicadoOrderByWithRelationInput = {
    id?: SortOrder
    descuentoId?: SortOrder
    alumnoId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrderInput | SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    descuento?: DescuentoOrderByWithRelationInput
    alumno?: AlumnoOrderByWithRelationInput
  }

  export type DescuentoAplicadoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DescuentoAplicadoWhereInput | DescuentoAplicadoWhereInput[]
    OR?: DescuentoAplicadoWhereInput[]
    NOT?: DescuentoAplicadoWhereInput | DescuentoAplicadoWhereInput[]
    descuentoId?: IntFilter<"DescuentoAplicado"> | number
    alumnoId?: IntFilter<"DescuentoAplicado"> | number
    fechaInicio?: DateTimeFilter<"DescuentoAplicado"> | Date | string
    fechaFin?: DateTimeNullableFilter<"DescuentoAplicado"> | Date | string | null
    activo?: BoolFilter<"DescuentoAplicado"> | boolean
    createdAt?: DateTimeFilter<"DescuentoAplicado"> | Date | string
    updatedAt?: DateTimeFilter<"DescuentoAplicado"> | Date | string
    descuento?: XOR<DescuentoScalarRelationFilter, DescuentoWhereInput>
    alumno?: XOR<AlumnoScalarRelationFilter, AlumnoWhereInput>
  }, "id">

  export type DescuentoAplicadoOrderByWithAggregationInput = {
    id?: SortOrder
    descuentoId?: SortOrder
    alumnoId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrderInput | SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DescuentoAplicadoCountOrderByAggregateInput
    _avg?: DescuentoAplicadoAvgOrderByAggregateInput
    _max?: DescuentoAplicadoMaxOrderByAggregateInput
    _min?: DescuentoAplicadoMinOrderByAggregateInput
    _sum?: DescuentoAplicadoSumOrderByAggregateInput
  }

  export type DescuentoAplicadoScalarWhereWithAggregatesInput = {
    AND?: DescuentoAplicadoScalarWhereWithAggregatesInput | DescuentoAplicadoScalarWhereWithAggregatesInput[]
    OR?: DescuentoAplicadoScalarWhereWithAggregatesInput[]
    NOT?: DescuentoAplicadoScalarWhereWithAggregatesInput | DescuentoAplicadoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DescuentoAplicado"> | number
    descuentoId?: IntWithAggregatesFilter<"DescuentoAplicado"> | number
    alumnoId?: IntWithAggregatesFilter<"DescuentoAplicado"> | number
    fechaInicio?: DateTimeWithAggregatesFilter<"DescuentoAplicado"> | Date | string
    fechaFin?: DateTimeNullableWithAggregatesFilter<"DescuentoAplicado"> | Date | string | null
    activo?: BoolWithAggregatesFilter<"DescuentoAplicado"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DescuentoAplicado"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DescuentoAplicado"> | Date | string
  }

  export type DeudaWhereInput = {
    AND?: DeudaWhereInput | DeudaWhereInput[]
    OR?: DeudaWhereInput[]
    NOT?: DeudaWhereInput | DeudaWhereInput[]
    id?: IntFilter<"Deuda"> | number
    alumnoId?: IntFilter<"Deuda"> | number
    monto?: FloatFilter<"Deuda"> | number
    montoOriginal?: FloatFilter<"Deuda"> | number
    mes?: StringFilter<"Deuda"> | string
    anio?: IntFilter<"Deuda"> | number
    estiloId?: IntFilter<"Deuda"> | number
    pagada?: BoolFilter<"Deuda"> | boolean
    fechaPago?: DateTimeNullableFilter<"Deuda"> | Date | string | null
    fechaVencimiento?: DateTimeFilter<"Deuda"> | Date | string
    createdAt?: DateTimeFilter<"Deuda"> | Date | string
    updatedAt?: DateTimeFilter<"Deuda"> | Date | string
    alumno?: XOR<AlumnoScalarRelationFilter, AlumnoWhereInput>
    estilo?: XOR<EstiloScalarRelationFilter, EstiloWhereInput>
    pagos?: PagoDeudaListRelationFilter
  }

  export type DeudaOrderByWithRelationInput = {
    id?: SortOrder
    alumnoId?: SortOrder
    monto?: SortOrder
    montoOriginal?: SortOrder
    mes?: SortOrder
    anio?: SortOrder
    estiloId?: SortOrder
    pagada?: SortOrder
    fechaPago?: SortOrderInput | SortOrder
    fechaVencimiento?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    alumno?: AlumnoOrderByWithRelationInput
    estilo?: EstiloOrderByWithRelationInput
    pagos?: PagoDeudaOrderByRelationAggregateInput
  }

  export type DeudaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DeudaWhereInput | DeudaWhereInput[]
    OR?: DeudaWhereInput[]
    NOT?: DeudaWhereInput | DeudaWhereInput[]
    alumnoId?: IntFilter<"Deuda"> | number
    monto?: FloatFilter<"Deuda"> | number
    montoOriginal?: FloatFilter<"Deuda"> | number
    mes?: StringFilter<"Deuda"> | string
    anio?: IntFilter<"Deuda"> | number
    estiloId?: IntFilter<"Deuda"> | number
    pagada?: BoolFilter<"Deuda"> | boolean
    fechaPago?: DateTimeNullableFilter<"Deuda"> | Date | string | null
    fechaVencimiento?: DateTimeFilter<"Deuda"> | Date | string
    createdAt?: DateTimeFilter<"Deuda"> | Date | string
    updatedAt?: DateTimeFilter<"Deuda"> | Date | string
    alumno?: XOR<AlumnoScalarRelationFilter, AlumnoWhereInput>
    estilo?: XOR<EstiloScalarRelationFilter, EstiloWhereInput>
    pagos?: PagoDeudaListRelationFilter
  }, "id">

  export type DeudaOrderByWithAggregationInput = {
    id?: SortOrder
    alumnoId?: SortOrder
    monto?: SortOrder
    montoOriginal?: SortOrder
    mes?: SortOrder
    anio?: SortOrder
    estiloId?: SortOrder
    pagada?: SortOrder
    fechaPago?: SortOrderInput | SortOrder
    fechaVencimiento?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeudaCountOrderByAggregateInput
    _avg?: DeudaAvgOrderByAggregateInput
    _max?: DeudaMaxOrderByAggregateInput
    _min?: DeudaMinOrderByAggregateInput
    _sum?: DeudaSumOrderByAggregateInput
  }

  export type DeudaScalarWhereWithAggregatesInput = {
    AND?: DeudaScalarWhereWithAggregatesInput | DeudaScalarWhereWithAggregatesInput[]
    OR?: DeudaScalarWhereWithAggregatesInput[]
    NOT?: DeudaScalarWhereWithAggregatesInput | DeudaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Deuda"> | number
    alumnoId?: IntWithAggregatesFilter<"Deuda"> | number
    monto?: FloatWithAggregatesFilter<"Deuda"> | number
    montoOriginal?: FloatWithAggregatesFilter<"Deuda"> | number
    mes?: StringWithAggregatesFilter<"Deuda"> | string
    anio?: IntWithAggregatesFilter<"Deuda"> | number
    estiloId?: IntWithAggregatesFilter<"Deuda"> | number
    pagada?: BoolWithAggregatesFilter<"Deuda"> | boolean
    fechaPago?: DateTimeNullableWithAggregatesFilter<"Deuda"> | Date | string | null
    fechaVencimiento?: DateTimeWithAggregatesFilter<"Deuda"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Deuda"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Deuda"> | Date | string
  }

  export type PagoDeudaWhereInput = {
    AND?: PagoDeudaWhereInput | PagoDeudaWhereInput[]
    OR?: PagoDeudaWhereInput[]
    NOT?: PagoDeudaWhereInput | PagoDeudaWhereInput[]
    id?: IntFilter<"PagoDeuda"> | number
    deudaId?: IntFilter<"PagoDeuda"> | number
    reciboId?: IntFilter<"PagoDeuda"> | number
    monto?: FloatFilter<"PagoDeuda"> | number
    fecha?: DateTimeFilter<"PagoDeuda"> | Date | string
    createdAt?: DateTimeFilter<"PagoDeuda"> | Date | string
    updatedAt?: DateTimeFilter<"PagoDeuda"> | Date | string
    deuda?: XOR<DeudaScalarRelationFilter, DeudaWhereInput>
    recibo?: XOR<ReciboScalarRelationFilter, ReciboWhereInput>
  }

  export type PagoDeudaOrderByWithRelationInput = {
    id?: SortOrder
    deudaId?: SortOrder
    reciboId?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deuda?: DeudaOrderByWithRelationInput
    recibo?: ReciboOrderByWithRelationInput
  }

  export type PagoDeudaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PagoDeudaWhereInput | PagoDeudaWhereInput[]
    OR?: PagoDeudaWhereInput[]
    NOT?: PagoDeudaWhereInput | PagoDeudaWhereInput[]
    deudaId?: IntFilter<"PagoDeuda"> | number
    reciboId?: IntFilter<"PagoDeuda"> | number
    monto?: FloatFilter<"PagoDeuda"> | number
    fecha?: DateTimeFilter<"PagoDeuda"> | Date | string
    createdAt?: DateTimeFilter<"PagoDeuda"> | Date | string
    updatedAt?: DateTimeFilter<"PagoDeuda"> | Date | string
    deuda?: XOR<DeudaScalarRelationFilter, DeudaWhereInput>
    recibo?: XOR<ReciboScalarRelationFilter, ReciboWhereInput>
  }, "id">

  export type PagoDeudaOrderByWithAggregationInput = {
    id?: SortOrder
    deudaId?: SortOrder
    reciboId?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PagoDeudaCountOrderByAggregateInput
    _avg?: PagoDeudaAvgOrderByAggregateInput
    _max?: PagoDeudaMaxOrderByAggregateInput
    _min?: PagoDeudaMinOrderByAggregateInput
    _sum?: PagoDeudaSumOrderByAggregateInput
  }

  export type PagoDeudaScalarWhereWithAggregatesInput = {
    AND?: PagoDeudaScalarWhereWithAggregatesInput | PagoDeudaScalarWhereWithAggregatesInput[]
    OR?: PagoDeudaScalarWhereWithAggregatesInput[]
    NOT?: PagoDeudaScalarWhereWithAggregatesInput | PagoDeudaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PagoDeuda"> | number
    deudaId?: IntWithAggregatesFilter<"PagoDeuda"> | number
    reciboId?: IntWithAggregatesFilter<"PagoDeuda"> | number
    monto?: FloatWithAggregatesFilter<"PagoDeuda"> | number
    fecha?: DateTimeWithAggregatesFilter<"PagoDeuda"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"PagoDeuda"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PagoDeuda"> | Date | string
  }

  export type ConceptoWhereInput = {
    AND?: ConceptoWhereInput | ConceptoWhereInput[]
    OR?: ConceptoWhereInput[]
    NOT?: ConceptoWhereInput | ConceptoWhereInput[]
    id?: IntFilter<"Concepto"> | number
    nombre?: StringFilter<"Concepto"> | string
    descripcion?: StringNullableFilter<"Concepto"> | string | null
    monto?: FloatFilter<"Concepto"> | number
    estiloId?: IntNullableFilter<"Concepto"> | number | null
    createdAt?: DateTimeFilter<"Concepto"> | Date | string
    updatedAt?: DateTimeFilter<"Concepto"> | Date | string
    estilo?: XOR<EstiloNullableScalarRelationFilter, EstiloWhereInput> | null
    recibos?: ReciboListRelationFilter
  }

  export type ConceptoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    monto?: SortOrder
    estiloId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    estilo?: EstiloOrderByWithRelationInput
    recibos?: ReciboOrderByRelationAggregateInput
  }

  export type ConceptoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ConceptoWhereInput | ConceptoWhereInput[]
    OR?: ConceptoWhereInput[]
    NOT?: ConceptoWhereInput | ConceptoWhereInput[]
    nombre?: StringFilter<"Concepto"> | string
    descripcion?: StringNullableFilter<"Concepto"> | string | null
    monto?: FloatFilter<"Concepto"> | number
    estiloId?: IntNullableFilter<"Concepto"> | number | null
    createdAt?: DateTimeFilter<"Concepto"> | Date | string
    updatedAt?: DateTimeFilter<"Concepto"> | Date | string
    estilo?: XOR<EstiloNullableScalarRelationFilter, EstiloWhereInput> | null
    recibos?: ReciboListRelationFilter
  }, "id">

  export type ConceptoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    monto?: SortOrder
    estiloId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConceptoCountOrderByAggregateInput
    _avg?: ConceptoAvgOrderByAggregateInput
    _max?: ConceptoMaxOrderByAggregateInput
    _min?: ConceptoMinOrderByAggregateInput
    _sum?: ConceptoSumOrderByAggregateInput
  }

  export type ConceptoScalarWhereWithAggregatesInput = {
    AND?: ConceptoScalarWhereWithAggregatesInput | ConceptoScalarWhereWithAggregatesInput[]
    OR?: ConceptoScalarWhereWithAggregatesInput[]
    NOT?: ConceptoScalarWhereWithAggregatesInput | ConceptoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Concepto"> | number
    nombre?: StringWithAggregatesFilter<"Concepto"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Concepto"> | string | null
    monto?: FloatWithAggregatesFilter<"Concepto"> | number
    estiloId?: IntNullableWithAggregatesFilter<"Concepto"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Concepto"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Concepto"> | Date | string
  }

  export type ReciboWhereInput = {
    AND?: ReciboWhereInput | ReciboWhereInput[]
    OR?: ReciboWhereInput[]
    NOT?: ReciboWhereInput | ReciboWhereInput[]
    id?: IntFilter<"Recibo"> | number
    numeroRecibo?: IntFilter<"Recibo"> | number
    fecha?: DateTimeFilter<"Recibo"> | Date | string
    fechaEfecto?: DateTimeFilter<"Recibo"> | Date | string
    monto?: FloatFilter<"Recibo"> | number
    montoOriginal?: FloatFilter<"Recibo"> | number
    descuento?: FloatNullableFilter<"Recibo"> | number | null
    periodoPago?: StringFilter<"Recibo"> | string
    tipoPago?: EnumTipoPagoFilter<"Recibo"> | $Enums.TipoPago
    fueraDeTermino?: BoolFilter<"Recibo"> | boolean
    esClaseSuelta?: BoolFilter<"Recibo"> | boolean
    esMesCompleto?: BoolFilter<"Recibo"> | boolean
    alumnoId?: IntNullableFilter<"Recibo"> | number | null
    alumnoSueltoId?: IntNullableFilter<"Recibo"> | number | null
    conceptoId?: IntFilter<"Recibo"> | number
    claseId?: IntNullableFilter<"Recibo"> | number | null
    anulado?: BoolFilter<"Recibo"> | boolean
    motivoAnulacion?: StringNullableFilter<"Recibo"> | string | null
    referenciaRecibo?: IntNullableFilter<"Recibo"> | number | null
    createdAt?: DateTimeFilter<"Recibo"> | Date | string
    updatedAt?: DateTimeFilter<"Recibo"> | Date | string
    alumno?: XOR<AlumnoNullableScalarRelationFilter, AlumnoWhereInput> | null
    alumnoSuelto?: XOR<AlumnoSueltoNullableScalarRelationFilter, AlumnoSueltoWhereInput> | null
    concepto?: XOR<ConceptoScalarRelationFilter, ConceptoWhereInput>
    pagosDeuda?: PagoDeudaListRelationFilter
    detallesLiquidacion?: DetalleLiquidacionListRelationFilter
    clase?: XOR<ClaseNullableScalarRelationFilter, ClaseWhereInput> | null
    reciboAnulado?: XOR<ReciboNullableScalarRelationFilter, ReciboWhereInput> | null
    recibosAnulados?: ReciboListRelationFilter
  }

  export type ReciboOrderByWithRelationInput = {
    id?: SortOrder
    numeroRecibo?: SortOrder
    fecha?: SortOrder
    fechaEfecto?: SortOrder
    monto?: SortOrder
    montoOriginal?: SortOrder
    descuento?: SortOrderInput | SortOrder
    periodoPago?: SortOrder
    tipoPago?: SortOrder
    fueraDeTermino?: SortOrder
    esClaseSuelta?: SortOrder
    esMesCompleto?: SortOrder
    alumnoId?: SortOrderInput | SortOrder
    alumnoSueltoId?: SortOrderInput | SortOrder
    conceptoId?: SortOrder
    claseId?: SortOrderInput | SortOrder
    anulado?: SortOrder
    motivoAnulacion?: SortOrderInput | SortOrder
    referenciaRecibo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    alumno?: AlumnoOrderByWithRelationInput
    alumnoSuelto?: AlumnoSueltoOrderByWithRelationInput
    concepto?: ConceptoOrderByWithRelationInput
    pagosDeuda?: PagoDeudaOrderByRelationAggregateInput
    detallesLiquidacion?: DetalleLiquidacionOrderByRelationAggregateInput
    clase?: ClaseOrderByWithRelationInput
    reciboAnulado?: ReciboOrderByWithRelationInput
    recibosAnulados?: ReciboOrderByRelationAggregateInput
  }

  export type ReciboWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    numeroRecibo?: number
    AND?: ReciboWhereInput | ReciboWhereInput[]
    OR?: ReciboWhereInput[]
    NOT?: ReciboWhereInput | ReciboWhereInput[]
    fecha?: DateTimeFilter<"Recibo"> | Date | string
    fechaEfecto?: DateTimeFilter<"Recibo"> | Date | string
    monto?: FloatFilter<"Recibo"> | number
    montoOriginal?: FloatFilter<"Recibo"> | number
    descuento?: FloatNullableFilter<"Recibo"> | number | null
    periodoPago?: StringFilter<"Recibo"> | string
    tipoPago?: EnumTipoPagoFilter<"Recibo"> | $Enums.TipoPago
    fueraDeTermino?: BoolFilter<"Recibo"> | boolean
    esClaseSuelta?: BoolFilter<"Recibo"> | boolean
    esMesCompleto?: BoolFilter<"Recibo"> | boolean
    alumnoId?: IntNullableFilter<"Recibo"> | number | null
    alumnoSueltoId?: IntNullableFilter<"Recibo"> | number | null
    conceptoId?: IntFilter<"Recibo"> | number
    claseId?: IntNullableFilter<"Recibo"> | number | null
    anulado?: BoolFilter<"Recibo"> | boolean
    motivoAnulacion?: StringNullableFilter<"Recibo"> | string | null
    referenciaRecibo?: IntNullableFilter<"Recibo"> | number | null
    createdAt?: DateTimeFilter<"Recibo"> | Date | string
    updatedAt?: DateTimeFilter<"Recibo"> | Date | string
    alumno?: XOR<AlumnoNullableScalarRelationFilter, AlumnoWhereInput> | null
    alumnoSuelto?: XOR<AlumnoSueltoNullableScalarRelationFilter, AlumnoSueltoWhereInput> | null
    concepto?: XOR<ConceptoScalarRelationFilter, ConceptoWhereInput>
    pagosDeuda?: PagoDeudaListRelationFilter
    detallesLiquidacion?: DetalleLiquidacionListRelationFilter
    clase?: XOR<ClaseNullableScalarRelationFilter, ClaseWhereInput> | null
    reciboAnulado?: XOR<ReciboNullableScalarRelationFilter, ReciboWhereInput> | null
    recibosAnulados?: ReciboListRelationFilter
  }, "id" | "numeroRecibo">

  export type ReciboOrderByWithAggregationInput = {
    id?: SortOrder
    numeroRecibo?: SortOrder
    fecha?: SortOrder
    fechaEfecto?: SortOrder
    monto?: SortOrder
    montoOriginal?: SortOrder
    descuento?: SortOrderInput | SortOrder
    periodoPago?: SortOrder
    tipoPago?: SortOrder
    fueraDeTermino?: SortOrder
    esClaseSuelta?: SortOrder
    esMesCompleto?: SortOrder
    alumnoId?: SortOrderInput | SortOrder
    alumnoSueltoId?: SortOrderInput | SortOrder
    conceptoId?: SortOrder
    claseId?: SortOrderInput | SortOrder
    anulado?: SortOrder
    motivoAnulacion?: SortOrderInput | SortOrder
    referenciaRecibo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReciboCountOrderByAggregateInput
    _avg?: ReciboAvgOrderByAggregateInput
    _max?: ReciboMaxOrderByAggregateInput
    _min?: ReciboMinOrderByAggregateInput
    _sum?: ReciboSumOrderByAggregateInput
  }

  export type ReciboScalarWhereWithAggregatesInput = {
    AND?: ReciboScalarWhereWithAggregatesInput | ReciboScalarWhereWithAggregatesInput[]
    OR?: ReciboScalarWhereWithAggregatesInput[]
    NOT?: ReciboScalarWhereWithAggregatesInput | ReciboScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Recibo"> | number
    numeroRecibo?: IntWithAggregatesFilter<"Recibo"> | number
    fecha?: DateTimeWithAggregatesFilter<"Recibo"> | Date | string
    fechaEfecto?: DateTimeWithAggregatesFilter<"Recibo"> | Date | string
    monto?: FloatWithAggregatesFilter<"Recibo"> | number
    montoOriginal?: FloatWithAggregatesFilter<"Recibo"> | number
    descuento?: FloatNullableWithAggregatesFilter<"Recibo"> | number | null
    periodoPago?: StringWithAggregatesFilter<"Recibo"> | string
    tipoPago?: EnumTipoPagoWithAggregatesFilter<"Recibo"> | $Enums.TipoPago
    fueraDeTermino?: BoolWithAggregatesFilter<"Recibo"> | boolean
    esClaseSuelta?: BoolWithAggregatesFilter<"Recibo"> | boolean
    esMesCompleto?: BoolWithAggregatesFilter<"Recibo"> | boolean
    alumnoId?: IntNullableWithAggregatesFilter<"Recibo"> | number | null
    alumnoSueltoId?: IntNullableWithAggregatesFilter<"Recibo"> | number | null
    conceptoId?: IntWithAggregatesFilter<"Recibo"> | number
    claseId?: IntNullableWithAggregatesFilter<"Recibo"> | number | null
    anulado?: BoolWithAggregatesFilter<"Recibo"> | boolean
    motivoAnulacion?: StringNullableWithAggregatesFilter<"Recibo"> | string | null
    referenciaRecibo?: IntNullableWithAggregatesFilter<"Recibo"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Recibo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Recibo"> | Date | string
  }

  export type EstiloWhereInput = {
    AND?: EstiloWhereInput | EstiloWhereInput[]
    OR?: EstiloWhereInput[]
    NOT?: EstiloWhereInput | EstiloWhereInput[]
    id?: IntFilter<"Estilo"> | number
    nombre?: StringFilter<"Estilo"> | string
    monto?: FloatFilter<"Estilo"> | number
    descripcion?: StringNullableFilter<"Estilo"> | string | null
    importe?: FloatFilter<"Estilo"> | number
    profesorId?: IntNullableFilter<"Estilo"> | number | null
    createdAt?: DateTimeFilter<"Estilo"> | Date | string
    updatedAt?: DateTimeFilter<"Estilo"> | Date | string
    deudas?: DeudaListRelationFilter
    conceptos?: ConceptoListRelationFilter
    clases?: ClaseListRelationFilter
    alumnoEstilos?: AlumnoEstilosListRelationFilter
    profesor?: XOR<ProfesorNullableScalarRelationFilter, ProfesorWhereInput> | null
    alumnos?: AlumnoListRelationFilter
  }

  export type EstiloOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    monto?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    importe?: SortOrder
    profesorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deudas?: DeudaOrderByRelationAggregateInput
    conceptos?: ConceptoOrderByRelationAggregateInput
    clases?: ClaseOrderByRelationAggregateInput
    alumnoEstilos?: AlumnoEstilosOrderByRelationAggregateInput
    profesor?: ProfesorOrderByWithRelationInput
    alumnos?: AlumnoOrderByRelationAggregateInput
  }

  export type EstiloWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EstiloWhereInput | EstiloWhereInput[]
    OR?: EstiloWhereInput[]
    NOT?: EstiloWhereInput | EstiloWhereInput[]
    nombre?: StringFilter<"Estilo"> | string
    monto?: FloatFilter<"Estilo"> | number
    descripcion?: StringNullableFilter<"Estilo"> | string | null
    importe?: FloatFilter<"Estilo"> | number
    profesorId?: IntNullableFilter<"Estilo"> | number | null
    createdAt?: DateTimeFilter<"Estilo"> | Date | string
    updatedAt?: DateTimeFilter<"Estilo"> | Date | string
    deudas?: DeudaListRelationFilter
    conceptos?: ConceptoListRelationFilter
    clases?: ClaseListRelationFilter
    alumnoEstilos?: AlumnoEstilosListRelationFilter
    profesor?: XOR<ProfesorNullableScalarRelationFilter, ProfesorWhereInput> | null
    alumnos?: AlumnoListRelationFilter
  }, "id">

  export type EstiloOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    monto?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    importe?: SortOrder
    profesorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EstiloCountOrderByAggregateInput
    _avg?: EstiloAvgOrderByAggregateInput
    _max?: EstiloMaxOrderByAggregateInput
    _min?: EstiloMinOrderByAggregateInput
    _sum?: EstiloSumOrderByAggregateInput
  }

  export type EstiloScalarWhereWithAggregatesInput = {
    AND?: EstiloScalarWhereWithAggregatesInput | EstiloScalarWhereWithAggregatesInput[]
    OR?: EstiloScalarWhereWithAggregatesInput[]
    NOT?: EstiloScalarWhereWithAggregatesInput | EstiloScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Estilo"> | number
    nombre?: StringWithAggregatesFilter<"Estilo"> | string
    monto?: FloatWithAggregatesFilter<"Estilo"> | number
    descripcion?: StringNullableWithAggregatesFilter<"Estilo"> | string | null
    importe?: FloatWithAggregatesFilter<"Estilo"> | number
    profesorId?: IntNullableWithAggregatesFilter<"Estilo"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Estilo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Estilo"> | Date | string
  }

  export type AlumnoEstilosWhereInput = {
    AND?: AlumnoEstilosWhereInput | AlumnoEstilosWhereInput[]
    OR?: AlumnoEstilosWhereInput[]
    NOT?: AlumnoEstilosWhereInput | AlumnoEstilosWhereInput[]
    id?: IntFilter<"AlumnoEstilos"> | number
    alumnoId?: IntFilter<"AlumnoEstilos"> | number
    estiloId?: IntFilter<"AlumnoEstilos"> | number
    activo?: BoolFilter<"AlumnoEstilos"> | boolean
    fechaInicio?: DateTimeFilter<"AlumnoEstilos"> | Date | string
    fechaFin?: DateTimeNullableFilter<"AlumnoEstilos"> | Date | string | null
    montoPersonalizado?: FloatNullableFilter<"AlumnoEstilos"> | number | null
    descuentoPersonalizado?: FloatNullableFilter<"AlumnoEstilos"> | number | null
    observaciones?: StringNullableFilter<"AlumnoEstilos"> | string | null
    alumno?: XOR<AlumnoScalarRelationFilter, AlumnoWhereInput>
    estilo?: XOR<EstiloScalarRelationFilter, EstiloWhereInput>
  }

  export type AlumnoEstilosOrderByWithRelationInput = {
    id?: SortOrder
    alumnoId?: SortOrder
    estiloId?: SortOrder
    activo?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrderInput | SortOrder
    montoPersonalizado?: SortOrderInput | SortOrder
    descuentoPersonalizado?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    alumno?: AlumnoOrderByWithRelationInput
    estilo?: EstiloOrderByWithRelationInput
  }

  export type AlumnoEstilosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    alumnoId_estiloId?: AlumnoEstilosAlumnoIdEstiloIdCompoundUniqueInput
    AND?: AlumnoEstilosWhereInput | AlumnoEstilosWhereInput[]
    OR?: AlumnoEstilosWhereInput[]
    NOT?: AlumnoEstilosWhereInput | AlumnoEstilosWhereInput[]
    alumnoId?: IntFilter<"AlumnoEstilos"> | number
    estiloId?: IntFilter<"AlumnoEstilos"> | number
    activo?: BoolFilter<"AlumnoEstilos"> | boolean
    fechaInicio?: DateTimeFilter<"AlumnoEstilos"> | Date | string
    fechaFin?: DateTimeNullableFilter<"AlumnoEstilos"> | Date | string | null
    montoPersonalizado?: FloatNullableFilter<"AlumnoEstilos"> | number | null
    descuentoPersonalizado?: FloatNullableFilter<"AlumnoEstilos"> | number | null
    observaciones?: StringNullableFilter<"AlumnoEstilos"> | string | null
    alumno?: XOR<AlumnoScalarRelationFilter, AlumnoWhereInput>
    estilo?: XOR<EstiloScalarRelationFilter, EstiloWhereInput>
  }, "id" | "alumnoId_estiloId">

  export type AlumnoEstilosOrderByWithAggregationInput = {
    id?: SortOrder
    alumnoId?: SortOrder
    estiloId?: SortOrder
    activo?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrderInput | SortOrder
    montoPersonalizado?: SortOrderInput | SortOrder
    descuentoPersonalizado?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    _count?: AlumnoEstilosCountOrderByAggregateInput
    _avg?: AlumnoEstilosAvgOrderByAggregateInput
    _max?: AlumnoEstilosMaxOrderByAggregateInput
    _min?: AlumnoEstilosMinOrderByAggregateInput
    _sum?: AlumnoEstilosSumOrderByAggregateInput
  }

  export type AlumnoEstilosScalarWhereWithAggregatesInput = {
    AND?: AlumnoEstilosScalarWhereWithAggregatesInput | AlumnoEstilosScalarWhereWithAggregatesInput[]
    OR?: AlumnoEstilosScalarWhereWithAggregatesInput[]
    NOT?: AlumnoEstilosScalarWhereWithAggregatesInput | AlumnoEstilosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AlumnoEstilos"> | number
    alumnoId?: IntWithAggregatesFilter<"AlumnoEstilos"> | number
    estiloId?: IntWithAggregatesFilter<"AlumnoEstilos"> | number
    activo?: BoolWithAggregatesFilter<"AlumnoEstilos"> | boolean
    fechaInicio?: DateTimeWithAggregatesFilter<"AlumnoEstilos"> | Date | string
    fechaFin?: DateTimeNullableWithAggregatesFilter<"AlumnoEstilos"> | Date | string | null
    montoPersonalizado?: FloatNullableWithAggregatesFilter<"AlumnoEstilos"> | number | null
    descuentoPersonalizado?: FloatNullableWithAggregatesFilter<"AlumnoEstilos"> | number | null
    observaciones?: StringNullableWithAggregatesFilter<"AlumnoEstilos"> | string | null
  }

  export type ProfesorWhereInput = {
    AND?: ProfesorWhereInput | ProfesorWhereInput[]
    OR?: ProfesorWhereInput[]
    NOT?: ProfesorWhereInput | ProfesorWhereInput[]
    id?: IntFilter<"Profesor"> | number
    nombre?: StringFilter<"Profesor"> | string
    apellido?: StringFilter<"Profesor"> | string
    dni?: StringFilter<"Profesor"> | string
    fechaNacimiento?: DateTimeNullableFilter<"Profesor"> | Date | string | null
    direccion?: StringNullableFilter<"Profesor"> | string | null
    cuit?: StringNullableFilter<"Profesor"> | string | null
    email?: StringNullableFilter<"Profesor"> | string | null
    telefono?: StringNullableFilter<"Profesor"> | string | null
    fechaIngreso?: DateTimeFilter<"Profesor"> | Date | string
    porcentajePorDefecto?: FloatFilter<"Profesor"> | number
    porcentajeClasesSueltasPorDefecto?: FloatFilter<"Profesor"> | number
    activo?: BoolFilter<"Profesor"> | boolean
    createdAt?: DateTimeFilter<"Profesor"> | Date | string
    updatedAt?: DateTimeFilter<"Profesor"> | Date | string
    clases?: ClaseListRelationFilter
    estilos?: EstiloListRelationFilter
    liquidaciones?: LiquidacionListRelationFilter
  }

  export type ProfesorOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    fechaNacimiento?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    cuit?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    fechaIngreso?: SortOrder
    porcentajePorDefecto?: SortOrder
    porcentajeClasesSueltasPorDefecto?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clases?: ClaseOrderByRelationAggregateInput
    estilos?: EstiloOrderByRelationAggregateInput
    liquidaciones?: LiquidacionOrderByRelationAggregateInput
  }

  export type ProfesorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    dni?: string
    AND?: ProfesorWhereInput | ProfesorWhereInput[]
    OR?: ProfesorWhereInput[]
    NOT?: ProfesorWhereInput | ProfesorWhereInput[]
    nombre?: StringFilter<"Profesor"> | string
    apellido?: StringFilter<"Profesor"> | string
    fechaNacimiento?: DateTimeNullableFilter<"Profesor"> | Date | string | null
    direccion?: StringNullableFilter<"Profesor"> | string | null
    cuit?: StringNullableFilter<"Profesor"> | string | null
    email?: StringNullableFilter<"Profesor"> | string | null
    telefono?: StringNullableFilter<"Profesor"> | string | null
    fechaIngreso?: DateTimeFilter<"Profesor"> | Date | string
    porcentajePorDefecto?: FloatFilter<"Profesor"> | number
    porcentajeClasesSueltasPorDefecto?: FloatFilter<"Profesor"> | number
    activo?: BoolFilter<"Profesor"> | boolean
    createdAt?: DateTimeFilter<"Profesor"> | Date | string
    updatedAt?: DateTimeFilter<"Profesor"> | Date | string
    clases?: ClaseListRelationFilter
    estilos?: EstiloListRelationFilter
    liquidaciones?: LiquidacionListRelationFilter
  }, "id" | "dni">

  export type ProfesorOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    fechaNacimiento?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    cuit?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    fechaIngreso?: SortOrder
    porcentajePorDefecto?: SortOrder
    porcentajeClasesSueltasPorDefecto?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfesorCountOrderByAggregateInput
    _avg?: ProfesorAvgOrderByAggregateInput
    _max?: ProfesorMaxOrderByAggregateInput
    _min?: ProfesorMinOrderByAggregateInput
    _sum?: ProfesorSumOrderByAggregateInput
  }

  export type ProfesorScalarWhereWithAggregatesInput = {
    AND?: ProfesorScalarWhereWithAggregatesInput | ProfesorScalarWhereWithAggregatesInput[]
    OR?: ProfesorScalarWhereWithAggregatesInput[]
    NOT?: ProfesorScalarWhereWithAggregatesInput | ProfesorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Profesor"> | number
    nombre?: StringWithAggregatesFilter<"Profesor"> | string
    apellido?: StringWithAggregatesFilter<"Profesor"> | string
    dni?: StringWithAggregatesFilter<"Profesor"> | string
    fechaNacimiento?: DateTimeNullableWithAggregatesFilter<"Profesor"> | Date | string | null
    direccion?: StringNullableWithAggregatesFilter<"Profesor"> | string | null
    cuit?: StringNullableWithAggregatesFilter<"Profesor"> | string | null
    email?: StringNullableWithAggregatesFilter<"Profesor"> | string | null
    telefono?: StringNullableWithAggregatesFilter<"Profesor"> | string | null
    fechaIngreso?: DateTimeWithAggregatesFilter<"Profesor"> | Date | string
    porcentajePorDefecto?: FloatWithAggregatesFilter<"Profesor"> | number
    porcentajeClasesSueltasPorDefecto?: FloatWithAggregatesFilter<"Profesor"> | number
    activo?: BoolWithAggregatesFilter<"Profesor"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Profesor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Profesor"> | Date | string
  }

  export type CtaCteWhereInput = {
    AND?: CtaCteWhereInput | CtaCteWhereInput[]
    OR?: CtaCteWhereInput[]
    NOT?: CtaCteWhereInput | CtaCteWhereInput[]
    id?: IntFilter<"CtaCte"> | number
    saldo?: FloatFilter<"CtaCte"> | number
    alumnoId?: IntFilter<"CtaCte"> | number
    createdAt?: DateTimeFilter<"CtaCte"> | Date | string
    updatedAt?: DateTimeFilter<"CtaCte"> | Date | string
    alumno?: XOR<AlumnoScalarRelationFilter, AlumnoWhereInput>
  }

  export type CtaCteOrderByWithRelationInput = {
    id?: SortOrder
    saldo?: SortOrder
    alumnoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    alumno?: AlumnoOrderByWithRelationInput
  }

  export type CtaCteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    alumnoId?: number
    AND?: CtaCteWhereInput | CtaCteWhereInput[]
    OR?: CtaCteWhereInput[]
    NOT?: CtaCteWhereInput | CtaCteWhereInput[]
    saldo?: FloatFilter<"CtaCte"> | number
    createdAt?: DateTimeFilter<"CtaCte"> | Date | string
    updatedAt?: DateTimeFilter<"CtaCte"> | Date | string
    alumno?: XOR<AlumnoScalarRelationFilter, AlumnoWhereInput>
  }, "id" | "alumnoId">

  export type CtaCteOrderByWithAggregationInput = {
    id?: SortOrder
    saldo?: SortOrder
    alumnoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CtaCteCountOrderByAggregateInput
    _avg?: CtaCteAvgOrderByAggregateInput
    _max?: CtaCteMaxOrderByAggregateInput
    _min?: CtaCteMinOrderByAggregateInput
    _sum?: CtaCteSumOrderByAggregateInput
  }

  export type CtaCteScalarWhereWithAggregatesInput = {
    AND?: CtaCteScalarWhereWithAggregatesInput | CtaCteScalarWhereWithAggregatesInput[]
    OR?: CtaCteScalarWhereWithAggregatesInput[]
    NOT?: CtaCteScalarWhereWithAggregatesInput | CtaCteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CtaCte"> | number
    saldo?: FloatWithAggregatesFilter<"CtaCte"> | number
    alumnoId?: IntWithAggregatesFilter<"CtaCte"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CtaCte"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CtaCte"> | Date | string
  }

  export type CajaDiariaWhereInput = {
    AND?: CajaDiariaWhereInput | CajaDiariaWhereInput[]
    OR?: CajaDiariaWhereInput[]
    NOT?: CajaDiariaWhereInput | CajaDiariaWhereInput[]
    id?: IntFilter<"CajaDiaria"> | number
    fecha?: DateTimeFilter<"CajaDiaria"> | Date | string
    apertura?: FloatFilter<"CajaDiaria"> | number
    cierre?: FloatFilter<"CajaDiaria"> | number
    diferencia?: FloatFilter<"CajaDiaria"> | number
    createdAt?: DateTimeFilter<"CajaDiaria"> | Date | string
    updatedAt?: DateTimeFilter<"CajaDiaria"> | Date | string
  }

  export type CajaDiariaOrderByWithRelationInput = {
    id?: SortOrder
    fecha?: SortOrder
    apertura?: SortOrder
    cierre?: SortOrder
    diferencia?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CajaDiariaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    fecha?: Date | string
    AND?: CajaDiariaWhereInput | CajaDiariaWhereInput[]
    OR?: CajaDiariaWhereInput[]
    NOT?: CajaDiariaWhereInput | CajaDiariaWhereInput[]
    apertura?: FloatFilter<"CajaDiaria"> | number
    cierre?: FloatFilter<"CajaDiaria"> | number
    diferencia?: FloatFilter<"CajaDiaria"> | number
    createdAt?: DateTimeFilter<"CajaDiaria"> | Date | string
    updatedAt?: DateTimeFilter<"CajaDiaria"> | Date | string
  }, "id" | "fecha">

  export type CajaDiariaOrderByWithAggregationInput = {
    id?: SortOrder
    fecha?: SortOrder
    apertura?: SortOrder
    cierre?: SortOrder
    diferencia?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CajaDiariaCountOrderByAggregateInput
    _avg?: CajaDiariaAvgOrderByAggregateInput
    _max?: CajaDiariaMaxOrderByAggregateInput
    _min?: CajaDiariaMinOrderByAggregateInput
    _sum?: CajaDiariaSumOrderByAggregateInput
  }

  export type CajaDiariaScalarWhereWithAggregatesInput = {
    AND?: CajaDiariaScalarWhereWithAggregatesInput | CajaDiariaScalarWhereWithAggregatesInput[]
    OR?: CajaDiariaScalarWhereWithAggregatesInput[]
    NOT?: CajaDiariaScalarWhereWithAggregatesInput | CajaDiariaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CajaDiaria"> | number
    fecha?: DateTimeWithAggregatesFilter<"CajaDiaria"> | Date | string
    apertura?: FloatWithAggregatesFilter<"CajaDiaria"> | number
    cierre?: FloatWithAggregatesFilter<"CajaDiaria"> | number
    diferencia?: FloatWithAggregatesFilter<"CajaDiaria"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CajaDiaria"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CajaDiaria"> | Date | string
  }

  export type ClaseWhereInput = {
    AND?: ClaseWhereInput | ClaseWhereInput[]
    OR?: ClaseWhereInput[]
    NOT?: ClaseWhereInput | ClaseWhereInput[]
    id?: IntFilter<"Clase"> | number
    fecha?: DateTimeFilter<"Clase"> | Date | string
    profesorId?: IntFilter<"Clase"> | number
    estiloId?: IntFilter<"Clase"> | number
    createdAt?: DateTimeFilter<"Clase"> | Date | string
    updatedAt?: DateTimeFilter<"Clase"> | Date | string
    profesor?: XOR<ProfesorScalarRelationFilter, ProfesorWhereInput>
    estilo?: XOR<EstiloScalarRelationFilter, EstiloWhereInput>
    asistencias?: AsistenciaListRelationFilter
    alumnosSueltos?: AlumnoSueltoListRelationFilter
    recibos?: ReciboListRelationFilter
  }

  export type ClaseOrderByWithRelationInput = {
    id?: SortOrder
    fecha?: SortOrder
    profesorId?: SortOrder
    estiloId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profesor?: ProfesorOrderByWithRelationInput
    estilo?: EstiloOrderByWithRelationInput
    asistencias?: AsistenciaOrderByRelationAggregateInput
    alumnosSueltos?: AlumnoSueltoOrderByRelationAggregateInput
    recibos?: ReciboOrderByRelationAggregateInput
  }

  export type ClaseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClaseWhereInput | ClaseWhereInput[]
    OR?: ClaseWhereInput[]
    NOT?: ClaseWhereInput | ClaseWhereInput[]
    fecha?: DateTimeFilter<"Clase"> | Date | string
    profesorId?: IntFilter<"Clase"> | number
    estiloId?: IntFilter<"Clase"> | number
    createdAt?: DateTimeFilter<"Clase"> | Date | string
    updatedAt?: DateTimeFilter<"Clase"> | Date | string
    profesor?: XOR<ProfesorScalarRelationFilter, ProfesorWhereInput>
    estilo?: XOR<EstiloScalarRelationFilter, EstiloWhereInput>
    asistencias?: AsistenciaListRelationFilter
    alumnosSueltos?: AlumnoSueltoListRelationFilter
    recibos?: ReciboListRelationFilter
  }, "id">

  export type ClaseOrderByWithAggregationInput = {
    id?: SortOrder
    fecha?: SortOrder
    profesorId?: SortOrder
    estiloId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClaseCountOrderByAggregateInput
    _avg?: ClaseAvgOrderByAggregateInput
    _max?: ClaseMaxOrderByAggregateInput
    _min?: ClaseMinOrderByAggregateInput
    _sum?: ClaseSumOrderByAggregateInput
  }

  export type ClaseScalarWhereWithAggregatesInput = {
    AND?: ClaseScalarWhereWithAggregatesInput | ClaseScalarWhereWithAggregatesInput[]
    OR?: ClaseScalarWhereWithAggregatesInput[]
    NOT?: ClaseScalarWhereWithAggregatesInput | ClaseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Clase"> | number
    fecha?: DateTimeWithAggregatesFilter<"Clase"> | Date | string
    profesorId?: IntWithAggregatesFilter<"Clase"> | number
    estiloId?: IntWithAggregatesFilter<"Clase"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Clase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Clase"> | Date | string
  }

  export type AsistenciaWhereInput = {
    AND?: AsistenciaWhereInput | AsistenciaWhereInput[]
    OR?: AsistenciaWhereInput[]
    NOT?: AsistenciaWhereInput | AsistenciaWhereInput[]
    id?: IntFilter<"Asistencia"> | number
    claseId?: IntFilter<"Asistencia"> | number
    alumnoId?: IntFilter<"Asistencia"> | number
    asistio?: BoolFilter<"Asistencia"> | boolean
    createdAt?: DateTimeFilter<"Asistencia"> | Date | string
    updatedAt?: DateTimeFilter<"Asistencia"> | Date | string
    clase?: XOR<ClaseScalarRelationFilter, ClaseWhereInput>
    alumno?: XOR<AlumnoScalarRelationFilter, AlumnoWhereInput>
  }

  export type AsistenciaOrderByWithRelationInput = {
    id?: SortOrder
    claseId?: SortOrder
    alumnoId?: SortOrder
    asistio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clase?: ClaseOrderByWithRelationInput
    alumno?: AlumnoOrderByWithRelationInput
  }

  export type AsistenciaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AsistenciaWhereInput | AsistenciaWhereInput[]
    OR?: AsistenciaWhereInput[]
    NOT?: AsistenciaWhereInput | AsistenciaWhereInput[]
    claseId?: IntFilter<"Asistencia"> | number
    alumnoId?: IntFilter<"Asistencia"> | number
    asistio?: BoolFilter<"Asistencia"> | boolean
    createdAt?: DateTimeFilter<"Asistencia"> | Date | string
    updatedAt?: DateTimeFilter<"Asistencia"> | Date | string
    clase?: XOR<ClaseScalarRelationFilter, ClaseWhereInput>
    alumno?: XOR<AlumnoScalarRelationFilter, AlumnoWhereInput>
  }, "id">

  export type AsistenciaOrderByWithAggregationInput = {
    id?: SortOrder
    claseId?: SortOrder
    alumnoId?: SortOrder
    asistio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AsistenciaCountOrderByAggregateInput
    _avg?: AsistenciaAvgOrderByAggregateInput
    _max?: AsistenciaMaxOrderByAggregateInput
    _min?: AsistenciaMinOrderByAggregateInput
    _sum?: AsistenciaSumOrderByAggregateInput
  }

  export type AsistenciaScalarWhereWithAggregatesInput = {
    AND?: AsistenciaScalarWhereWithAggregatesInput | AsistenciaScalarWhereWithAggregatesInput[]
    OR?: AsistenciaScalarWhereWithAggregatesInput[]
    NOT?: AsistenciaScalarWhereWithAggregatesInput | AsistenciaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Asistencia"> | number
    claseId?: IntWithAggregatesFilter<"Asistencia"> | number
    alumnoId?: IntWithAggregatesFilter<"Asistencia"> | number
    asistio?: BoolWithAggregatesFilter<"Asistencia"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Asistencia"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Asistencia"> | Date | string
  }

  export type AlumnoSueltoWhereInput = {
    AND?: AlumnoSueltoWhereInput | AlumnoSueltoWhereInput[]
    OR?: AlumnoSueltoWhereInput[]
    NOT?: AlumnoSueltoWhereInput | AlumnoSueltoWhereInput[]
    id?: IntFilter<"AlumnoSuelto"> | number
    nombre?: StringFilter<"AlumnoSuelto"> | string
    apellido?: StringFilter<"AlumnoSuelto"> | string
    dni?: StringFilter<"AlumnoSuelto"> | string
    telefono?: StringNullableFilter<"AlumnoSuelto"> | string | null
    email?: StringNullableFilter<"AlumnoSuelto"> | string | null
    alumnoRegularId?: IntNullableFilter<"AlumnoSuelto"> | number | null
    createdAt?: DateTimeFilter<"AlumnoSuelto"> | Date | string
    updatedAt?: DateTimeFilter<"AlumnoSuelto"> | Date | string
    recibos?: ReciboListRelationFilter
    clases?: ClaseListRelationFilter
    alumnoRegular?: XOR<AlumnoNullableScalarRelationFilter, AlumnoWhereInput> | null
  }

  export type AlumnoSueltoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    telefono?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    alumnoRegularId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    recibos?: ReciboOrderByRelationAggregateInput
    clases?: ClaseOrderByRelationAggregateInput
    alumnoRegular?: AlumnoOrderByWithRelationInput
  }

  export type AlumnoSueltoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    dni?: string
    AND?: AlumnoSueltoWhereInput | AlumnoSueltoWhereInput[]
    OR?: AlumnoSueltoWhereInput[]
    NOT?: AlumnoSueltoWhereInput | AlumnoSueltoWhereInput[]
    nombre?: StringFilter<"AlumnoSuelto"> | string
    apellido?: StringFilter<"AlumnoSuelto"> | string
    telefono?: StringNullableFilter<"AlumnoSuelto"> | string | null
    email?: StringNullableFilter<"AlumnoSuelto"> | string | null
    alumnoRegularId?: IntNullableFilter<"AlumnoSuelto"> | number | null
    createdAt?: DateTimeFilter<"AlumnoSuelto"> | Date | string
    updatedAt?: DateTimeFilter<"AlumnoSuelto"> | Date | string
    recibos?: ReciboListRelationFilter
    clases?: ClaseListRelationFilter
    alumnoRegular?: XOR<AlumnoNullableScalarRelationFilter, AlumnoWhereInput> | null
  }, "id" | "dni">

  export type AlumnoSueltoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    telefono?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    alumnoRegularId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AlumnoSueltoCountOrderByAggregateInput
    _avg?: AlumnoSueltoAvgOrderByAggregateInput
    _max?: AlumnoSueltoMaxOrderByAggregateInput
    _min?: AlumnoSueltoMinOrderByAggregateInput
    _sum?: AlumnoSueltoSumOrderByAggregateInput
  }

  export type AlumnoSueltoScalarWhereWithAggregatesInput = {
    AND?: AlumnoSueltoScalarWhereWithAggregatesInput | AlumnoSueltoScalarWhereWithAggregatesInput[]
    OR?: AlumnoSueltoScalarWhereWithAggregatesInput[]
    NOT?: AlumnoSueltoScalarWhereWithAggregatesInput | AlumnoSueltoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AlumnoSuelto"> | number
    nombre?: StringWithAggregatesFilter<"AlumnoSuelto"> | string
    apellido?: StringWithAggregatesFilter<"AlumnoSuelto"> | string
    dni?: StringWithAggregatesFilter<"AlumnoSuelto"> | string
    telefono?: StringNullableWithAggregatesFilter<"AlumnoSuelto"> | string | null
    email?: StringNullableWithAggregatesFilter<"AlumnoSuelto"> | string | null
    alumnoRegularId?: IntNullableWithAggregatesFilter<"AlumnoSuelto"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"AlumnoSuelto"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AlumnoSuelto"> | Date | string
  }

  export type LiquidacionWhereInput = {
    AND?: LiquidacionWhereInput | LiquidacionWhereInput[]
    OR?: LiquidacionWhereInput[]
    NOT?: LiquidacionWhereInput | LiquidacionWhereInput[]
    id?: IntFilter<"Liquidacion"> | number
    fecha?: DateTimeFilter<"Liquidacion"> | Date | string
    mes?: IntFilter<"Liquidacion"> | number
    anio?: IntFilter<"Liquidacion"> | number
    profesorId?: IntNullableFilter<"Liquidacion"> | number | null
    montoTotal?: FloatFilter<"Liquidacion"> | number
    montoCursos?: FloatFilter<"Liquidacion"> | number
    montoClasesSueltas?: FloatFilter<"Liquidacion"> | number
    porcentajeCursos?: FloatFilter<"Liquidacion"> | number
    porcentajeClasesSueltas?: FloatFilter<"Liquidacion"> | number
    estado?: EnumEstadoLiquidacionFilter<"Liquidacion"> | $Enums.EstadoLiquidacion
    metodoPago?: EnumTipoPagoNullableFilter<"Liquidacion"> | $Enums.TipoPago | null
    fechaPago?: DateTimeNullableFilter<"Liquidacion"> | Date | string | null
    observaciones?: StringNullableFilter<"Liquidacion"> | string | null
    createdAt?: DateTimeFilter<"Liquidacion"> | Date | string
    updatedAt?: DateTimeFilter<"Liquidacion"> | Date | string
    profesor?: XOR<ProfesorNullableScalarRelationFilter, ProfesorWhereInput> | null
    detalles?: DetalleLiquidacionListRelationFilter
  }

  export type LiquidacionOrderByWithRelationInput = {
    id?: SortOrder
    fecha?: SortOrder
    mes?: SortOrder
    anio?: SortOrder
    profesorId?: SortOrderInput | SortOrder
    montoTotal?: SortOrder
    montoCursos?: SortOrder
    montoClasesSueltas?: SortOrder
    porcentajeCursos?: SortOrder
    porcentajeClasesSueltas?: SortOrder
    estado?: SortOrder
    metodoPago?: SortOrderInput | SortOrder
    fechaPago?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profesor?: ProfesorOrderByWithRelationInput
    detalles?: DetalleLiquidacionOrderByRelationAggregateInput
  }

  export type LiquidacionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LiquidacionWhereInput | LiquidacionWhereInput[]
    OR?: LiquidacionWhereInput[]
    NOT?: LiquidacionWhereInput | LiquidacionWhereInput[]
    fecha?: DateTimeFilter<"Liquidacion"> | Date | string
    mes?: IntFilter<"Liquidacion"> | number
    anio?: IntFilter<"Liquidacion"> | number
    profesorId?: IntNullableFilter<"Liquidacion"> | number | null
    montoTotal?: FloatFilter<"Liquidacion"> | number
    montoCursos?: FloatFilter<"Liquidacion"> | number
    montoClasesSueltas?: FloatFilter<"Liquidacion"> | number
    porcentajeCursos?: FloatFilter<"Liquidacion"> | number
    porcentajeClasesSueltas?: FloatFilter<"Liquidacion"> | number
    estado?: EnumEstadoLiquidacionFilter<"Liquidacion"> | $Enums.EstadoLiquidacion
    metodoPago?: EnumTipoPagoNullableFilter<"Liquidacion"> | $Enums.TipoPago | null
    fechaPago?: DateTimeNullableFilter<"Liquidacion"> | Date | string | null
    observaciones?: StringNullableFilter<"Liquidacion"> | string | null
    createdAt?: DateTimeFilter<"Liquidacion"> | Date | string
    updatedAt?: DateTimeFilter<"Liquidacion"> | Date | string
    profesor?: XOR<ProfesorNullableScalarRelationFilter, ProfesorWhereInput> | null
    detalles?: DetalleLiquidacionListRelationFilter
  }, "id">

  export type LiquidacionOrderByWithAggregationInput = {
    id?: SortOrder
    fecha?: SortOrder
    mes?: SortOrder
    anio?: SortOrder
    profesorId?: SortOrderInput | SortOrder
    montoTotal?: SortOrder
    montoCursos?: SortOrder
    montoClasesSueltas?: SortOrder
    porcentajeCursos?: SortOrder
    porcentajeClasesSueltas?: SortOrder
    estado?: SortOrder
    metodoPago?: SortOrderInput | SortOrder
    fechaPago?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LiquidacionCountOrderByAggregateInput
    _avg?: LiquidacionAvgOrderByAggregateInput
    _max?: LiquidacionMaxOrderByAggregateInput
    _min?: LiquidacionMinOrderByAggregateInput
    _sum?: LiquidacionSumOrderByAggregateInput
  }

  export type LiquidacionScalarWhereWithAggregatesInput = {
    AND?: LiquidacionScalarWhereWithAggregatesInput | LiquidacionScalarWhereWithAggregatesInput[]
    OR?: LiquidacionScalarWhereWithAggregatesInput[]
    NOT?: LiquidacionScalarWhereWithAggregatesInput | LiquidacionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Liquidacion"> | number
    fecha?: DateTimeWithAggregatesFilter<"Liquidacion"> | Date | string
    mes?: IntWithAggregatesFilter<"Liquidacion"> | number
    anio?: IntWithAggregatesFilter<"Liquidacion"> | number
    profesorId?: IntNullableWithAggregatesFilter<"Liquidacion"> | number | null
    montoTotal?: FloatWithAggregatesFilter<"Liquidacion"> | number
    montoCursos?: FloatWithAggregatesFilter<"Liquidacion"> | number
    montoClasesSueltas?: FloatWithAggregatesFilter<"Liquidacion"> | number
    porcentajeCursos?: FloatWithAggregatesFilter<"Liquidacion"> | number
    porcentajeClasesSueltas?: FloatWithAggregatesFilter<"Liquidacion"> | number
    estado?: EnumEstadoLiquidacionWithAggregatesFilter<"Liquidacion"> | $Enums.EstadoLiquidacion
    metodoPago?: EnumTipoPagoNullableWithAggregatesFilter<"Liquidacion"> | $Enums.TipoPago | null
    fechaPago?: DateTimeNullableWithAggregatesFilter<"Liquidacion"> | Date | string | null
    observaciones?: StringNullableWithAggregatesFilter<"Liquidacion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Liquidacion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Liquidacion"> | Date | string
  }

  export type DetalleLiquidacionWhereInput = {
    AND?: DetalleLiquidacionWhereInput | DetalleLiquidacionWhereInput[]
    OR?: DetalleLiquidacionWhereInput[]
    NOT?: DetalleLiquidacionWhereInput | DetalleLiquidacionWhereInput[]
    id?: IntFilter<"DetalleLiquidacion"> | number
    liquidacionId?: IntFilter<"DetalleLiquidacion"> | number
    reciboId?: IntNullableFilter<"DetalleLiquidacion"> | number | null
    montoOriginal?: FloatFilter<"DetalleLiquidacion"> | number
    porcentaje?: FloatFilter<"DetalleLiquidacion"> | number
    montoLiquidado?: FloatFilter<"DetalleLiquidacion"> | number
    createdAt?: DateTimeFilter<"DetalleLiquidacion"> | Date | string
    updatedAt?: DateTimeFilter<"DetalleLiquidacion"> | Date | string
    liquidacion?: XOR<LiquidacionScalarRelationFilter, LiquidacionWhereInput>
    recibo?: XOR<ReciboNullableScalarRelationFilter, ReciboWhereInput> | null
  }

  export type DetalleLiquidacionOrderByWithRelationInput = {
    id?: SortOrder
    liquidacionId?: SortOrder
    reciboId?: SortOrderInput | SortOrder
    montoOriginal?: SortOrder
    porcentaje?: SortOrder
    montoLiquidado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    liquidacion?: LiquidacionOrderByWithRelationInput
    recibo?: ReciboOrderByWithRelationInput
  }

  export type DetalleLiquidacionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DetalleLiquidacionWhereInput | DetalleLiquidacionWhereInput[]
    OR?: DetalleLiquidacionWhereInput[]
    NOT?: DetalleLiquidacionWhereInput | DetalleLiquidacionWhereInput[]
    liquidacionId?: IntFilter<"DetalleLiquidacion"> | number
    reciboId?: IntNullableFilter<"DetalleLiquidacion"> | number | null
    montoOriginal?: FloatFilter<"DetalleLiquidacion"> | number
    porcentaje?: FloatFilter<"DetalleLiquidacion"> | number
    montoLiquidado?: FloatFilter<"DetalleLiquidacion"> | number
    createdAt?: DateTimeFilter<"DetalleLiquidacion"> | Date | string
    updatedAt?: DateTimeFilter<"DetalleLiquidacion"> | Date | string
    liquidacion?: XOR<LiquidacionScalarRelationFilter, LiquidacionWhereInput>
    recibo?: XOR<ReciboNullableScalarRelationFilter, ReciboWhereInput> | null
  }, "id">

  export type DetalleLiquidacionOrderByWithAggregationInput = {
    id?: SortOrder
    liquidacionId?: SortOrder
    reciboId?: SortOrderInput | SortOrder
    montoOriginal?: SortOrder
    porcentaje?: SortOrder
    montoLiquidado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DetalleLiquidacionCountOrderByAggregateInput
    _avg?: DetalleLiquidacionAvgOrderByAggregateInput
    _max?: DetalleLiquidacionMaxOrderByAggregateInput
    _min?: DetalleLiquidacionMinOrderByAggregateInput
    _sum?: DetalleLiquidacionSumOrderByAggregateInput
  }

  export type DetalleLiquidacionScalarWhereWithAggregatesInput = {
    AND?: DetalleLiquidacionScalarWhereWithAggregatesInput | DetalleLiquidacionScalarWhereWithAggregatesInput[]
    OR?: DetalleLiquidacionScalarWhereWithAggregatesInput[]
    NOT?: DetalleLiquidacionScalarWhereWithAggregatesInput | DetalleLiquidacionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DetalleLiquidacion"> | number
    liquidacionId?: IntWithAggregatesFilter<"DetalleLiquidacion"> | number
    reciboId?: IntNullableWithAggregatesFilter<"DetalleLiquidacion"> | number | null
    montoOriginal?: FloatWithAggregatesFilter<"DetalleLiquidacion"> | number
    porcentaje?: FloatWithAggregatesFilter<"DetalleLiquidacion"> | number
    montoLiquidado?: FloatWithAggregatesFilter<"DetalleLiquidacion"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DetalleLiquidacion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DetalleLiquidacion"> | Date | string
  }

  export type AlumnoCreateInput = {
    nombre: string
    apellido: string
    dni: string
    activo?: boolean
    fechaNacimiento: Date | string
    email?: string | null
    telefono?: string | null
    numeroEmergencia?: string | null
    direccion?: string | null
    obraSocial?: string | null
    nombreTutor?: string | null
    dniTutor?: string | null
    notas?: string | null
    fechaIngreso?: Date | string
    fechaBaja?: Date | string | null
    motivoBaja?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recibos?: ReciboCreateNestedManyWithoutAlumnoInput
    alumnosSueltosAnteriores?: AlumnoSueltoCreateNestedManyWithoutAlumnoRegularInput
    ctaCte?: CtaCteCreateNestedOneWithoutAlumnoInput
    estilos?: EstiloCreateNestedManyWithoutAlumnosInput
    asistencias?: AsistenciaCreateNestedManyWithoutAlumnoInput
    alumnoEstilos?: AlumnoEstilosCreateNestedManyWithoutAlumnoInput
    deudas?: DeudaCreateNestedManyWithoutAlumnoInput
    descuentosVigentes?: DescuentoAplicadoCreateNestedManyWithoutAlumnoInput
    configuracionPago?: ConfiguracionPagoAlumnoCreateNestedOneWithoutAlumnoInput
  }

  export type AlumnoUncheckedCreateInput = {
    id?: number
    nombre: string
    apellido: string
    dni: string
    activo?: boolean
    fechaNacimiento: Date | string
    email?: string | null
    telefono?: string | null
    numeroEmergencia?: string | null
    direccion?: string | null
    obraSocial?: string | null
    nombreTutor?: string | null
    dniTutor?: string | null
    notas?: string | null
    fechaIngreso?: Date | string
    fechaBaja?: Date | string | null
    motivoBaja?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recibos?: ReciboUncheckedCreateNestedManyWithoutAlumnoInput
    alumnosSueltosAnteriores?: AlumnoSueltoUncheckedCreateNestedManyWithoutAlumnoRegularInput
    ctaCte?: CtaCteUncheckedCreateNestedOneWithoutAlumnoInput
    estilos?: EstiloUncheckedCreateNestedManyWithoutAlumnosInput
    asistencias?: AsistenciaUncheckedCreateNestedManyWithoutAlumnoInput
    alumnoEstilos?: AlumnoEstilosUncheckedCreateNestedManyWithoutAlumnoInput
    deudas?: DeudaUncheckedCreateNestedManyWithoutAlumnoInput
    descuentosVigentes?: DescuentoAplicadoUncheckedCreateNestedManyWithoutAlumnoInput
    configuracionPago?: ConfiguracionPagoAlumnoUncheckedCreateNestedOneWithoutAlumnoInput
  }

  export type AlumnoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    numeroEmergencia?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    obraSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nombreTutor?: NullableStringFieldUpdateOperationsInput | string | null
    dniTutor?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoBaja?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibos?: ReciboUpdateManyWithoutAlumnoNestedInput
    alumnosSueltosAnteriores?: AlumnoSueltoUpdateManyWithoutAlumnoRegularNestedInput
    ctaCte?: CtaCteUpdateOneWithoutAlumnoNestedInput
    estilos?: EstiloUpdateManyWithoutAlumnosNestedInput
    asistencias?: AsistenciaUpdateManyWithoutAlumnoNestedInput
    alumnoEstilos?: AlumnoEstilosUpdateManyWithoutAlumnoNestedInput
    deudas?: DeudaUpdateManyWithoutAlumnoNestedInput
    descuentosVigentes?: DescuentoAplicadoUpdateManyWithoutAlumnoNestedInput
    configuracionPago?: ConfiguracionPagoAlumnoUpdateOneWithoutAlumnoNestedInput
  }

  export type AlumnoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    numeroEmergencia?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    obraSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nombreTutor?: NullableStringFieldUpdateOperationsInput | string | null
    dniTutor?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoBaja?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibos?: ReciboUncheckedUpdateManyWithoutAlumnoNestedInput
    alumnosSueltosAnteriores?: AlumnoSueltoUncheckedUpdateManyWithoutAlumnoRegularNestedInput
    ctaCte?: CtaCteUncheckedUpdateOneWithoutAlumnoNestedInput
    estilos?: EstiloUncheckedUpdateManyWithoutAlumnosNestedInput
    asistencias?: AsistenciaUncheckedUpdateManyWithoutAlumnoNestedInput
    alumnoEstilos?: AlumnoEstilosUncheckedUpdateManyWithoutAlumnoNestedInput
    deudas?: DeudaUncheckedUpdateManyWithoutAlumnoNestedInput
    descuentosVigentes?: DescuentoAplicadoUncheckedUpdateManyWithoutAlumnoNestedInput
    configuracionPago?: ConfiguracionPagoAlumnoUncheckedUpdateOneWithoutAlumnoNestedInput
  }

  export type AlumnoCreateManyInput = {
    id?: number
    nombre: string
    apellido: string
    dni: string
    activo?: boolean
    fechaNacimiento: Date | string
    email?: string | null
    telefono?: string | null
    numeroEmergencia?: string | null
    direccion?: string | null
    obraSocial?: string | null
    nombreTutor?: string | null
    dniTutor?: string | null
    notas?: string | null
    fechaIngreso?: Date | string
    fechaBaja?: Date | string | null
    motivoBaja?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlumnoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    numeroEmergencia?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    obraSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nombreTutor?: NullableStringFieldUpdateOperationsInput | string | null
    dniTutor?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoBaja?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlumnoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    numeroEmergencia?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    obraSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nombreTutor?: NullableStringFieldUpdateOperationsInput | string | null
    dniTutor?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoBaja?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfiguracionPagoAlumnoCreateInput = {
    diaPago?: number | null
    metodoPago?: $Enums.TipoPago
    descuentoFijo?: number | null
    observaciones?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alumno: AlumnoCreateNestedOneWithoutConfiguracionPagoInput
  }

  export type ConfiguracionPagoAlumnoUncheckedCreateInput = {
    id?: number
    alumnoId: number
    diaPago?: number | null
    metodoPago?: $Enums.TipoPago
    descuentoFijo?: number | null
    observaciones?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfiguracionPagoAlumnoUpdateInput = {
    diaPago?: NullableIntFieldUpdateOperationsInput | number | null
    metodoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    descuentoFijo?: NullableFloatFieldUpdateOperationsInput | number | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alumno?: AlumnoUpdateOneRequiredWithoutConfiguracionPagoNestedInput
  }

  export type ConfiguracionPagoAlumnoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    alumnoId?: IntFieldUpdateOperationsInput | number
    diaPago?: NullableIntFieldUpdateOperationsInput | number | null
    metodoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    descuentoFijo?: NullableFloatFieldUpdateOperationsInput | number | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfiguracionPagoAlumnoCreateManyInput = {
    id?: number
    alumnoId: number
    diaPago?: number | null
    metodoPago?: $Enums.TipoPago
    descuentoFijo?: number | null
    observaciones?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfiguracionPagoAlumnoUpdateManyMutationInput = {
    diaPago?: NullableIntFieldUpdateOperationsInput | number | null
    metodoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    descuentoFijo?: NullableFloatFieldUpdateOperationsInput | number | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfiguracionPagoAlumnoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    alumnoId?: IntFieldUpdateOperationsInput | number
    diaPago?: NullableIntFieldUpdateOperationsInput | number | null
    metodoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    descuentoFijo?: NullableFloatFieldUpdateOperationsInput | number | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DescuentoCreateInput = {
    nombre: string
    porcentaje: number
    activo?: boolean
    esAutomatico?: boolean
    minEstilos?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aplicadoA?: DescuentoAplicadoCreateNestedManyWithoutDescuentoInput
  }

  export type DescuentoUncheckedCreateInput = {
    id?: number
    nombre: string
    porcentaje: number
    activo?: boolean
    esAutomatico?: boolean
    minEstilos?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aplicadoA?: DescuentoAplicadoUncheckedCreateNestedManyWithoutDescuentoInput
  }

  export type DescuentoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    porcentaje?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    esAutomatico?: BoolFieldUpdateOperationsInput | boolean
    minEstilos?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aplicadoA?: DescuentoAplicadoUpdateManyWithoutDescuentoNestedInput
  }

  export type DescuentoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    porcentaje?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    esAutomatico?: BoolFieldUpdateOperationsInput | boolean
    minEstilos?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aplicadoA?: DescuentoAplicadoUncheckedUpdateManyWithoutDescuentoNestedInput
  }

  export type DescuentoCreateManyInput = {
    id?: number
    nombre: string
    porcentaje: number
    activo?: boolean
    esAutomatico?: boolean
    minEstilos?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DescuentoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    porcentaje?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    esAutomatico?: BoolFieldUpdateOperationsInput | boolean
    minEstilos?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DescuentoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    porcentaje?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    esAutomatico?: BoolFieldUpdateOperationsInput | boolean
    minEstilos?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DescuentoAplicadoCreateInput = {
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    descuento: DescuentoCreateNestedOneWithoutAplicadoAInput
    alumno: AlumnoCreateNestedOneWithoutDescuentosVigentesInput
  }

  export type DescuentoAplicadoUncheckedCreateInput = {
    id?: number
    descuentoId: number
    alumnoId: number
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DescuentoAplicadoUpdateInput = {
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    descuento?: DescuentoUpdateOneRequiredWithoutAplicadoANestedInput
    alumno?: AlumnoUpdateOneRequiredWithoutDescuentosVigentesNestedInput
  }

  export type DescuentoAplicadoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descuentoId?: IntFieldUpdateOperationsInput | number
    alumnoId?: IntFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DescuentoAplicadoCreateManyInput = {
    id?: number
    descuentoId: number
    alumnoId: number
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DescuentoAplicadoUpdateManyMutationInput = {
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DescuentoAplicadoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descuentoId?: IntFieldUpdateOperationsInput | number
    alumnoId?: IntFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeudaCreateInput = {
    monto: number
    montoOriginal: number
    mes: string
    anio: number
    pagada?: boolean
    fechaPago?: Date | string | null
    fechaVencimiento: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    alumno: AlumnoCreateNestedOneWithoutDeudasInput
    estilo: EstiloCreateNestedOneWithoutDeudasInput
    pagos?: PagoDeudaCreateNestedManyWithoutDeudaInput
  }

  export type DeudaUncheckedCreateInput = {
    id?: number
    alumnoId: number
    monto: number
    montoOriginal: number
    mes: string
    anio: number
    estiloId: number
    pagada?: boolean
    fechaPago?: Date | string | null
    fechaVencimiento: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    pagos?: PagoDeudaUncheckedCreateNestedManyWithoutDeudaInput
  }

  export type DeudaUpdateInput = {
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    mes?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    pagada?: BoolFieldUpdateOperationsInput | boolean
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alumno?: AlumnoUpdateOneRequiredWithoutDeudasNestedInput
    estilo?: EstiloUpdateOneRequiredWithoutDeudasNestedInput
    pagos?: PagoDeudaUpdateManyWithoutDeudaNestedInput
  }

  export type DeudaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    alumnoId?: IntFieldUpdateOperationsInput | number
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    mes?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    estiloId?: IntFieldUpdateOperationsInput | number
    pagada?: BoolFieldUpdateOperationsInput | boolean
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagos?: PagoDeudaUncheckedUpdateManyWithoutDeudaNestedInput
  }

  export type DeudaCreateManyInput = {
    id?: number
    alumnoId: number
    monto: number
    montoOriginal: number
    mes: string
    anio: number
    estiloId: number
    pagada?: boolean
    fechaPago?: Date | string | null
    fechaVencimiento: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeudaUpdateManyMutationInput = {
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    mes?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    pagada?: BoolFieldUpdateOperationsInput | boolean
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeudaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    alumnoId?: IntFieldUpdateOperationsInput | number
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    mes?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    estiloId?: IntFieldUpdateOperationsInput | number
    pagada?: BoolFieldUpdateOperationsInput | boolean
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoDeudaCreateInput = {
    monto: number
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deuda: DeudaCreateNestedOneWithoutPagosInput
    recibo: ReciboCreateNestedOneWithoutPagosDeudaInput
  }

  export type PagoDeudaUncheckedCreateInput = {
    id?: number
    deudaId: number
    reciboId: number
    monto: number
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PagoDeudaUpdateInput = {
    monto?: FloatFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deuda?: DeudaUpdateOneRequiredWithoutPagosNestedInput
    recibo?: ReciboUpdateOneRequiredWithoutPagosDeudaNestedInput
  }

  export type PagoDeudaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    deudaId?: IntFieldUpdateOperationsInput | number
    reciboId?: IntFieldUpdateOperationsInput | number
    monto?: FloatFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoDeudaCreateManyInput = {
    id?: number
    deudaId: number
    reciboId: number
    monto: number
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PagoDeudaUpdateManyMutationInput = {
    monto?: FloatFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoDeudaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    deudaId?: IntFieldUpdateOperationsInput | number
    reciboId?: IntFieldUpdateOperationsInput | number
    monto?: FloatFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptoCreateInput = {
    nombre: string
    descripcion?: string | null
    monto: number
    createdAt?: Date | string
    updatedAt?: Date | string
    estilo?: EstiloCreateNestedOneWithoutConceptosInput
    recibos?: ReciboCreateNestedManyWithoutConceptoInput
  }

  export type ConceptoUncheckedCreateInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    monto: number
    estiloId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recibos?: ReciboUncheckedCreateNestedManyWithoutConceptoInput
  }

  export type ConceptoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estilo?: EstiloUpdateOneWithoutConceptosNestedInput
    recibos?: ReciboUpdateManyWithoutConceptoNestedInput
  }

  export type ConceptoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: FloatFieldUpdateOperationsInput | number
    estiloId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibos?: ReciboUncheckedUpdateManyWithoutConceptoNestedInput
  }

  export type ConceptoCreateManyInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    monto: number
    estiloId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConceptoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: FloatFieldUpdateOperationsInput | number
    estiloId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReciboCreateInput = {
    numeroRecibo?: number
    fecha?: Date | string
    fechaEfecto?: Date | string
    monto: number
    montoOriginal: number
    descuento?: number | null
    periodoPago: string
    tipoPago: $Enums.TipoPago
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    anulado?: boolean
    motivoAnulacion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alumno?: AlumnoCreateNestedOneWithoutRecibosInput
    alumnoSuelto?: AlumnoSueltoCreateNestedOneWithoutRecibosInput
    concepto: ConceptoCreateNestedOneWithoutRecibosInput
    pagosDeuda?: PagoDeudaCreateNestedManyWithoutReciboInput
    detallesLiquidacion?: DetalleLiquidacionCreateNestedManyWithoutReciboInput
    clase?: ClaseCreateNestedOneWithoutRecibosInput
    reciboAnulado?: ReciboCreateNestedOneWithoutRecibosAnuladosInput
    recibosAnulados?: ReciboCreateNestedManyWithoutReciboAnuladoInput
  }

  export type ReciboUncheckedCreateInput = {
    id?: number
    numeroRecibo?: number
    fecha?: Date | string
    fechaEfecto?: Date | string
    monto: number
    montoOriginal: number
    descuento?: number | null
    periodoPago: string
    tipoPago: $Enums.TipoPago
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    alumnoId?: number | null
    alumnoSueltoId?: number | null
    conceptoId: number
    claseId?: number | null
    anulado?: boolean
    motivoAnulacion?: string | null
    referenciaRecibo?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pagosDeuda?: PagoDeudaUncheckedCreateNestedManyWithoutReciboInput
    detallesLiquidacion?: DetalleLiquidacionUncheckedCreateNestedManyWithoutReciboInput
    recibosAnulados?: ReciboUncheckedCreateNestedManyWithoutReciboAnuladoInput
  }

  export type ReciboUpdateInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEfecto?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    periodoPago?: StringFieldUpdateOperationsInput | string
    tipoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    fueraDeTermino?: BoolFieldUpdateOperationsInput | boolean
    esClaseSuelta?: BoolFieldUpdateOperationsInput | boolean
    esMesCompleto?: BoolFieldUpdateOperationsInput | boolean
    anulado?: BoolFieldUpdateOperationsInput | boolean
    motivoAnulacion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alumno?: AlumnoUpdateOneWithoutRecibosNestedInput
    alumnoSuelto?: AlumnoSueltoUpdateOneWithoutRecibosNestedInput
    concepto?: ConceptoUpdateOneRequiredWithoutRecibosNestedInput
    pagosDeuda?: PagoDeudaUpdateManyWithoutReciboNestedInput
    detallesLiquidacion?: DetalleLiquidacionUpdateManyWithoutReciboNestedInput
    clase?: ClaseUpdateOneWithoutRecibosNestedInput
    reciboAnulado?: ReciboUpdateOneWithoutRecibosAnuladosNestedInput
    recibosAnulados?: ReciboUpdateManyWithoutReciboAnuladoNestedInput
  }

  export type ReciboUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroRecibo?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEfecto?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    periodoPago?: StringFieldUpdateOperationsInput | string
    tipoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    fueraDeTermino?: BoolFieldUpdateOperationsInput | boolean
    esClaseSuelta?: BoolFieldUpdateOperationsInput | boolean
    esMesCompleto?: BoolFieldUpdateOperationsInput | boolean
    alumnoId?: NullableIntFieldUpdateOperationsInput | number | null
    alumnoSueltoId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptoId?: IntFieldUpdateOperationsInput | number
    claseId?: NullableIntFieldUpdateOperationsInput | number | null
    anulado?: BoolFieldUpdateOperationsInput | boolean
    motivoAnulacion?: NullableStringFieldUpdateOperationsInput | string | null
    referenciaRecibo?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagosDeuda?: PagoDeudaUncheckedUpdateManyWithoutReciboNestedInput
    detallesLiquidacion?: DetalleLiquidacionUncheckedUpdateManyWithoutReciboNestedInput
    recibosAnulados?: ReciboUncheckedUpdateManyWithoutReciboAnuladoNestedInput
  }

  export type ReciboCreateManyInput = {
    id?: number
    numeroRecibo?: number
    fecha?: Date | string
    fechaEfecto?: Date | string
    monto: number
    montoOriginal: number
    descuento?: number | null
    periodoPago: string
    tipoPago: $Enums.TipoPago
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    alumnoId?: number | null
    alumnoSueltoId?: number | null
    conceptoId: number
    claseId?: number | null
    anulado?: boolean
    motivoAnulacion?: string | null
    referenciaRecibo?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReciboUpdateManyMutationInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEfecto?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    periodoPago?: StringFieldUpdateOperationsInput | string
    tipoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    fueraDeTermino?: BoolFieldUpdateOperationsInput | boolean
    esClaseSuelta?: BoolFieldUpdateOperationsInput | boolean
    esMesCompleto?: BoolFieldUpdateOperationsInput | boolean
    anulado?: BoolFieldUpdateOperationsInput | boolean
    motivoAnulacion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReciboUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroRecibo?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEfecto?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    periodoPago?: StringFieldUpdateOperationsInput | string
    tipoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    fueraDeTermino?: BoolFieldUpdateOperationsInput | boolean
    esClaseSuelta?: BoolFieldUpdateOperationsInput | boolean
    esMesCompleto?: BoolFieldUpdateOperationsInput | boolean
    alumnoId?: NullableIntFieldUpdateOperationsInput | number | null
    alumnoSueltoId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptoId?: IntFieldUpdateOperationsInput | number
    claseId?: NullableIntFieldUpdateOperationsInput | number | null
    anulado?: BoolFieldUpdateOperationsInput | boolean
    motivoAnulacion?: NullableStringFieldUpdateOperationsInput | string | null
    referenciaRecibo?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EstiloCreateInput = {
    nombre: string
    monto?: number
    descripcion?: string | null
    importe?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deudas?: DeudaCreateNestedManyWithoutEstiloInput
    conceptos?: ConceptoCreateNestedManyWithoutEstiloInput
    clases?: ClaseCreateNestedManyWithoutEstiloInput
    alumnoEstilos?: AlumnoEstilosCreateNestedManyWithoutEstiloInput
    profesor?: ProfesorCreateNestedOneWithoutEstilosInput
    alumnos?: AlumnoCreateNestedManyWithoutEstilosInput
  }

  export type EstiloUncheckedCreateInput = {
    id?: number
    nombre: string
    monto?: number
    descripcion?: string | null
    importe?: number
    profesorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deudas?: DeudaUncheckedCreateNestedManyWithoutEstiloInput
    conceptos?: ConceptoUncheckedCreateNestedManyWithoutEstiloInput
    clases?: ClaseUncheckedCreateNestedManyWithoutEstiloInput
    alumnoEstilos?: AlumnoEstilosUncheckedCreateNestedManyWithoutEstiloInput
    alumnos?: AlumnoUncheckedCreateNestedManyWithoutEstilosInput
  }

  export type EstiloUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deudas?: DeudaUpdateManyWithoutEstiloNestedInput
    conceptos?: ConceptoUpdateManyWithoutEstiloNestedInput
    clases?: ClaseUpdateManyWithoutEstiloNestedInput
    alumnoEstilos?: AlumnoEstilosUpdateManyWithoutEstiloNestedInput
    profesor?: ProfesorUpdateOneWithoutEstilosNestedInput
    alumnos?: AlumnoUpdateManyWithoutEstilosNestedInput
  }

  export type EstiloUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: FloatFieldUpdateOperationsInput | number
    profesorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deudas?: DeudaUncheckedUpdateManyWithoutEstiloNestedInput
    conceptos?: ConceptoUncheckedUpdateManyWithoutEstiloNestedInput
    clases?: ClaseUncheckedUpdateManyWithoutEstiloNestedInput
    alumnoEstilos?: AlumnoEstilosUncheckedUpdateManyWithoutEstiloNestedInput
    alumnos?: AlumnoUncheckedUpdateManyWithoutEstilosNestedInput
  }

  export type EstiloCreateManyInput = {
    id?: number
    nombre: string
    monto?: number
    descripcion?: string | null
    importe?: number
    profesorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EstiloUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EstiloUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: FloatFieldUpdateOperationsInput | number
    profesorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlumnoEstilosCreateInput = {
    activo?: boolean
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    montoPersonalizado?: number | null
    descuentoPersonalizado?: number | null
    observaciones?: string | null
    alumno: AlumnoCreateNestedOneWithoutAlumnoEstilosInput
    estilo: EstiloCreateNestedOneWithoutAlumnoEstilosInput
  }

  export type AlumnoEstilosUncheckedCreateInput = {
    id?: number
    alumnoId: number
    estiloId: number
    activo?: boolean
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    montoPersonalizado?: number | null
    descuentoPersonalizado?: number | null
    observaciones?: string | null
  }

  export type AlumnoEstilosUpdateInput = {
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montoPersonalizado?: NullableFloatFieldUpdateOperationsInput | number | null
    descuentoPersonalizado?: NullableFloatFieldUpdateOperationsInput | number | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    alumno?: AlumnoUpdateOneRequiredWithoutAlumnoEstilosNestedInput
    estilo?: EstiloUpdateOneRequiredWithoutAlumnoEstilosNestedInput
  }

  export type AlumnoEstilosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    alumnoId?: IntFieldUpdateOperationsInput | number
    estiloId?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montoPersonalizado?: NullableFloatFieldUpdateOperationsInput | number | null
    descuentoPersonalizado?: NullableFloatFieldUpdateOperationsInput | number | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlumnoEstilosCreateManyInput = {
    id?: number
    alumnoId: number
    estiloId: number
    activo?: boolean
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    montoPersonalizado?: number | null
    descuentoPersonalizado?: number | null
    observaciones?: string | null
  }

  export type AlumnoEstilosUpdateManyMutationInput = {
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montoPersonalizado?: NullableFloatFieldUpdateOperationsInput | number | null
    descuentoPersonalizado?: NullableFloatFieldUpdateOperationsInput | number | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlumnoEstilosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    alumnoId?: IntFieldUpdateOperationsInput | number
    estiloId?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montoPersonalizado?: NullableFloatFieldUpdateOperationsInput | number | null
    descuentoPersonalizado?: NullableFloatFieldUpdateOperationsInput | number | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfesorCreateInput = {
    nombre: string
    apellido: string
    dni: string
    fechaNacimiento?: Date | string | null
    direccion?: string | null
    cuit?: string | null
    email?: string | null
    telefono?: string | null
    fechaIngreso?: Date | string
    porcentajePorDefecto?: number
    porcentajeClasesSueltasPorDefecto?: number
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clases?: ClaseCreateNestedManyWithoutProfesorInput
    estilos?: EstiloCreateNestedManyWithoutProfesorInput
    liquidaciones?: LiquidacionCreateNestedManyWithoutProfesorInput
  }

  export type ProfesorUncheckedCreateInput = {
    id?: number
    nombre: string
    apellido: string
    dni: string
    fechaNacimiento?: Date | string | null
    direccion?: string | null
    cuit?: string | null
    email?: string | null
    telefono?: string | null
    fechaIngreso?: Date | string
    porcentajePorDefecto?: number
    porcentajeClasesSueltasPorDefecto?: number
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clases?: ClaseUncheckedCreateNestedManyWithoutProfesorInput
    estilos?: EstiloUncheckedCreateNestedManyWithoutProfesorInput
    liquidaciones?: LiquidacionUncheckedCreateNestedManyWithoutProfesorInput
  }

  export type ProfesorUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    porcentajePorDefecto?: FloatFieldUpdateOperationsInput | number
    porcentajeClasesSueltasPorDefecto?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clases?: ClaseUpdateManyWithoutProfesorNestedInput
    estilos?: EstiloUpdateManyWithoutProfesorNestedInput
    liquidaciones?: LiquidacionUpdateManyWithoutProfesorNestedInput
  }

  export type ProfesorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    porcentajePorDefecto?: FloatFieldUpdateOperationsInput | number
    porcentajeClasesSueltasPorDefecto?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clases?: ClaseUncheckedUpdateManyWithoutProfesorNestedInput
    estilos?: EstiloUncheckedUpdateManyWithoutProfesorNestedInput
    liquidaciones?: LiquidacionUncheckedUpdateManyWithoutProfesorNestedInput
  }

  export type ProfesorCreateManyInput = {
    id?: number
    nombre: string
    apellido: string
    dni: string
    fechaNacimiento?: Date | string | null
    direccion?: string | null
    cuit?: string | null
    email?: string | null
    telefono?: string | null
    fechaIngreso?: Date | string
    porcentajePorDefecto?: number
    porcentajeClasesSueltasPorDefecto?: number
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfesorUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    porcentajePorDefecto?: FloatFieldUpdateOperationsInput | number
    porcentajeClasesSueltasPorDefecto?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfesorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    porcentajePorDefecto?: FloatFieldUpdateOperationsInput | number
    porcentajeClasesSueltasPorDefecto?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CtaCteCreateInput = {
    saldo: number
    createdAt?: Date | string
    updatedAt?: Date | string
    alumno: AlumnoCreateNestedOneWithoutCtaCteInput
  }

  export type CtaCteUncheckedCreateInput = {
    id?: number
    saldo: number
    alumnoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CtaCteUpdateInput = {
    saldo?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alumno?: AlumnoUpdateOneRequiredWithoutCtaCteNestedInput
  }

  export type CtaCteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    saldo?: FloatFieldUpdateOperationsInput | number
    alumnoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CtaCteCreateManyInput = {
    id?: number
    saldo: number
    alumnoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CtaCteUpdateManyMutationInput = {
    saldo?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CtaCteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    saldo?: FloatFieldUpdateOperationsInput | number
    alumnoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CajaDiariaCreateInput = {
    fecha?: Date | string
    apertura: number
    cierre: number
    diferencia: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CajaDiariaUncheckedCreateInput = {
    id?: number
    fecha?: Date | string
    apertura: number
    cierre: number
    diferencia: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CajaDiariaUpdateInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    apertura?: FloatFieldUpdateOperationsInput | number
    cierre?: FloatFieldUpdateOperationsInput | number
    diferencia?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CajaDiariaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    apertura?: FloatFieldUpdateOperationsInput | number
    cierre?: FloatFieldUpdateOperationsInput | number
    diferencia?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CajaDiariaCreateManyInput = {
    id?: number
    fecha?: Date | string
    apertura: number
    cierre: number
    diferencia: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CajaDiariaUpdateManyMutationInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    apertura?: FloatFieldUpdateOperationsInput | number
    cierre?: FloatFieldUpdateOperationsInput | number
    diferencia?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CajaDiariaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    apertura?: FloatFieldUpdateOperationsInput | number
    cierre?: FloatFieldUpdateOperationsInput | number
    diferencia?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaseCreateInput = {
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    profesor: ProfesorCreateNestedOneWithoutClasesInput
    estilo: EstiloCreateNestedOneWithoutClasesInput
    asistencias?: AsistenciaCreateNestedManyWithoutClaseInput
    alumnosSueltos?: AlumnoSueltoCreateNestedManyWithoutClasesInput
    recibos?: ReciboCreateNestedManyWithoutClaseInput
  }

  export type ClaseUncheckedCreateInput = {
    id?: number
    fecha?: Date | string
    profesorId: number
    estiloId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    asistencias?: AsistenciaUncheckedCreateNestedManyWithoutClaseInput
    alumnosSueltos?: AlumnoSueltoUncheckedCreateNestedManyWithoutClasesInput
    recibos?: ReciboUncheckedCreateNestedManyWithoutClaseInput
  }

  export type ClaseUpdateInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profesor?: ProfesorUpdateOneRequiredWithoutClasesNestedInput
    estilo?: EstiloUpdateOneRequiredWithoutClasesNestedInput
    asistencias?: AsistenciaUpdateManyWithoutClaseNestedInput
    alumnosSueltos?: AlumnoSueltoUpdateManyWithoutClasesNestedInput
    recibos?: ReciboUpdateManyWithoutClaseNestedInput
  }

  export type ClaseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    profesorId?: IntFieldUpdateOperationsInput | number
    estiloId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asistencias?: AsistenciaUncheckedUpdateManyWithoutClaseNestedInput
    alumnosSueltos?: AlumnoSueltoUncheckedUpdateManyWithoutClasesNestedInput
    recibos?: ReciboUncheckedUpdateManyWithoutClaseNestedInput
  }

  export type ClaseCreateManyInput = {
    id?: number
    fecha?: Date | string
    profesorId: number
    estiloId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClaseUpdateManyMutationInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    profesorId?: IntFieldUpdateOperationsInput | number
    estiloId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AsistenciaCreateInput = {
    asistio: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clase: ClaseCreateNestedOneWithoutAsistenciasInput
    alumno: AlumnoCreateNestedOneWithoutAsistenciasInput
  }

  export type AsistenciaUncheckedCreateInput = {
    id?: number
    claseId: number
    alumnoId: number
    asistio: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AsistenciaUpdateInput = {
    asistio?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clase?: ClaseUpdateOneRequiredWithoutAsistenciasNestedInput
    alumno?: AlumnoUpdateOneRequiredWithoutAsistenciasNestedInput
  }

  export type AsistenciaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    claseId?: IntFieldUpdateOperationsInput | number
    alumnoId?: IntFieldUpdateOperationsInput | number
    asistio?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AsistenciaCreateManyInput = {
    id?: number
    claseId: number
    alumnoId: number
    asistio: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AsistenciaUpdateManyMutationInput = {
    asistio?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AsistenciaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    claseId?: IntFieldUpdateOperationsInput | number
    alumnoId?: IntFieldUpdateOperationsInput | number
    asistio?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlumnoSueltoCreateInput = {
    nombre: string
    apellido: string
    dni: string
    telefono?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recibos?: ReciboCreateNestedManyWithoutAlumnoSueltoInput
    clases?: ClaseCreateNestedManyWithoutAlumnosSueltosInput
    alumnoRegular?: AlumnoCreateNestedOneWithoutAlumnosSueltosAnterioresInput
  }

  export type AlumnoSueltoUncheckedCreateInput = {
    id?: number
    nombre: string
    apellido: string
    dni: string
    telefono?: string | null
    email?: string | null
    alumnoRegularId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recibos?: ReciboUncheckedCreateNestedManyWithoutAlumnoSueltoInput
    clases?: ClaseUncheckedCreateNestedManyWithoutAlumnosSueltosInput
  }

  export type AlumnoSueltoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibos?: ReciboUpdateManyWithoutAlumnoSueltoNestedInput
    clases?: ClaseUpdateManyWithoutAlumnosSueltosNestedInput
    alumnoRegular?: AlumnoUpdateOneWithoutAlumnosSueltosAnterioresNestedInput
  }

  export type AlumnoSueltoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    alumnoRegularId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibos?: ReciboUncheckedUpdateManyWithoutAlumnoSueltoNestedInput
    clases?: ClaseUncheckedUpdateManyWithoutAlumnosSueltosNestedInput
  }

  export type AlumnoSueltoCreateManyInput = {
    id?: number
    nombre: string
    apellido: string
    dni: string
    telefono?: string | null
    email?: string | null
    alumnoRegularId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlumnoSueltoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlumnoSueltoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    alumnoRegularId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiquidacionCreateInput = {
    fecha?: Date | string
    mes: number
    anio: number
    montoTotal: number
    montoCursos: number
    montoClasesSueltas: number
    porcentajeCursos?: number
    porcentajeClasesSueltas?: number
    estado?: $Enums.EstadoLiquidacion
    metodoPago?: $Enums.TipoPago | null
    fechaPago?: Date | string | null
    observaciones?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profesor?: ProfesorCreateNestedOneWithoutLiquidacionesInput
    detalles?: DetalleLiquidacionCreateNestedManyWithoutLiquidacionInput
  }

  export type LiquidacionUncheckedCreateInput = {
    id?: number
    fecha?: Date | string
    mes: number
    anio: number
    profesorId?: number | null
    montoTotal: number
    montoCursos: number
    montoClasesSueltas: number
    porcentajeCursos?: number
    porcentajeClasesSueltas?: number
    estado?: $Enums.EstadoLiquidacion
    metodoPago?: $Enums.TipoPago | null
    fechaPago?: Date | string | null
    observaciones?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    detalles?: DetalleLiquidacionUncheckedCreateNestedManyWithoutLiquidacionInput
  }

  export type LiquidacionUpdateInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    mes?: IntFieldUpdateOperationsInput | number
    anio?: IntFieldUpdateOperationsInput | number
    montoTotal?: FloatFieldUpdateOperationsInput | number
    montoCursos?: FloatFieldUpdateOperationsInput | number
    montoClasesSueltas?: FloatFieldUpdateOperationsInput | number
    porcentajeCursos?: FloatFieldUpdateOperationsInput | number
    porcentajeClasesSueltas?: FloatFieldUpdateOperationsInput | number
    estado?: EnumEstadoLiquidacionFieldUpdateOperationsInput | $Enums.EstadoLiquidacion
    metodoPago?: NullableEnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago | null
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profesor?: ProfesorUpdateOneWithoutLiquidacionesNestedInput
    detalles?: DetalleLiquidacionUpdateManyWithoutLiquidacionNestedInput
  }

  export type LiquidacionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    mes?: IntFieldUpdateOperationsInput | number
    anio?: IntFieldUpdateOperationsInput | number
    profesorId?: NullableIntFieldUpdateOperationsInput | number | null
    montoTotal?: FloatFieldUpdateOperationsInput | number
    montoCursos?: FloatFieldUpdateOperationsInput | number
    montoClasesSueltas?: FloatFieldUpdateOperationsInput | number
    porcentajeCursos?: FloatFieldUpdateOperationsInput | number
    porcentajeClasesSueltas?: FloatFieldUpdateOperationsInput | number
    estado?: EnumEstadoLiquidacionFieldUpdateOperationsInput | $Enums.EstadoLiquidacion
    metodoPago?: NullableEnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago | null
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detalles?: DetalleLiquidacionUncheckedUpdateManyWithoutLiquidacionNestedInput
  }

  export type LiquidacionCreateManyInput = {
    id?: number
    fecha?: Date | string
    mes: number
    anio: number
    profesorId?: number | null
    montoTotal: number
    montoCursos: number
    montoClasesSueltas: number
    porcentajeCursos?: number
    porcentajeClasesSueltas?: number
    estado?: $Enums.EstadoLiquidacion
    metodoPago?: $Enums.TipoPago | null
    fechaPago?: Date | string | null
    observaciones?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LiquidacionUpdateManyMutationInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    mes?: IntFieldUpdateOperationsInput | number
    anio?: IntFieldUpdateOperationsInput | number
    montoTotal?: FloatFieldUpdateOperationsInput | number
    montoCursos?: FloatFieldUpdateOperationsInput | number
    montoClasesSueltas?: FloatFieldUpdateOperationsInput | number
    porcentajeCursos?: FloatFieldUpdateOperationsInput | number
    porcentajeClasesSueltas?: FloatFieldUpdateOperationsInput | number
    estado?: EnumEstadoLiquidacionFieldUpdateOperationsInput | $Enums.EstadoLiquidacion
    metodoPago?: NullableEnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago | null
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiquidacionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    mes?: IntFieldUpdateOperationsInput | number
    anio?: IntFieldUpdateOperationsInput | number
    profesorId?: NullableIntFieldUpdateOperationsInput | number | null
    montoTotal?: FloatFieldUpdateOperationsInput | number
    montoCursos?: FloatFieldUpdateOperationsInput | number
    montoClasesSueltas?: FloatFieldUpdateOperationsInput | number
    porcentajeCursos?: FloatFieldUpdateOperationsInput | number
    porcentajeClasesSueltas?: FloatFieldUpdateOperationsInput | number
    estado?: EnumEstadoLiquidacionFieldUpdateOperationsInput | $Enums.EstadoLiquidacion
    metodoPago?: NullableEnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago | null
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetalleLiquidacionCreateInput = {
    montoOriginal: number
    porcentaje: number
    montoLiquidado: number
    createdAt?: Date | string
    updatedAt?: Date | string
    liquidacion: LiquidacionCreateNestedOneWithoutDetallesInput
    recibo?: ReciboCreateNestedOneWithoutDetallesLiquidacionInput
  }

  export type DetalleLiquidacionUncheckedCreateInput = {
    id?: number
    liquidacionId: number
    reciboId?: number | null
    montoOriginal: number
    porcentaje: number
    montoLiquidado: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetalleLiquidacionUpdateInput = {
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    porcentaje?: FloatFieldUpdateOperationsInput | number
    montoLiquidado?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    liquidacion?: LiquidacionUpdateOneRequiredWithoutDetallesNestedInput
    recibo?: ReciboUpdateOneWithoutDetallesLiquidacionNestedInput
  }

  export type DetalleLiquidacionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    liquidacionId?: IntFieldUpdateOperationsInput | number
    reciboId?: NullableIntFieldUpdateOperationsInput | number | null
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    porcentaje?: FloatFieldUpdateOperationsInput | number
    montoLiquidado?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetalleLiquidacionCreateManyInput = {
    id?: number
    liquidacionId: number
    reciboId?: number | null
    montoOriginal: number
    porcentaje: number
    montoLiquidado: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetalleLiquidacionUpdateManyMutationInput = {
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    porcentaje?: FloatFieldUpdateOperationsInput | number
    montoLiquidado?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetalleLiquidacionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    liquidacionId?: IntFieldUpdateOperationsInput | number
    reciboId?: NullableIntFieldUpdateOperationsInput | number | null
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    porcentaje?: FloatFieldUpdateOperationsInput | number
    montoLiquidado?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ReciboListRelationFilter = {
    every?: ReciboWhereInput
    some?: ReciboWhereInput
    none?: ReciboWhereInput
  }

  export type AlumnoSueltoListRelationFilter = {
    every?: AlumnoSueltoWhereInput
    some?: AlumnoSueltoWhereInput
    none?: AlumnoSueltoWhereInput
  }

  export type CtaCteNullableScalarRelationFilter = {
    is?: CtaCteWhereInput | null
    isNot?: CtaCteWhereInput | null
  }

  export type EstiloListRelationFilter = {
    every?: EstiloWhereInput
    some?: EstiloWhereInput
    none?: EstiloWhereInput
  }

  export type AsistenciaListRelationFilter = {
    every?: AsistenciaWhereInput
    some?: AsistenciaWhereInput
    none?: AsistenciaWhereInput
  }

  export type AlumnoEstilosListRelationFilter = {
    every?: AlumnoEstilosWhereInput
    some?: AlumnoEstilosWhereInput
    none?: AlumnoEstilosWhereInput
  }

  export type DeudaListRelationFilter = {
    every?: DeudaWhereInput
    some?: DeudaWhereInput
    none?: DeudaWhereInput
  }

  export type DescuentoAplicadoListRelationFilter = {
    every?: DescuentoAplicadoWhereInput
    some?: DescuentoAplicadoWhereInput
    none?: DescuentoAplicadoWhereInput
  }

  export type ConfiguracionPagoAlumnoNullableScalarRelationFilter = {
    is?: ConfiguracionPagoAlumnoWhereInput | null
    isNot?: ConfiguracionPagoAlumnoWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ReciboOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlumnoSueltoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EstiloOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AsistenciaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlumnoEstilosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeudaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DescuentoAplicadoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlumnoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    activo?: SortOrder
    fechaNacimiento?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    numeroEmergencia?: SortOrder
    direccion?: SortOrder
    obraSocial?: SortOrder
    nombreTutor?: SortOrder
    dniTutor?: SortOrder
    notas?: SortOrder
    fechaIngreso?: SortOrder
    fechaBaja?: SortOrder
    motivoBaja?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlumnoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AlumnoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    activo?: SortOrder
    fechaNacimiento?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    numeroEmergencia?: SortOrder
    direccion?: SortOrder
    obraSocial?: SortOrder
    nombreTutor?: SortOrder
    dniTutor?: SortOrder
    notas?: SortOrder
    fechaIngreso?: SortOrder
    fechaBaja?: SortOrder
    motivoBaja?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlumnoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    activo?: SortOrder
    fechaNacimiento?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    numeroEmergencia?: SortOrder
    direccion?: SortOrder
    obraSocial?: SortOrder
    nombreTutor?: SortOrder
    dniTutor?: SortOrder
    notas?: SortOrder
    fechaIngreso?: SortOrder
    fechaBaja?: SortOrder
    motivoBaja?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlumnoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumTipoPagoFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoPago | EnumTipoPagoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoPago[] | ListEnumTipoPagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoPago[] | ListEnumTipoPagoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoPagoFilter<$PrismaModel> | $Enums.TipoPago
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type AlumnoScalarRelationFilter = {
    is?: AlumnoWhereInput
    isNot?: AlumnoWhereInput
  }

  export type ConfiguracionPagoAlumnoCountOrderByAggregateInput = {
    id?: SortOrder
    alumnoId?: SortOrder
    diaPago?: SortOrder
    metodoPago?: SortOrder
    descuentoFijo?: SortOrder
    observaciones?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfiguracionPagoAlumnoAvgOrderByAggregateInput = {
    id?: SortOrder
    alumnoId?: SortOrder
    diaPago?: SortOrder
    descuentoFijo?: SortOrder
  }

  export type ConfiguracionPagoAlumnoMaxOrderByAggregateInput = {
    id?: SortOrder
    alumnoId?: SortOrder
    diaPago?: SortOrder
    metodoPago?: SortOrder
    descuentoFijo?: SortOrder
    observaciones?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfiguracionPagoAlumnoMinOrderByAggregateInput = {
    id?: SortOrder
    alumnoId?: SortOrder
    diaPago?: SortOrder
    metodoPago?: SortOrder
    descuentoFijo?: SortOrder
    observaciones?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfiguracionPagoAlumnoSumOrderByAggregateInput = {
    id?: SortOrder
    alumnoId?: SortOrder
    diaPago?: SortOrder
    descuentoFijo?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumTipoPagoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoPago | EnumTipoPagoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoPago[] | ListEnumTipoPagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoPago[] | ListEnumTipoPagoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoPagoWithAggregatesFilter<$PrismaModel> | $Enums.TipoPago
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoPagoFilter<$PrismaModel>
    _max?: NestedEnumTipoPagoFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DescuentoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    porcentaje?: SortOrder
    activo?: SortOrder
    esAutomatico?: SortOrder
    minEstilos?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DescuentoAvgOrderByAggregateInput = {
    id?: SortOrder
    porcentaje?: SortOrder
    minEstilos?: SortOrder
  }

  export type DescuentoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    porcentaje?: SortOrder
    activo?: SortOrder
    esAutomatico?: SortOrder
    minEstilos?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DescuentoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    porcentaje?: SortOrder
    activo?: SortOrder
    esAutomatico?: SortOrder
    minEstilos?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DescuentoSumOrderByAggregateInput = {
    id?: SortOrder
    porcentaje?: SortOrder
    minEstilos?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DescuentoScalarRelationFilter = {
    is?: DescuentoWhereInput
    isNot?: DescuentoWhereInput
  }

  export type DescuentoAplicadoCountOrderByAggregateInput = {
    id?: SortOrder
    descuentoId?: SortOrder
    alumnoId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DescuentoAplicadoAvgOrderByAggregateInput = {
    id?: SortOrder
    descuentoId?: SortOrder
    alumnoId?: SortOrder
  }

  export type DescuentoAplicadoMaxOrderByAggregateInput = {
    id?: SortOrder
    descuentoId?: SortOrder
    alumnoId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DescuentoAplicadoMinOrderByAggregateInput = {
    id?: SortOrder
    descuentoId?: SortOrder
    alumnoId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DescuentoAplicadoSumOrderByAggregateInput = {
    id?: SortOrder
    descuentoId?: SortOrder
    alumnoId?: SortOrder
  }

  export type EstiloScalarRelationFilter = {
    is?: EstiloWhereInput
    isNot?: EstiloWhereInput
  }

  export type PagoDeudaListRelationFilter = {
    every?: PagoDeudaWhereInput
    some?: PagoDeudaWhereInput
    none?: PagoDeudaWhereInput
  }

  export type PagoDeudaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeudaCountOrderByAggregateInput = {
    id?: SortOrder
    alumnoId?: SortOrder
    monto?: SortOrder
    montoOriginal?: SortOrder
    mes?: SortOrder
    anio?: SortOrder
    estiloId?: SortOrder
    pagada?: SortOrder
    fechaPago?: SortOrder
    fechaVencimiento?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeudaAvgOrderByAggregateInput = {
    id?: SortOrder
    alumnoId?: SortOrder
    monto?: SortOrder
    montoOriginal?: SortOrder
    anio?: SortOrder
    estiloId?: SortOrder
  }

  export type DeudaMaxOrderByAggregateInput = {
    id?: SortOrder
    alumnoId?: SortOrder
    monto?: SortOrder
    montoOriginal?: SortOrder
    mes?: SortOrder
    anio?: SortOrder
    estiloId?: SortOrder
    pagada?: SortOrder
    fechaPago?: SortOrder
    fechaVencimiento?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeudaMinOrderByAggregateInput = {
    id?: SortOrder
    alumnoId?: SortOrder
    monto?: SortOrder
    montoOriginal?: SortOrder
    mes?: SortOrder
    anio?: SortOrder
    estiloId?: SortOrder
    pagada?: SortOrder
    fechaPago?: SortOrder
    fechaVencimiento?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeudaSumOrderByAggregateInput = {
    id?: SortOrder
    alumnoId?: SortOrder
    monto?: SortOrder
    montoOriginal?: SortOrder
    anio?: SortOrder
    estiloId?: SortOrder
  }

  export type DeudaScalarRelationFilter = {
    is?: DeudaWhereInput
    isNot?: DeudaWhereInput
  }

  export type ReciboScalarRelationFilter = {
    is?: ReciboWhereInput
    isNot?: ReciboWhereInput
  }

  export type PagoDeudaCountOrderByAggregateInput = {
    id?: SortOrder
    deudaId?: SortOrder
    reciboId?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PagoDeudaAvgOrderByAggregateInput = {
    id?: SortOrder
    deudaId?: SortOrder
    reciboId?: SortOrder
    monto?: SortOrder
  }

  export type PagoDeudaMaxOrderByAggregateInput = {
    id?: SortOrder
    deudaId?: SortOrder
    reciboId?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PagoDeudaMinOrderByAggregateInput = {
    id?: SortOrder
    deudaId?: SortOrder
    reciboId?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PagoDeudaSumOrderByAggregateInput = {
    id?: SortOrder
    deudaId?: SortOrder
    reciboId?: SortOrder
    monto?: SortOrder
  }

  export type EstiloNullableScalarRelationFilter = {
    is?: EstiloWhereInput | null
    isNot?: EstiloWhereInput | null
  }

  export type ConceptoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    monto?: SortOrder
    estiloId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConceptoAvgOrderByAggregateInput = {
    id?: SortOrder
    monto?: SortOrder
    estiloId?: SortOrder
  }

  export type ConceptoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    monto?: SortOrder
    estiloId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConceptoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    monto?: SortOrder
    estiloId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConceptoSumOrderByAggregateInput = {
    id?: SortOrder
    monto?: SortOrder
    estiloId?: SortOrder
  }

  export type AlumnoNullableScalarRelationFilter = {
    is?: AlumnoWhereInput | null
    isNot?: AlumnoWhereInput | null
  }

  export type AlumnoSueltoNullableScalarRelationFilter = {
    is?: AlumnoSueltoWhereInput | null
    isNot?: AlumnoSueltoWhereInput | null
  }

  export type ConceptoScalarRelationFilter = {
    is?: ConceptoWhereInput
    isNot?: ConceptoWhereInput
  }

  export type DetalleLiquidacionListRelationFilter = {
    every?: DetalleLiquidacionWhereInput
    some?: DetalleLiquidacionWhereInput
    none?: DetalleLiquidacionWhereInput
  }

  export type ClaseNullableScalarRelationFilter = {
    is?: ClaseWhereInput | null
    isNot?: ClaseWhereInput | null
  }

  export type ReciboNullableScalarRelationFilter = {
    is?: ReciboWhereInput | null
    isNot?: ReciboWhereInput | null
  }

  export type DetalleLiquidacionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReciboCountOrderByAggregateInput = {
    id?: SortOrder
    numeroRecibo?: SortOrder
    fecha?: SortOrder
    fechaEfecto?: SortOrder
    monto?: SortOrder
    montoOriginal?: SortOrder
    descuento?: SortOrder
    periodoPago?: SortOrder
    tipoPago?: SortOrder
    fueraDeTermino?: SortOrder
    esClaseSuelta?: SortOrder
    esMesCompleto?: SortOrder
    alumnoId?: SortOrder
    alumnoSueltoId?: SortOrder
    conceptoId?: SortOrder
    claseId?: SortOrder
    anulado?: SortOrder
    motivoAnulacion?: SortOrder
    referenciaRecibo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReciboAvgOrderByAggregateInput = {
    id?: SortOrder
    numeroRecibo?: SortOrder
    monto?: SortOrder
    montoOriginal?: SortOrder
    descuento?: SortOrder
    alumnoId?: SortOrder
    alumnoSueltoId?: SortOrder
    conceptoId?: SortOrder
    claseId?: SortOrder
    referenciaRecibo?: SortOrder
  }

  export type ReciboMaxOrderByAggregateInput = {
    id?: SortOrder
    numeroRecibo?: SortOrder
    fecha?: SortOrder
    fechaEfecto?: SortOrder
    monto?: SortOrder
    montoOriginal?: SortOrder
    descuento?: SortOrder
    periodoPago?: SortOrder
    tipoPago?: SortOrder
    fueraDeTermino?: SortOrder
    esClaseSuelta?: SortOrder
    esMesCompleto?: SortOrder
    alumnoId?: SortOrder
    alumnoSueltoId?: SortOrder
    conceptoId?: SortOrder
    claseId?: SortOrder
    anulado?: SortOrder
    motivoAnulacion?: SortOrder
    referenciaRecibo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReciboMinOrderByAggregateInput = {
    id?: SortOrder
    numeroRecibo?: SortOrder
    fecha?: SortOrder
    fechaEfecto?: SortOrder
    monto?: SortOrder
    montoOriginal?: SortOrder
    descuento?: SortOrder
    periodoPago?: SortOrder
    tipoPago?: SortOrder
    fueraDeTermino?: SortOrder
    esClaseSuelta?: SortOrder
    esMesCompleto?: SortOrder
    alumnoId?: SortOrder
    alumnoSueltoId?: SortOrder
    conceptoId?: SortOrder
    claseId?: SortOrder
    anulado?: SortOrder
    motivoAnulacion?: SortOrder
    referenciaRecibo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReciboSumOrderByAggregateInput = {
    id?: SortOrder
    numeroRecibo?: SortOrder
    monto?: SortOrder
    montoOriginal?: SortOrder
    descuento?: SortOrder
    alumnoId?: SortOrder
    alumnoSueltoId?: SortOrder
    conceptoId?: SortOrder
    claseId?: SortOrder
    referenciaRecibo?: SortOrder
  }

  export type ConceptoListRelationFilter = {
    every?: ConceptoWhereInput
    some?: ConceptoWhereInput
    none?: ConceptoWhereInput
  }

  export type ClaseListRelationFilter = {
    every?: ClaseWhereInput
    some?: ClaseWhereInput
    none?: ClaseWhereInput
  }

  export type ProfesorNullableScalarRelationFilter = {
    is?: ProfesorWhereInput | null
    isNot?: ProfesorWhereInput | null
  }

  export type AlumnoListRelationFilter = {
    every?: AlumnoWhereInput
    some?: AlumnoWhereInput
    none?: AlumnoWhereInput
  }

  export type ConceptoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlumnoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EstiloCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    monto?: SortOrder
    descripcion?: SortOrder
    importe?: SortOrder
    profesorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EstiloAvgOrderByAggregateInput = {
    id?: SortOrder
    monto?: SortOrder
    importe?: SortOrder
    profesorId?: SortOrder
  }

  export type EstiloMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    monto?: SortOrder
    descripcion?: SortOrder
    importe?: SortOrder
    profesorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EstiloMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    monto?: SortOrder
    descripcion?: SortOrder
    importe?: SortOrder
    profesorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EstiloSumOrderByAggregateInput = {
    id?: SortOrder
    monto?: SortOrder
    importe?: SortOrder
    profesorId?: SortOrder
  }

  export type AlumnoEstilosAlumnoIdEstiloIdCompoundUniqueInput = {
    alumnoId: number
    estiloId: number
  }

  export type AlumnoEstilosCountOrderByAggregateInput = {
    id?: SortOrder
    alumnoId?: SortOrder
    estiloId?: SortOrder
    activo?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    montoPersonalizado?: SortOrder
    descuentoPersonalizado?: SortOrder
    observaciones?: SortOrder
  }

  export type AlumnoEstilosAvgOrderByAggregateInput = {
    id?: SortOrder
    alumnoId?: SortOrder
    estiloId?: SortOrder
    montoPersonalizado?: SortOrder
    descuentoPersonalizado?: SortOrder
  }

  export type AlumnoEstilosMaxOrderByAggregateInput = {
    id?: SortOrder
    alumnoId?: SortOrder
    estiloId?: SortOrder
    activo?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    montoPersonalizado?: SortOrder
    descuentoPersonalizado?: SortOrder
    observaciones?: SortOrder
  }

  export type AlumnoEstilosMinOrderByAggregateInput = {
    id?: SortOrder
    alumnoId?: SortOrder
    estiloId?: SortOrder
    activo?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    montoPersonalizado?: SortOrder
    descuentoPersonalizado?: SortOrder
    observaciones?: SortOrder
  }

  export type AlumnoEstilosSumOrderByAggregateInput = {
    id?: SortOrder
    alumnoId?: SortOrder
    estiloId?: SortOrder
    montoPersonalizado?: SortOrder
    descuentoPersonalizado?: SortOrder
  }

  export type LiquidacionListRelationFilter = {
    every?: LiquidacionWhereInput
    some?: LiquidacionWhereInput
    none?: LiquidacionWhereInput
  }

  export type LiquidacionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfesorCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    fechaNacimiento?: SortOrder
    direccion?: SortOrder
    cuit?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    fechaIngreso?: SortOrder
    porcentajePorDefecto?: SortOrder
    porcentajeClasesSueltasPorDefecto?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfesorAvgOrderByAggregateInput = {
    id?: SortOrder
    porcentajePorDefecto?: SortOrder
    porcentajeClasesSueltasPorDefecto?: SortOrder
  }

  export type ProfesorMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    fechaNacimiento?: SortOrder
    direccion?: SortOrder
    cuit?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    fechaIngreso?: SortOrder
    porcentajePorDefecto?: SortOrder
    porcentajeClasesSueltasPorDefecto?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfesorMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    fechaNacimiento?: SortOrder
    direccion?: SortOrder
    cuit?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    fechaIngreso?: SortOrder
    porcentajePorDefecto?: SortOrder
    porcentajeClasesSueltasPorDefecto?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfesorSumOrderByAggregateInput = {
    id?: SortOrder
    porcentajePorDefecto?: SortOrder
    porcentajeClasesSueltasPorDefecto?: SortOrder
  }

  export type CtaCteCountOrderByAggregateInput = {
    id?: SortOrder
    saldo?: SortOrder
    alumnoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CtaCteAvgOrderByAggregateInput = {
    id?: SortOrder
    saldo?: SortOrder
    alumnoId?: SortOrder
  }

  export type CtaCteMaxOrderByAggregateInput = {
    id?: SortOrder
    saldo?: SortOrder
    alumnoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CtaCteMinOrderByAggregateInput = {
    id?: SortOrder
    saldo?: SortOrder
    alumnoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CtaCteSumOrderByAggregateInput = {
    id?: SortOrder
    saldo?: SortOrder
    alumnoId?: SortOrder
  }

  export type CajaDiariaCountOrderByAggregateInput = {
    id?: SortOrder
    fecha?: SortOrder
    apertura?: SortOrder
    cierre?: SortOrder
    diferencia?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CajaDiariaAvgOrderByAggregateInput = {
    id?: SortOrder
    apertura?: SortOrder
    cierre?: SortOrder
    diferencia?: SortOrder
  }

  export type CajaDiariaMaxOrderByAggregateInput = {
    id?: SortOrder
    fecha?: SortOrder
    apertura?: SortOrder
    cierre?: SortOrder
    diferencia?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CajaDiariaMinOrderByAggregateInput = {
    id?: SortOrder
    fecha?: SortOrder
    apertura?: SortOrder
    cierre?: SortOrder
    diferencia?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CajaDiariaSumOrderByAggregateInput = {
    id?: SortOrder
    apertura?: SortOrder
    cierre?: SortOrder
    diferencia?: SortOrder
  }

  export type ProfesorScalarRelationFilter = {
    is?: ProfesorWhereInput
    isNot?: ProfesorWhereInput
  }

  export type ClaseCountOrderByAggregateInput = {
    id?: SortOrder
    fecha?: SortOrder
    profesorId?: SortOrder
    estiloId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClaseAvgOrderByAggregateInput = {
    id?: SortOrder
    profesorId?: SortOrder
    estiloId?: SortOrder
  }

  export type ClaseMaxOrderByAggregateInput = {
    id?: SortOrder
    fecha?: SortOrder
    profesorId?: SortOrder
    estiloId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClaseMinOrderByAggregateInput = {
    id?: SortOrder
    fecha?: SortOrder
    profesorId?: SortOrder
    estiloId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClaseSumOrderByAggregateInput = {
    id?: SortOrder
    profesorId?: SortOrder
    estiloId?: SortOrder
  }

  export type ClaseScalarRelationFilter = {
    is?: ClaseWhereInput
    isNot?: ClaseWhereInput
  }

  export type AsistenciaCountOrderByAggregateInput = {
    id?: SortOrder
    claseId?: SortOrder
    alumnoId?: SortOrder
    asistio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AsistenciaAvgOrderByAggregateInput = {
    id?: SortOrder
    claseId?: SortOrder
    alumnoId?: SortOrder
  }

  export type AsistenciaMaxOrderByAggregateInput = {
    id?: SortOrder
    claseId?: SortOrder
    alumnoId?: SortOrder
    asistio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AsistenciaMinOrderByAggregateInput = {
    id?: SortOrder
    claseId?: SortOrder
    alumnoId?: SortOrder
    asistio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AsistenciaSumOrderByAggregateInput = {
    id?: SortOrder
    claseId?: SortOrder
    alumnoId?: SortOrder
  }

  export type AlumnoSueltoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
    email?: SortOrder
    alumnoRegularId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlumnoSueltoAvgOrderByAggregateInput = {
    id?: SortOrder
    alumnoRegularId?: SortOrder
  }

  export type AlumnoSueltoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
    email?: SortOrder
    alumnoRegularId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlumnoSueltoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
    email?: SortOrder
    alumnoRegularId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlumnoSueltoSumOrderByAggregateInput = {
    id?: SortOrder
    alumnoRegularId?: SortOrder
  }

  export type EnumEstadoLiquidacionFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoLiquidacion | EnumEstadoLiquidacionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoLiquidacion[] | ListEnumEstadoLiquidacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoLiquidacion[] | ListEnumEstadoLiquidacionFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoLiquidacionFilter<$PrismaModel> | $Enums.EstadoLiquidacion
  }

  export type EnumTipoPagoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoPago | EnumTipoPagoFieldRefInput<$PrismaModel> | null
    in?: $Enums.TipoPago[] | ListEnumTipoPagoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TipoPago[] | ListEnumTipoPagoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTipoPagoNullableFilter<$PrismaModel> | $Enums.TipoPago | null
  }

  export type LiquidacionCountOrderByAggregateInput = {
    id?: SortOrder
    fecha?: SortOrder
    mes?: SortOrder
    anio?: SortOrder
    profesorId?: SortOrder
    montoTotal?: SortOrder
    montoCursos?: SortOrder
    montoClasesSueltas?: SortOrder
    porcentajeCursos?: SortOrder
    porcentajeClasesSueltas?: SortOrder
    estado?: SortOrder
    metodoPago?: SortOrder
    fechaPago?: SortOrder
    observaciones?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LiquidacionAvgOrderByAggregateInput = {
    id?: SortOrder
    mes?: SortOrder
    anio?: SortOrder
    profesorId?: SortOrder
    montoTotal?: SortOrder
    montoCursos?: SortOrder
    montoClasesSueltas?: SortOrder
    porcentajeCursos?: SortOrder
    porcentajeClasesSueltas?: SortOrder
  }

  export type LiquidacionMaxOrderByAggregateInput = {
    id?: SortOrder
    fecha?: SortOrder
    mes?: SortOrder
    anio?: SortOrder
    profesorId?: SortOrder
    montoTotal?: SortOrder
    montoCursos?: SortOrder
    montoClasesSueltas?: SortOrder
    porcentajeCursos?: SortOrder
    porcentajeClasesSueltas?: SortOrder
    estado?: SortOrder
    metodoPago?: SortOrder
    fechaPago?: SortOrder
    observaciones?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LiquidacionMinOrderByAggregateInput = {
    id?: SortOrder
    fecha?: SortOrder
    mes?: SortOrder
    anio?: SortOrder
    profesorId?: SortOrder
    montoTotal?: SortOrder
    montoCursos?: SortOrder
    montoClasesSueltas?: SortOrder
    porcentajeCursos?: SortOrder
    porcentajeClasesSueltas?: SortOrder
    estado?: SortOrder
    metodoPago?: SortOrder
    fechaPago?: SortOrder
    observaciones?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LiquidacionSumOrderByAggregateInput = {
    id?: SortOrder
    mes?: SortOrder
    anio?: SortOrder
    profesorId?: SortOrder
    montoTotal?: SortOrder
    montoCursos?: SortOrder
    montoClasesSueltas?: SortOrder
    porcentajeCursos?: SortOrder
    porcentajeClasesSueltas?: SortOrder
  }

  export type EnumEstadoLiquidacionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoLiquidacion | EnumEstadoLiquidacionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoLiquidacion[] | ListEnumEstadoLiquidacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoLiquidacion[] | ListEnumEstadoLiquidacionFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoLiquidacionWithAggregatesFilter<$PrismaModel> | $Enums.EstadoLiquidacion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoLiquidacionFilter<$PrismaModel>
    _max?: NestedEnumEstadoLiquidacionFilter<$PrismaModel>
  }

  export type EnumTipoPagoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoPago | EnumTipoPagoFieldRefInput<$PrismaModel> | null
    in?: $Enums.TipoPago[] | ListEnumTipoPagoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TipoPago[] | ListEnumTipoPagoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTipoPagoNullableWithAggregatesFilter<$PrismaModel> | $Enums.TipoPago | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTipoPagoNullableFilter<$PrismaModel>
    _max?: NestedEnumTipoPagoNullableFilter<$PrismaModel>
  }

  export type LiquidacionScalarRelationFilter = {
    is?: LiquidacionWhereInput
    isNot?: LiquidacionWhereInput
  }

  export type DetalleLiquidacionCountOrderByAggregateInput = {
    id?: SortOrder
    liquidacionId?: SortOrder
    reciboId?: SortOrder
    montoOriginal?: SortOrder
    porcentaje?: SortOrder
    montoLiquidado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DetalleLiquidacionAvgOrderByAggregateInput = {
    id?: SortOrder
    liquidacionId?: SortOrder
    reciboId?: SortOrder
    montoOriginal?: SortOrder
    porcentaje?: SortOrder
    montoLiquidado?: SortOrder
  }

  export type DetalleLiquidacionMaxOrderByAggregateInput = {
    id?: SortOrder
    liquidacionId?: SortOrder
    reciboId?: SortOrder
    montoOriginal?: SortOrder
    porcentaje?: SortOrder
    montoLiquidado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DetalleLiquidacionMinOrderByAggregateInput = {
    id?: SortOrder
    liquidacionId?: SortOrder
    reciboId?: SortOrder
    montoOriginal?: SortOrder
    porcentaje?: SortOrder
    montoLiquidado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DetalleLiquidacionSumOrderByAggregateInput = {
    id?: SortOrder
    liquidacionId?: SortOrder
    reciboId?: SortOrder
    montoOriginal?: SortOrder
    porcentaje?: SortOrder
    montoLiquidado?: SortOrder
  }

  export type ReciboCreateNestedManyWithoutAlumnoInput = {
    create?: XOR<ReciboCreateWithoutAlumnoInput, ReciboUncheckedCreateWithoutAlumnoInput> | ReciboCreateWithoutAlumnoInput[] | ReciboUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: ReciboCreateOrConnectWithoutAlumnoInput | ReciboCreateOrConnectWithoutAlumnoInput[]
    createMany?: ReciboCreateManyAlumnoInputEnvelope
    connect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
  }

  export type AlumnoSueltoCreateNestedManyWithoutAlumnoRegularInput = {
    create?: XOR<AlumnoSueltoCreateWithoutAlumnoRegularInput, AlumnoSueltoUncheckedCreateWithoutAlumnoRegularInput> | AlumnoSueltoCreateWithoutAlumnoRegularInput[] | AlumnoSueltoUncheckedCreateWithoutAlumnoRegularInput[]
    connectOrCreate?: AlumnoSueltoCreateOrConnectWithoutAlumnoRegularInput | AlumnoSueltoCreateOrConnectWithoutAlumnoRegularInput[]
    createMany?: AlumnoSueltoCreateManyAlumnoRegularInputEnvelope
    connect?: AlumnoSueltoWhereUniqueInput | AlumnoSueltoWhereUniqueInput[]
  }

  export type CtaCteCreateNestedOneWithoutAlumnoInput = {
    create?: XOR<CtaCteCreateWithoutAlumnoInput, CtaCteUncheckedCreateWithoutAlumnoInput>
    connectOrCreate?: CtaCteCreateOrConnectWithoutAlumnoInput
    connect?: CtaCteWhereUniqueInput
  }

  export type EstiloCreateNestedManyWithoutAlumnosInput = {
    create?: XOR<EstiloCreateWithoutAlumnosInput, EstiloUncheckedCreateWithoutAlumnosInput> | EstiloCreateWithoutAlumnosInput[] | EstiloUncheckedCreateWithoutAlumnosInput[]
    connectOrCreate?: EstiloCreateOrConnectWithoutAlumnosInput | EstiloCreateOrConnectWithoutAlumnosInput[]
    connect?: EstiloWhereUniqueInput | EstiloWhereUniqueInput[]
  }

  export type AsistenciaCreateNestedManyWithoutAlumnoInput = {
    create?: XOR<AsistenciaCreateWithoutAlumnoInput, AsistenciaUncheckedCreateWithoutAlumnoInput> | AsistenciaCreateWithoutAlumnoInput[] | AsistenciaUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: AsistenciaCreateOrConnectWithoutAlumnoInput | AsistenciaCreateOrConnectWithoutAlumnoInput[]
    createMany?: AsistenciaCreateManyAlumnoInputEnvelope
    connect?: AsistenciaWhereUniqueInput | AsistenciaWhereUniqueInput[]
  }

  export type AlumnoEstilosCreateNestedManyWithoutAlumnoInput = {
    create?: XOR<AlumnoEstilosCreateWithoutAlumnoInput, AlumnoEstilosUncheckedCreateWithoutAlumnoInput> | AlumnoEstilosCreateWithoutAlumnoInput[] | AlumnoEstilosUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: AlumnoEstilosCreateOrConnectWithoutAlumnoInput | AlumnoEstilosCreateOrConnectWithoutAlumnoInput[]
    createMany?: AlumnoEstilosCreateManyAlumnoInputEnvelope
    connect?: AlumnoEstilosWhereUniqueInput | AlumnoEstilosWhereUniqueInput[]
  }

  export type DeudaCreateNestedManyWithoutAlumnoInput = {
    create?: XOR<DeudaCreateWithoutAlumnoInput, DeudaUncheckedCreateWithoutAlumnoInput> | DeudaCreateWithoutAlumnoInput[] | DeudaUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: DeudaCreateOrConnectWithoutAlumnoInput | DeudaCreateOrConnectWithoutAlumnoInput[]
    createMany?: DeudaCreateManyAlumnoInputEnvelope
    connect?: DeudaWhereUniqueInput | DeudaWhereUniqueInput[]
  }

  export type DescuentoAplicadoCreateNestedManyWithoutAlumnoInput = {
    create?: XOR<DescuentoAplicadoCreateWithoutAlumnoInput, DescuentoAplicadoUncheckedCreateWithoutAlumnoInput> | DescuentoAplicadoCreateWithoutAlumnoInput[] | DescuentoAplicadoUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: DescuentoAplicadoCreateOrConnectWithoutAlumnoInput | DescuentoAplicadoCreateOrConnectWithoutAlumnoInput[]
    createMany?: DescuentoAplicadoCreateManyAlumnoInputEnvelope
    connect?: DescuentoAplicadoWhereUniqueInput | DescuentoAplicadoWhereUniqueInput[]
  }

  export type ConfiguracionPagoAlumnoCreateNestedOneWithoutAlumnoInput = {
    create?: XOR<ConfiguracionPagoAlumnoCreateWithoutAlumnoInput, ConfiguracionPagoAlumnoUncheckedCreateWithoutAlumnoInput>
    connectOrCreate?: ConfiguracionPagoAlumnoCreateOrConnectWithoutAlumnoInput
    connect?: ConfiguracionPagoAlumnoWhereUniqueInput
  }

  export type ReciboUncheckedCreateNestedManyWithoutAlumnoInput = {
    create?: XOR<ReciboCreateWithoutAlumnoInput, ReciboUncheckedCreateWithoutAlumnoInput> | ReciboCreateWithoutAlumnoInput[] | ReciboUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: ReciboCreateOrConnectWithoutAlumnoInput | ReciboCreateOrConnectWithoutAlumnoInput[]
    createMany?: ReciboCreateManyAlumnoInputEnvelope
    connect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
  }

  export type AlumnoSueltoUncheckedCreateNestedManyWithoutAlumnoRegularInput = {
    create?: XOR<AlumnoSueltoCreateWithoutAlumnoRegularInput, AlumnoSueltoUncheckedCreateWithoutAlumnoRegularInput> | AlumnoSueltoCreateWithoutAlumnoRegularInput[] | AlumnoSueltoUncheckedCreateWithoutAlumnoRegularInput[]
    connectOrCreate?: AlumnoSueltoCreateOrConnectWithoutAlumnoRegularInput | AlumnoSueltoCreateOrConnectWithoutAlumnoRegularInput[]
    createMany?: AlumnoSueltoCreateManyAlumnoRegularInputEnvelope
    connect?: AlumnoSueltoWhereUniqueInput | AlumnoSueltoWhereUniqueInput[]
  }

  export type CtaCteUncheckedCreateNestedOneWithoutAlumnoInput = {
    create?: XOR<CtaCteCreateWithoutAlumnoInput, CtaCteUncheckedCreateWithoutAlumnoInput>
    connectOrCreate?: CtaCteCreateOrConnectWithoutAlumnoInput
    connect?: CtaCteWhereUniqueInput
  }

  export type EstiloUncheckedCreateNestedManyWithoutAlumnosInput = {
    create?: XOR<EstiloCreateWithoutAlumnosInput, EstiloUncheckedCreateWithoutAlumnosInput> | EstiloCreateWithoutAlumnosInput[] | EstiloUncheckedCreateWithoutAlumnosInput[]
    connectOrCreate?: EstiloCreateOrConnectWithoutAlumnosInput | EstiloCreateOrConnectWithoutAlumnosInput[]
    connect?: EstiloWhereUniqueInput | EstiloWhereUniqueInput[]
  }

  export type AsistenciaUncheckedCreateNestedManyWithoutAlumnoInput = {
    create?: XOR<AsistenciaCreateWithoutAlumnoInput, AsistenciaUncheckedCreateWithoutAlumnoInput> | AsistenciaCreateWithoutAlumnoInput[] | AsistenciaUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: AsistenciaCreateOrConnectWithoutAlumnoInput | AsistenciaCreateOrConnectWithoutAlumnoInput[]
    createMany?: AsistenciaCreateManyAlumnoInputEnvelope
    connect?: AsistenciaWhereUniqueInput | AsistenciaWhereUniqueInput[]
  }

  export type AlumnoEstilosUncheckedCreateNestedManyWithoutAlumnoInput = {
    create?: XOR<AlumnoEstilosCreateWithoutAlumnoInput, AlumnoEstilosUncheckedCreateWithoutAlumnoInput> | AlumnoEstilosCreateWithoutAlumnoInput[] | AlumnoEstilosUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: AlumnoEstilosCreateOrConnectWithoutAlumnoInput | AlumnoEstilosCreateOrConnectWithoutAlumnoInput[]
    createMany?: AlumnoEstilosCreateManyAlumnoInputEnvelope
    connect?: AlumnoEstilosWhereUniqueInput | AlumnoEstilosWhereUniqueInput[]
  }

  export type DeudaUncheckedCreateNestedManyWithoutAlumnoInput = {
    create?: XOR<DeudaCreateWithoutAlumnoInput, DeudaUncheckedCreateWithoutAlumnoInput> | DeudaCreateWithoutAlumnoInput[] | DeudaUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: DeudaCreateOrConnectWithoutAlumnoInput | DeudaCreateOrConnectWithoutAlumnoInput[]
    createMany?: DeudaCreateManyAlumnoInputEnvelope
    connect?: DeudaWhereUniqueInput | DeudaWhereUniqueInput[]
  }

  export type DescuentoAplicadoUncheckedCreateNestedManyWithoutAlumnoInput = {
    create?: XOR<DescuentoAplicadoCreateWithoutAlumnoInput, DescuentoAplicadoUncheckedCreateWithoutAlumnoInput> | DescuentoAplicadoCreateWithoutAlumnoInput[] | DescuentoAplicadoUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: DescuentoAplicadoCreateOrConnectWithoutAlumnoInput | DescuentoAplicadoCreateOrConnectWithoutAlumnoInput[]
    createMany?: DescuentoAplicadoCreateManyAlumnoInputEnvelope
    connect?: DescuentoAplicadoWhereUniqueInput | DescuentoAplicadoWhereUniqueInput[]
  }

  export type ConfiguracionPagoAlumnoUncheckedCreateNestedOneWithoutAlumnoInput = {
    create?: XOR<ConfiguracionPagoAlumnoCreateWithoutAlumnoInput, ConfiguracionPagoAlumnoUncheckedCreateWithoutAlumnoInput>
    connectOrCreate?: ConfiguracionPagoAlumnoCreateOrConnectWithoutAlumnoInput
    connect?: ConfiguracionPagoAlumnoWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ReciboUpdateManyWithoutAlumnoNestedInput = {
    create?: XOR<ReciboCreateWithoutAlumnoInput, ReciboUncheckedCreateWithoutAlumnoInput> | ReciboCreateWithoutAlumnoInput[] | ReciboUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: ReciboCreateOrConnectWithoutAlumnoInput | ReciboCreateOrConnectWithoutAlumnoInput[]
    upsert?: ReciboUpsertWithWhereUniqueWithoutAlumnoInput | ReciboUpsertWithWhereUniqueWithoutAlumnoInput[]
    createMany?: ReciboCreateManyAlumnoInputEnvelope
    set?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    disconnect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    delete?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    connect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    update?: ReciboUpdateWithWhereUniqueWithoutAlumnoInput | ReciboUpdateWithWhereUniqueWithoutAlumnoInput[]
    updateMany?: ReciboUpdateManyWithWhereWithoutAlumnoInput | ReciboUpdateManyWithWhereWithoutAlumnoInput[]
    deleteMany?: ReciboScalarWhereInput | ReciboScalarWhereInput[]
  }

  export type AlumnoSueltoUpdateManyWithoutAlumnoRegularNestedInput = {
    create?: XOR<AlumnoSueltoCreateWithoutAlumnoRegularInput, AlumnoSueltoUncheckedCreateWithoutAlumnoRegularInput> | AlumnoSueltoCreateWithoutAlumnoRegularInput[] | AlumnoSueltoUncheckedCreateWithoutAlumnoRegularInput[]
    connectOrCreate?: AlumnoSueltoCreateOrConnectWithoutAlumnoRegularInput | AlumnoSueltoCreateOrConnectWithoutAlumnoRegularInput[]
    upsert?: AlumnoSueltoUpsertWithWhereUniqueWithoutAlumnoRegularInput | AlumnoSueltoUpsertWithWhereUniqueWithoutAlumnoRegularInput[]
    createMany?: AlumnoSueltoCreateManyAlumnoRegularInputEnvelope
    set?: AlumnoSueltoWhereUniqueInput | AlumnoSueltoWhereUniqueInput[]
    disconnect?: AlumnoSueltoWhereUniqueInput | AlumnoSueltoWhereUniqueInput[]
    delete?: AlumnoSueltoWhereUniqueInput | AlumnoSueltoWhereUniqueInput[]
    connect?: AlumnoSueltoWhereUniqueInput | AlumnoSueltoWhereUniqueInput[]
    update?: AlumnoSueltoUpdateWithWhereUniqueWithoutAlumnoRegularInput | AlumnoSueltoUpdateWithWhereUniqueWithoutAlumnoRegularInput[]
    updateMany?: AlumnoSueltoUpdateManyWithWhereWithoutAlumnoRegularInput | AlumnoSueltoUpdateManyWithWhereWithoutAlumnoRegularInput[]
    deleteMany?: AlumnoSueltoScalarWhereInput | AlumnoSueltoScalarWhereInput[]
  }

  export type CtaCteUpdateOneWithoutAlumnoNestedInput = {
    create?: XOR<CtaCteCreateWithoutAlumnoInput, CtaCteUncheckedCreateWithoutAlumnoInput>
    connectOrCreate?: CtaCteCreateOrConnectWithoutAlumnoInput
    upsert?: CtaCteUpsertWithoutAlumnoInput
    disconnect?: CtaCteWhereInput | boolean
    delete?: CtaCteWhereInput | boolean
    connect?: CtaCteWhereUniqueInput
    update?: XOR<XOR<CtaCteUpdateToOneWithWhereWithoutAlumnoInput, CtaCteUpdateWithoutAlumnoInput>, CtaCteUncheckedUpdateWithoutAlumnoInput>
  }

  export type EstiloUpdateManyWithoutAlumnosNestedInput = {
    create?: XOR<EstiloCreateWithoutAlumnosInput, EstiloUncheckedCreateWithoutAlumnosInput> | EstiloCreateWithoutAlumnosInput[] | EstiloUncheckedCreateWithoutAlumnosInput[]
    connectOrCreate?: EstiloCreateOrConnectWithoutAlumnosInput | EstiloCreateOrConnectWithoutAlumnosInput[]
    upsert?: EstiloUpsertWithWhereUniqueWithoutAlumnosInput | EstiloUpsertWithWhereUniqueWithoutAlumnosInput[]
    set?: EstiloWhereUniqueInput | EstiloWhereUniqueInput[]
    disconnect?: EstiloWhereUniqueInput | EstiloWhereUniqueInput[]
    delete?: EstiloWhereUniqueInput | EstiloWhereUniqueInput[]
    connect?: EstiloWhereUniqueInput | EstiloWhereUniqueInput[]
    update?: EstiloUpdateWithWhereUniqueWithoutAlumnosInput | EstiloUpdateWithWhereUniqueWithoutAlumnosInput[]
    updateMany?: EstiloUpdateManyWithWhereWithoutAlumnosInput | EstiloUpdateManyWithWhereWithoutAlumnosInput[]
    deleteMany?: EstiloScalarWhereInput | EstiloScalarWhereInput[]
  }

  export type AsistenciaUpdateManyWithoutAlumnoNestedInput = {
    create?: XOR<AsistenciaCreateWithoutAlumnoInput, AsistenciaUncheckedCreateWithoutAlumnoInput> | AsistenciaCreateWithoutAlumnoInput[] | AsistenciaUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: AsistenciaCreateOrConnectWithoutAlumnoInput | AsistenciaCreateOrConnectWithoutAlumnoInput[]
    upsert?: AsistenciaUpsertWithWhereUniqueWithoutAlumnoInput | AsistenciaUpsertWithWhereUniqueWithoutAlumnoInput[]
    createMany?: AsistenciaCreateManyAlumnoInputEnvelope
    set?: AsistenciaWhereUniqueInput | AsistenciaWhereUniqueInput[]
    disconnect?: AsistenciaWhereUniqueInput | AsistenciaWhereUniqueInput[]
    delete?: AsistenciaWhereUniqueInput | AsistenciaWhereUniqueInput[]
    connect?: AsistenciaWhereUniqueInput | AsistenciaWhereUniqueInput[]
    update?: AsistenciaUpdateWithWhereUniqueWithoutAlumnoInput | AsistenciaUpdateWithWhereUniqueWithoutAlumnoInput[]
    updateMany?: AsistenciaUpdateManyWithWhereWithoutAlumnoInput | AsistenciaUpdateManyWithWhereWithoutAlumnoInput[]
    deleteMany?: AsistenciaScalarWhereInput | AsistenciaScalarWhereInput[]
  }

  export type AlumnoEstilosUpdateManyWithoutAlumnoNestedInput = {
    create?: XOR<AlumnoEstilosCreateWithoutAlumnoInput, AlumnoEstilosUncheckedCreateWithoutAlumnoInput> | AlumnoEstilosCreateWithoutAlumnoInput[] | AlumnoEstilosUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: AlumnoEstilosCreateOrConnectWithoutAlumnoInput | AlumnoEstilosCreateOrConnectWithoutAlumnoInput[]
    upsert?: AlumnoEstilosUpsertWithWhereUniqueWithoutAlumnoInput | AlumnoEstilosUpsertWithWhereUniqueWithoutAlumnoInput[]
    createMany?: AlumnoEstilosCreateManyAlumnoInputEnvelope
    set?: AlumnoEstilosWhereUniqueInput | AlumnoEstilosWhereUniqueInput[]
    disconnect?: AlumnoEstilosWhereUniqueInput | AlumnoEstilosWhereUniqueInput[]
    delete?: AlumnoEstilosWhereUniqueInput | AlumnoEstilosWhereUniqueInput[]
    connect?: AlumnoEstilosWhereUniqueInput | AlumnoEstilosWhereUniqueInput[]
    update?: AlumnoEstilosUpdateWithWhereUniqueWithoutAlumnoInput | AlumnoEstilosUpdateWithWhereUniqueWithoutAlumnoInput[]
    updateMany?: AlumnoEstilosUpdateManyWithWhereWithoutAlumnoInput | AlumnoEstilosUpdateManyWithWhereWithoutAlumnoInput[]
    deleteMany?: AlumnoEstilosScalarWhereInput | AlumnoEstilosScalarWhereInput[]
  }

  export type DeudaUpdateManyWithoutAlumnoNestedInput = {
    create?: XOR<DeudaCreateWithoutAlumnoInput, DeudaUncheckedCreateWithoutAlumnoInput> | DeudaCreateWithoutAlumnoInput[] | DeudaUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: DeudaCreateOrConnectWithoutAlumnoInput | DeudaCreateOrConnectWithoutAlumnoInput[]
    upsert?: DeudaUpsertWithWhereUniqueWithoutAlumnoInput | DeudaUpsertWithWhereUniqueWithoutAlumnoInput[]
    createMany?: DeudaCreateManyAlumnoInputEnvelope
    set?: DeudaWhereUniqueInput | DeudaWhereUniqueInput[]
    disconnect?: DeudaWhereUniqueInput | DeudaWhereUniqueInput[]
    delete?: DeudaWhereUniqueInput | DeudaWhereUniqueInput[]
    connect?: DeudaWhereUniqueInput | DeudaWhereUniqueInput[]
    update?: DeudaUpdateWithWhereUniqueWithoutAlumnoInput | DeudaUpdateWithWhereUniqueWithoutAlumnoInput[]
    updateMany?: DeudaUpdateManyWithWhereWithoutAlumnoInput | DeudaUpdateManyWithWhereWithoutAlumnoInput[]
    deleteMany?: DeudaScalarWhereInput | DeudaScalarWhereInput[]
  }

  export type DescuentoAplicadoUpdateManyWithoutAlumnoNestedInput = {
    create?: XOR<DescuentoAplicadoCreateWithoutAlumnoInput, DescuentoAplicadoUncheckedCreateWithoutAlumnoInput> | DescuentoAplicadoCreateWithoutAlumnoInput[] | DescuentoAplicadoUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: DescuentoAplicadoCreateOrConnectWithoutAlumnoInput | DescuentoAplicadoCreateOrConnectWithoutAlumnoInput[]
    upsert?: DescuentoAplicadoUpsertWithWhereUniqueWithoutAlumnoInput | DescuentoAplicadoUpsertWithWhereUniqueWithoutAlumnoInput[]
    createMany?: DescuentoAplicadoCreateManyAlumnoInputEnvelope
    set?: DescuentoAplicadoWhereUniqueInput | DescuentoAplicadoWhereUniqueInput[]
    disconnect?: DescuentoAplicadoWhereUniqueInput | DescuentoAplicadoWhereUniqueInput[]
    delete?: DescuentoAplicadoWhereUniqueInput | DescuentoAplicadoWhereUniqueInput[]
    connect?: DescuentoAplicadoWhereUniqueInput | DescuentoAplicadoWhereUniqueInput[]
    update?: DescuentoAplicadoUpdateWithWhereUniqueWithoutAlumnoInput | DescuentoAplicadoUpdateWithWhereUniqueWithoutAlumnoInput[]
    updateMany?: DescuentoAplicadoUpdateManyWithWhereWithoutAlumnoInput | DescuentoAplicadoUpdateManyWithWhereWithoutAlumnoInput[]
    deleteMany?: DescuentoAplicadoScalarWhereInput | DescuentoAplicadoScalarWhereInput[]
  }

  export type ConfiguracionPagoAlumnoUpdateOneWithoutAlumnoNestedInput = {
    create?: XOR<ConfiguracionPagoAlumnoCreateWithoutAlumnoInput, ConfiguracionPagoAlumnoUncheckedCreateWithoutAlumnoInput>
    connectOrCreate?: ConfiguracionPagoAlumnoCreateOrConnectWithoutAlumnoInput
    upsert?: ConfiguracionPagoAlumnoUpsertWithoutAlumnoInput
    disconnect?: ConfiguracionPagoAlumnoWhereInput | boolean
    delete?: ConfiguracionPagoAlumnoWhereInput | boolean
    connect?: ConfiguracionPagoAlumnoWhereUniqueInput
    update?: XOR<XOR<ConfiguracionPagoAlumnoUpdateToOneWithWhereWithoutAlumnoInput, ConfiguracionPagoAlumnoUpdateWithoutAlumnoInput>, ConfiguracionPagoAlumnoUncheckedUpdateWithoutAlumnoInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ReciboUncheckedUpdateManyWithoutAlumnoNestedInput = {
    create?: XOR<ReciboCreateWithoutAlumnoInput, ReciboUncheckedCreateWithoutAlumnoInput> | ReciboCreateWithoutAlumnoInput[] | ReciboUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: ReciboCreateOrConnectWithoutAlumnoInput | ReciboCreateOrConnectWithoutAlumnoInput[]
    upsert?: ReciboUpsertWithWhereUniqueWithoutAlumnoInput | ReciboUpsertWithWhereUniqueWithoutAlumnoInput[]
    createMany?: ReciboCreateManyAlumnoInputEnvelope
    set?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    disconnect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    delete?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    connect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    update?: ReciboUpdateWithWhereUniqueWithoutAlumnoInput | ReciboUpdateWithWhereUniqueWithoutAlumnoInput[]
    updateMany?: ReciboUpdateManyWithWhereWithoutAlumnoInput | ReciboUpdateManyWithWhereWithoutAlumnoInput[]
    deleteMany?: ReciboScalarWhereInput | ReciboScalarWhereInput[]
  }

  export type AlumnoSueltoUncheckedUpdateManyWithoutAlumnoRegularNestedInput = {
    create?: XOR<AlumnoSueltoCreateWithoutAlumnoRegularInput, AlumnoSueltoUncheckedCreateWithoutAlumnoRegularInput> | AlumnoSueltoCreateWithoutAlumnoRegularInput[] | AlumnoSueltoUncheckedCreateWithoutAlumnoRegularInput[]
    connectOrCreate?: AlumnoSueltoCreateOrConnectWithoutAlumnoRegularInput | AlumnoSueltoCreateOrConnectWithoutAlumnoRegularInput[]
    upsert?: AlumnoSueltoUpsertWithWhereUniqueWithoutAlumnoRegularInput | AlumnoSueltoUpsertWithWhereUniqueWithoutAlumnoRegularInput[]
    createMany?: AlumnoSueltoCreateManyAlumnoRegularInputEnvelope
    set?: AlumnoSueltoWhereUniqueInput | AlumnoSueltoWhereUniqueInput[]
    disconnect?: AlumnoSueltoWhereUniqueInput | AlumnoSueltoWhereUniqueInput[]
    delete?: AlumnoSueltoWhereUniqueInput | AlumnoSueltoWhereUniqueInput[]
    connect?: AlumnoSueltoWhereUniqueInput | AlumnoSueltoWhereUniqueInput[]
    update?: AlumnoSueltoUpdateWithWhereUniqueWithoutAlumnoRegularInput | AlumnoSueltoUpdateWithWhereUniqueWithoutAlumnoRegularInput[]
    updateMany?: AlumnoSueltoUpdateManyWithWhereWithoutAlumnoRegularInput | AlumnoSueltoUpdateManyWithWhereWithoutAlumnoRegularInput[]
    deleteMany?: AlumnoSueltoScalarWhereInput | AlumnoSueltoScalarWhereInput[]
  }

  export type CtaCteUncheckedUpdateOneWithoutAlumnoNestedInput = {
    create?: XOR<CtaCteCreateWithoutAlumnoInput, CtaCteUncheckedCreateWithoutAlumnoInput>
    connectOrCreate?: CtaCteCreateOrConnectWithoutAlumnoInput
    upsert?: CtaCteUpsertWithoutAlumnoInput
    disconnect?: CtaCteWhereInput | boolean
    delete?: CtaCteWhereInput | boolean
    connect?: CtaCteWhereUniqueInput
    update?: XOR<XOR<CtaCteUpdateToOneWithWhereWithoutAlumnoInput, CtaCteUpdateWithoutAlumnoInput>, CtaCteUncheckedUpdateWithoutAlumnoInput>
  }

  export type EstiloUncheckedUpdateManyWithoutAlumnosNestedInput = {
    create?: XOR<EstiloCreateWithoutAlumnosInput, EstiloUncheckedCreateWithoutAlumnosInput> | EstiloCreateWithoutAlumnosInput[] | EstiloUncheckedCreateWithoutAlumnosInput[]
    connectOrCreate?: EstiloCreateOrConnectWithoutAlumnosInput | EstiloCreateOrConnectWithoutAlumnosInput[]
    upsert?: EstiloUpsertWithWhereUniqueWithoutAlumnosInput | EstiloUpsertWithWhereUniqueWithoutAlumnosInput[]
    set?: EstiloWhereUniqueInput | EstiloWhereUniqueInput[]
    disconnect?: EstiloWhereUniqueInput | EstiloWhereUniqueInput[]
    delete?: EstiloWhereUniqueInput | EstiloWhereUniqueInput[]
    connect?: EstiloWhereUniqueInput | EstiloWhereUniqueInput[]
    update?: EstiloUpdateWithWhereUniqueWithoutAlumnosInput | EstiloUpdateWithWhereUniqueWithoutAlumnosInput[]
    updateMany?: EstiloUpdateManyWithWhereWithoutAlumnosInput | EstiloUpdateManyWithWhereWithoutAlumnosInput[]
    deleteMany?: EstiloScalarWhereInput | EstiloScalarWhereInput[]
  }

  export type AsistenciaUncheckedUpdateManyWithoutAlumnoNestedInput = {
    create?: XOR<AsistenciaCreateWithoutAlumnoInput, AsistenciaUncheckedCreateWithoutAlumnoInput> | AsistenciaCreateWithoutAlumnoInput[] | AsistenciaUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: AsistenciaCreateOrConnectWithoutAlumnoInput | AsistenciaCreateOrConnectWithoutAlumnoInput[]
    upsert?: AsistenciaUpsertWithWhereUniqueWithoutAlumnoInput | AsistenciaUpsertWithWhereUniqueWithoutAlumnoInput[]
    createMany?: AsistenciaCreateManyAlumnoInputEnvelope
    set?: AsistenciaWhereUniqueInput | AsistenciaWhereUniqueInput[]
    disconnect?: AsistenciaWhereUniqueInput | AsistenciaWhereUniqueInput[]
    delete?: AsistenciaWhereUniqueInput | AsistenciaWhereUniqueInput[]
    connect?: AsistenciaWhereUniqueInput | AsistenciaWhereUniqueInput[]
    update?: AsistenciaUpdateWithWhereUniqueWithoutAlumnoInput | AsistenciaUpdateWithWhereUniqueWithoutAlumnoInput[]
    updateMany?: AsistenciaUpdateManyWithWhereWithoutAlumnoInput | AsistenciaUpdateManyWithWhereWithoutAlumnoInput[]
    deleteMany?: AsistenciaScalarWhereInput | AsistenciaScalarWhereInput[]
  }

  export type AlumnoEstilosUncheckedUpdateManyWithoutAlumnoNestedInput = {
    create?: XOR<AlumnoEstilosCreateWithoutAlumnoInput, AlumnoEstilosUncheckedCreateWithoutAlumnoInput> | AlumnoEstilosCreateWithoutAlumnoInput[] | AlumnoEstilosUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: AlumnoEstilosCreateOrConnectWithoutAlumnoInput | AlumnoEstilosCreateOrConnectWithoutAlumnoInput[]
    upsert?: AlumnoEstilosUpsertWithWhereUniqueWithoutAlumnoInput | AlumnoEstilosUpsertWithWhereUniqueWithoutAlumnoInput[]
    createMany?: AlumnoEstilosCreateManyAlumnoInputEnvelope
    set?: AlumnoEstilosWhereUniqueInput | AlumnoEstilosWhereUniqueInput[]
    disconnect?: AlumnoEstilosWhereUniqueInput | AlumnoEstilosWhereUniqueInput[]
    delete?: AlumnoEstilosWhereUniqueInput | AlumnoEstilosWhereUniqueInput[]
    connect?: AlumnoEstilosWhereUniqueInput | AlumnoEstilosWhereUniqueInput[]
    update?: AlumnoEstilosUpdateWithWhereUniqueWithoutAlumnoInput | AlumnoEstilosUpdateWithWhereUniqueWithoutAlumnoInput[]
    updateMany?: AlumnoEstilosUpdateManyWithWhereWithoutAlumnoInput | AlumnoEstilosUpdateManyWithWhereWithoutAlumnoInput[]
    deleteMany?: AlumnoEstilosScalarWhereInput | AlumnoEstilosScalarWhereInput[]
  }

  export type DeudaUncheckedUpdateManyWithoutAlumnoNestedInput = {
    create?: XOR<DeudaCreateWithoutAlumnoInput, DeudaUncheckedCreateWithoutAlumnoInput> | DeudaCreateWithoutAlumnoInput[] | DeudaUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: DeudaCreateOrConnectWithoutAlumnoInput | DeudaCreateOrConnectWithoutAlumnoInput[]
    upsert?: DeudaUpsertWithWhereUniqueWithoutAlumnoInput | DeudaUpsertWithWhereUniqueWithoutAlumnoInput[]
    createMany?: DeudaCreateManyAlumnoInputEnvelope
    set?: DeudaWhereUniqueInput | DeudaWhereUniqueInput[]
    disconnect?: DeudaWhereUniqueInput | DeudaWhereUniqueInput[]
    delete?: DeudaWhereUniqueInput | DeudaWhereUniqueInput[]
    connect?: DeudaWhereUniqueInput | DeudaWhereUniqueInput[]
    update?: DeudaUpdateWithWhereUniqueWithoutAlumnoInput | DeudaUpdateWithWhereUniqueWithoutAlumnoInput[]
    updateMany?: DeudaUpdateManyWithWhereWithoutAlumnoInput | DeudaUpdateManyWithWhereWithoutAlumnoInput[]
    deleteMany?: DeudaScalarWhereInput | DeudaScalarWhereInput[]
  }

  export type DescuentoAplicadoUncheckedUpdateManyWithoutAlumnoNestedInput = {
    create?: XOR<DescuentoAplicadoCreateWithoutAlumnoInput, DescuentoAplicadoUncheckedCreateWithoutAlumnoInput> | DescuentoAplicadoCreateWithoutAlumnoInput[] | DescuentoAplicadoUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: DescuentoAplicadoCreateOrConnectWithoutAlumnoInput | DescuentoAplicadoCreateOrConnectWithoutAlumnoInput[]
    upsert?: DescuentoAplicadoUpsertWithWhereUniqueWithoutAlumnoInput | DescuentoAplicadoUpsertWithWhereUniqueWithoutAlumnoInput[]
    createMany?: DescuentoAplicadoCreateManyAlumnoInputEnvelope
    set?: DescuentoAplicadoWhereUniqueInput | DescuentoAplicadoWhereUniqueInput[]
    disconnect?: DescuentoAplicadoWhereUniqueInput | DescuentoAplicadoWhereUniqueInput[]
    delete?: DescuentoAplicadoWhereUniqueInput | DescuentoAplicadoWhereUniqueInput[]
    connect?: DescuentoAplicadoWhereUniqueInput | DescuentoAplicadoWhereUniqueInput[]
    update?: DescuentoAplicadoUpdateWithWhereUniqueWithoutAlumnoInput | DescuentoAplicadoUpdateWithWhereUniqueWithoutAlumnoInput[]
    updateMany?: DescuentoAplicadoUpdateManyWithWhereWithoutAlumnoInput | DescuentoAplicadoUpdateManyWithWhereWithoutAlumnoInput[]
    deleteMany?: DescuentoAplicadoScalarWhereInput | DescuentoAplicadoScalarWhereInput[]
  }

  export type ConfiguracionPagoAlumnoUncheckedUpdateOneWithoutAlumnoNestedInput = {
    create?: XOR<ConfiguracionPagoAlumnoCreateWithoutAlumnoInput, ConfiguracionPagoAlumnoUncheckedCreateWithoutAlumnoInput>
    connectOrCreate?: ConfiguracionPagoAlumnoCreateOrConnectWithoutAlumnoInput
    upsert?: ConfiguracionPagoAlumnoUpsertWithoutAlumnoInput
    disconnect?: ConfiguracionPagoAlumnoWhereInput | boolean
    delete?: ConfiguracionPagoAlumnoWhereInput | boolean
    connect?: ConfiguracionPagoAlumnoWhereUniqueInput
    update?: XOR<XOR<ConfiguracionPagoAlumnoUpdateToOneWithWhereWithoutAlumnoInput, ConfiguracionPagoAlumnoUpdateWithoutAlumnoInput>, ConfiguracionPagoAlumnoUncheckedUpdateWithoutAlumnoInput>
  }

  export type AlumnoCreateNestedOneWithoutConfiguracionPagoInput = {
    create?: XOR<AlumnoCreateWithoutConfiguracionPagoInput, AlumnoUncheckedCreateWithoutConfiguracionPagoInput>
    connectOrCreate?: AlumnoCreateOrConnectWithoutConfiguracionPagoInput
    connect?: AlumnoWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumTipoPagoFieldUpdateOperationsInput = {
    set?: $Enums.TipoPago
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AlumnoUpdateOneRequiredWithoutConfiguracionPagoNestedInput = {
    create?: XOR<AlumnoCreateWithoutConfiguracionPagoInput, AlumnoUncheckedCreateWithoutConfiguracionPagoInput>
    connectOrCreate?: AlumnoCreateOrConnectWithoutConfiguracionPagoInput
    upsert?: AlumnoUpsertWithoutConfiguracionPagoInput
    connect?: AlumnoWhereUniqueInput
    update?: XOR<XOR<AlumnoUpdateToOneWithWhereWithoutConfiguracionPagoInput, AlumnoUpdateWithoutConfiguracionPagoInput>, AlumnoUncheckedUpdateWithoutConfiguracionPagoInput>
  }

  export type DescuentoAplicadoCreateNestedManyWithoutDescuentoInput = {
    create?: XOR<DescuentoAplicadoCreateWithoutDescuentoInput, DescuentoAplicadoUncheckedCreateWithoutDescuentoInput> | DescuentoAplicadoCreateWithoutDescuentoInput[] | DescuentoAplicadoUncheckedCreateWithoutDescuentoInput[]
    connectOrCreate?: DescuentoAplicadoCreateOrConnectWithoutDescuentoInput | DescuentoAplicadoCreateOrConnectWithoutDescuentoInput[]
    createMany?: DescuentoAplicadoCreateManyDescuentoInputEnvelope
    connect?: DescuentoAplicadoWhereUniqueInput | DescuentoAplicadoWhereUniqueInput[]
  }

  export type DescuentoAplicadoUncheckedCreateNestedManyWithoutDescuentoInput = {
    create?: XOR<DescuentoAplicadoCreateWithoutDescuentoInput, DescuentoAplicadoUncheckedCreateWithoutDescuentoInput> | DescuentoAplicadoCreateWithoutDescuentoInput[] | DescuentoAplicadoUncheckedCreateWithoutDescuentoInput[]
    connectOrCreate?: DescuentoAplicadoCreateOrConnectWithoutDescuentoInput | DescuentoAplicadoCreateOrConnectWithoutDescuentoInput[]
    createMany?: DescuentoAplicadoCreateManyDescuentoInputEnvelope
    connect?: DescuentoAplicadoWhereUniqueInput | DescuentoAplicadoWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DescuentoAplicadoUpdateManyWithoutDescuentoNestedInput = {
    create?: XOR<DescuentoAplicadoCreateWithoutDescuentoInput, DescuentoAplicadoUncheckedCreateWithoutDescuentoInput> | DescuentoAplicadoCreateWithoutDescuentoInput[] | DescuentoAplicadoUncheckedCreateWithoutDescuentoInput[]
    connectOrCreate?: DescuentoAplicadoCreateOrConnectWithoutDescuentoInput | DescuentoAplicadoCreateOrConnectWithoutDescuentoInput[]
    upsert?: DescuentoAplicadoUpsertWithWhereUniqueWithoutDescuentoInput | DescuentoAplicadoUpsertWithWhereUniqueWithoutDescuentoInput[]
    createMany?: DescuentoAplicadoCreateManyDescuentoInputEnvelope
    set?: DescuentoAplicadoWhereUniqueInput | DescuentoAplicadoWhereUniqueInput[]
    disconnect?: DescuentoAplicadoWhereUniqueInput | DescuentoAplicadoWhereUniqueInput[]
    delete?: DescuentoAplicadoWhereUniqueInput | DescuentoAplicadoWhereUniqueInput[]
    connect?: DescuentoAplicadoWhereUniqueInput | DescuentoAplicadoWhereUniqueInput[]
    update?: DescuentoAplicadoUpdateWithWhereUniqueWithoutDescuentoInput | DescuentoAplicadoUpdateWithWhereUniqueWithoutDescuentoInput[]
    updateMany?: DescuentoAplicadoUpdateManyWithWhereWithoutDescuentoInput | DescuentoAplicadoUpdateManyWithWhereWithoutDescuentoInput[]
    deleteMany?: DescuentoAplicadoScalarWhereInput | DescuentoAplicadoScalarWhereInput[]
  }

  export type DescuentoAplicadoUncheckedUpdateManyWithoutDescuentoNestedInput = {
    create?: XOR<DescuentoAplicadoCreateWithoutDescuentoInput, DescuentoAplicadoUncheckedCreateWithoutDescuentoInput> | DescuentoAplicadoCreateWithoutDescuentoInput[] | DescuentoAplicadoUncheckedCreateWithoutDescuentoInput[]
    connectOrCreate?: DescuentoAplicadoCreateOrConnectWithoutDescuentoInput | DescuentoAplicadoCreateOrConnectWithoutDescuentoInput[]
    upsert?: DescuentoAplicadoUpsertWithWhereUniqueWithoutDescuentoInput | DescuentoAplicadoUpsertWithWhereUniqueWithoutDescuentoInput[]
    createMany?: DescuentoAplicadoCreateManyDescuentoInputEnvelope
    set?: DescuentoAplicadoWhereUniqueInput | DescuentoAplicadoWhereUniqueInput[]
    disconnect?: DescuentoAplicadoWhereUniqueInput | DescuentoAplicadoWhereUniqueInput[]
    delete?: DescuentoAplicadoWhereUniqueInput | DescuentoAplicadoWhereUniqueInput[]
    connect?: DescuentoAplicadoWhereUniqueInput | DescuentoAplicadoWhereUniqueInput[]
    update?: DescuentoAplicadoUpdateWithWhereUniqueWithoutDescuentoInput | DescuentoAplicadoUpdateWithWhereUniqueWithoutDescuentoInput[]
    updateMany?: DescuentoAplicadoUpdateManyWithWhereWithoutDescuentoInput | DescuentoAplicadoUpdateManyWithWhereWithoutDescuentoInput[]
    deleteMany?: DescuentoAplicadoScalarWhereInput | DescuentoAplicadoScalarWhereInput[]
  }

  export type DescuentoCreateNestedOneWithoutAplicadoAInput = {
    create?: XOR<DescuentoCreateWithoutAplicadoAInput, DescuentoUncheckedCreateWithoutAplicadoAInput>
    connectOrCreate?: DescuentoCreateOrConnectWithoutAplicadoAInput
    connect?: DescuentoWhereUniqueInput
  }

  export type AlumnoCreateNestedOneWithoutDescuentosVigentesInput = {
    create?: XOR<AlumnoCreateWithoutDescuentosVigentesInput, AlumnoUncheckedCreateWithoutDescuentosVigentesInput>
    connectOrCreate?: AlumnoCreateOrConnectWithoutDescuentosVigentesInput
    connect?: AlumnoWhereUniqueInput
  }

  export type DescuentoUpdateOneRequiredWithoutAplicadoANestedInput = {
    create?: XOR<DescuentoCreateWithoutAplicadoAInput, DescuentoUncheckedCreateWithoutAplicadoAInput>
    connectOrCreate?: DescuentoCreateOrConnectWithoutAplicadoAInput
    upsert?: DescuentoUpsertWithoutAplicadoAInput
    connect?: DescuentoWhereUniqueInput
    update?: XOR<XOR<DescuentoUpdateToOneWithWhereWithoutAplicadoAInput, DescuentoUpdateWithoutAplicadoAInput>, DescuentoUncheckedUpdateWithoutAplicadoAInput>
  }

  export type AlumnoUpdateOneRequiredWithoutDescuentosVigentesNestedInput = {
    create?: XOR<AlumnoCreateWithoutDescuentosVigentesInput, AlumnoUncheckedCreateWithoutDescuentosVigentesInput>
    connectOrCreate?: AlumnoCreateOrConnectWithoutDescuentosVigentesInput
    upsert?: AlumnoUpsertWithoutDescuentosVigentesInput
    connect?: AlumnoWhereUniqueInput
    update?: XOR<XOR<AlumnoUpdateToOneWithWhereWithoutDescuentosVigentesInput, AlumnoUpdateWithoutDescuentosVigentesInput>, AlumnoUncheckedUpdateWithoutDescuentosVigentesInput>
  }

  export type AlumnoCreateNestedOneWithoutDeudasInput = {
    create?: XOR<AlumnoCreateWithoutDeudasInput, AlumnoUncheckedCreateWithoutDeudasInput>
    connectOrCreate?: AlumnoCreateOrConnectWithoutDeudasInput
    connect?: AlumnoWhereUniqueInput
  }

  export type EstiloCreateNestedOneWithoutDeudasInput = {
    create?: XOR<EstiloCreateWithoutDeudasInput, EstiloUncheckedCreateWithoutDeudasInput>
    connectOrCreate?: EstiloCreateOrConnectWithoutDeudasInput
    connect?: EstiloWhereUniqueInput
  }

  export type PagoDeudaCreateNestedManyWithoutDeudaInput = {
    create?: XOR<PagoDeudaCreateWithoutDeudaInput, PagoDeudaUncheckedCreateWithoutDeudaInput> | PagoDeudaCreateWithoutDeudaInput[] | PagoDeudaUncheckedCreateWithoutDeudaInput[]
    connectOrCreate?: PagoDeudaCreateOrConnectWithoutDeudaInput | PagoDeudaCreateOrConnectWithoutDeudaInput[]
    createMany?: PagoDeudaCreateManyDeudaInputEnvelope
    connect?: PagoDeudaWhereUniqueInput | PagoDeudaWhereUniqueInput[]
  }

  export type PagoDeudaUncheckedCreateNestedManyWithoutDeudaInput = {
    create?: XOR<PagoDeudaCreateWithoutDeudaInput, PagoDeudaUncheckedCreateWithoutDeudaInput> | PagoDeudaCreateWithoutDeudaInput[] | PagoDeudaUncheckedCreateWithoutDeudaInput[]
    connectOrCreate?: PagoDeudaCreateOrConnectWithoutDeudaInput | PagoDeudaCreateOrConnectWithoutDeudaInput[]
    createMany?: PagoDeudaCreateManyDeudaInputEnvelope
    connect?: PagoDeudaWhereUniqueInput | PagoDeudaWhereUniqueInput[]
  }

  export type AlumnoUpdateOneRequiredWithoutDeudasNestedInput = {
    create?: XOR<AlumnoCreateWithoutDeudasInput, AlumnoUncheckedCreateWithoutDeudasInput>
    connectOrCreate?: AlumnoCreateOrConnectWithoutDeudasInput
    upsert?: AlumnoUpsertWithoutDeudasInput
    connect?: AlumnoWhereUniqueInput
    update?: XOR<XOR<AlumnoUpdateToOneWithWhereWithoutDeudasInput, AlumnoUpdateWithoutDeudasInput>, AlumnoUncheckedUpdateWithoutDeudasInput>
  }

  export type EstiloUpdateOneRequiredWithoutDeudasNestedInput = {
    create?: XOR<EstiloCreateWithoutDeudasInput, EstiloUncheckedCreateWithoutDeudasInput>
    connectOrCreate?: EstiloCreateOrConnectWithoutDeudasInput
    upsert?: EstiloUpsertWithoutDeudasInput
    connect?: EstiloWhereUniqueInput
    update?: XOR<XOR<EstiloUpdateToOneWithWhereWithoutDeudasInput, EstiloUpdateWithoutDeudasInput>, EstiloUncheckedUpdateWithoutDeudasInput>
  }

  export type PagoDeudaUpdateManyWithoutDeudaNestedInput = {
    create?: XOR<PagoDeudaCreateWithoutDeudaInput, PagoDeudaUncheckedCreateWithoutDeudaInput> | PagoDeudaCreateWithoutDeudaInput[] | PagoDeudaUncheckedCreateWithoutDeudaInput[]
    connectOrCreate?: PagoDeudaCreateOrConnectWithoutDeudaInput | PagoDeudaCreateOrConnectWithoutDeudaInput[]
    upsert?: PagoDeudaUpsertWithWhereUniqueWithoutDeudaInput | PagoDeudaUpsertWithWhereUniqueWithoutDeudaInput[]
    createMany?: PagoDeudaCreateManyDeudaInputEnvelope
    set?: PagoDeudaWhereUniqueInput | PagoDeudaWhereUniqueInput[]
    disconnect?: PagoDeudaWhereUniqueInput | PagoDeudaWhereUniqueInput[]
    delete?: PagoDeudaWhereUniqueInput | PagoDeudaWhereUniqueInput[]
    connect?: PagoDeudaWhereUniqueInput | PagoDeudaWhereUniqueInput[]
    update?: PagoDeudaUpdateWithWhereUniqueWithoutDeudaInput | PagoDeudaUpdateWithWhereUniqueWithoutDeudaInput[]
    updateMany?: PagoDeudaUpdateManyWithWhereWithoutDeudaInput | PagoDeudaUpdateManyWithWhereWithoutDeudaInput[]
    deleteMany?: PagoDeudaScalarWhereInput | PagoDeudaScalarWhereInput[]
  }

  export type PagoDeudaUncheckedUpdateManyWithoutDeudaNestedInput = {
    create?: XOR<PagoDeudaCreateWithoutDeudaInput, PagoDeudaUncheckedCreateWithoutDeudaInput> | PagoDeudaCreateWithoutDeudaInput[] | PagoDeudaUncheckedCreateWithoutDeudaInput[]
    connectOrCreate?: PagoDeudaCreateOrConnectWithoutDeudaInput | PagoDeudaCreateOrConnectWithoutDeudaInput[]
    upsert?: PagoDeudaUpsertWithWhereUniqueWithoutDeudaInput | PagoDeudaUpsertWithWhereUniqueWithoutDeudaInput[]
    createMany?: PagoDeudaCreateManyDeudaInputEnvelope
    set?: PagoDeudaWhereUniqueInput | PagoDeudaWhereUniqueInput[]
    disconnect?: PagoDeudaWhereUniqueInput | PagoDeudaWhereUniqueInput[]
    delete?: PagoDeudaWhereUniqueInput | PagoDeudaWhereUniqueInput[]
    connect?: PagoDeudaWhereUniqueInput | PagoDeudaWhereUniqueInput[]
    update?: PagoDeudaUpdateWithWhereUniqueWithoutDeudaInput | PagoDeudaUpdateWithWhereUniqueWithoutDeudaInput[]
    updateMany?: PagoDeudaUpdateManyWithWhereWithoutDeudaInput | PagoDeudaUpdateManyWithWhereWithoutDeudaInput[]
    deleteMany?: PagoDeudaScalarWhereInput | PagoDeudaScalarWhereInput[]
  }

  export type DeudaCreateNestedOneWithoutPagosInput = {
    create?: XOR<DeudaCreateWithoutPagosInput, DeudaUncheckedCreateWithoutPagosInput>
    connectOrCreate?: DeudaCreateOrConnectWithoutPagosInput
    connect?: DeudaWhereUniqueInput
  }

  export type ReciboCreateNestedOneWithoutPagosDeudaInput = {
    create?: XOR<ReciboCreateWithoutPagosDeudaInput, ReciboUncheckedCreateWithoutPagosDeudaInput>
    connectOrCreate?: ReciboCreateOrConnectWithoutPagosDeudaInput
    connect?: ReciboWhereUniqueInput
  }

  export type DeudaUpdateOneRequiredWithoutPagosNestedInput = {
    create?: XOR<DeudaCreateWithoutPagosInput, DeudaUncheckedCreateWithoutPagosInput>
    connectOrCreate?: DeudaCreateOrConnectWithoutPagosInput
    upsert?: DeudaUpsertWithoutPagosInput
    connect?: DeudaWhereUniqueInput
    update?: XOR<XOR<DeudaUpdateToOneWithWhereWithoutPagosInput, DeudaUpdateWithoutPagosInput>, DeudaUncheckedUpdateWithoutPagosInput>
  }

  export type ReciboUpdateOneRequiredWithoutPagosDeudaNestedInput = {
    create?: XOR<ReciboCreateWithoutPagosDeudaInput, ReciboUncheckedCreateWithoutPagosDeudaInput>
    connectOrCreate?: ReciboCreateOrConnectWithoutPagosDeudaInput
    upsert?: ReciboUpsertWithoutPagosDeudaInput
    connect?: ReciboWhereUniqueInput
    update?: XOR<XOR<ReciboUpdateToOneWithWhereWithoutPagosDeudaInput, ReciboUpdateWithoutPagosDeudaInput>, ReciboUncheckedUpdateWithoutPagosDeudaInput>
  }

  export type EstiloCreateNestedOneWithoutConceptosInput = {
    create?: XOR<EstiloCreateWithoutConceptosInput, EstiloUncheckedCreateWithoutConceptosInput>
    connectOrCreate?: EstiloCreateOrConnectWithoutConceptosInput
    connect?: EstiloWhereUniqueInput
  }

  export type ReciboCreateNestedManyWithoutConceptoInput = {
    create?: XOR<ReciboCreateWithoutConceptoInput, ReciboUncheckedCreateWithoutConceptoInput> | ReciboCreateWithoutConceptoInput[] | ReciboUncheckedCreateWithoutConceptoInput[]
    connectOrCreate?: ReciboCreateOrConnectWithoutConceptoInput | ReciboCreateOrConnectWithoutConceptoInput[]
    createMany?: ReciboCreateManyConceptoInputEnvelope
    connect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
  }

  export type ReciboUncheckedCreateNestedManyWithoutConceptoInput = {
    create?: XOR<ReciboCreateWithoutConceptoInput, ReciboUncheckedCreateWithoutConceptoInput> | ReciboCreateWithoutConceptoInput[] | ReciboUncheckedCreateWithoutConceptoInput[]
    connectOrCreate?: ReciboCreateOrConnectWithoutConceptoInput | ReciboCreateOrConnectWithoutConceptoInput[]
    createMany?: ReciboCreateManyConceptoInputEnvelope
    connect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
  }

  export type EstiloUpdateOneWithoutConceptosNestedInput = {
    create?: XOR<EstiloCreateWithoutConceptosInput, EstiloUncheckedCreateWithoutConceptosInput>
    connectOrCreate?: EstiloCreateOrConnectWithoutConceptosInput
    upsert?: EstiloUpsertWithoutConceptosInput
    disconnect?: EstiloWhereInput | boolean
    delete?: EstiloWhereInput | boolean
    connect?: EstiloWhereUniqueInput
    update?: XOR<XOR<EstiloUpdateToOneWithWhereWithoutConceptosInput, EstiloUpdateWithoutConceptosInput>, EstiloUncheckedUpdateWithoutConceptosInput>
  }

  export type ReciboUpdateManyWithoutConceptoNestedInput = {
    create?: XOR<ReciboCreateWithoutConceptoInput, ReciboUncheckedCreateWithoutConceptoInput> | ReciboCreateWithoutConceptoInput[] | ReciboUncheckedCreateWithoutConceptoInput[]
    connectOrCreate?: ReciboCreateOrConnectWithoutConceptoInput | ReciboCreateOrConnectWithoutConceptoInput[]
    upsert?: ReciboUpsertWithWhereUniqueWithoutConceptoInput | ReciboUpsertWithWhereUniqueWithoutConceptoInput[]
    createMany?: ReciboCreateManyConceptoInputEnvelope
    set?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    disconnect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    delete?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    connect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    update?: ReciboUpdateWithWhereUniqueWithoutConceptoInput | ReciboUpdateWithWhereUniqueWithoutConceptoInput[]
    updateMany?: ReciboUpdateManyWithWhereWithoutConceptoInput | ReciboUpdateManyWithWhereWithoutConceptoInput[]
    deleteMany?: ReciboScalarWhereInput | ReciboScalarWhereInput[]
  }

  export type ReciboUncheckedUpdateManyWithoutConceptoNestedInput = {
    create?: XOR<ReciboCreateWithoutConceptoInput, ReciboUncheckedCreateWithoutConceptoInput> | ReciboCreateWithoutConceptoInput[] | ReciboUncheckedCreateWithoutConceptoInput[]
    connectOrCreate?: ReciboCreateOrConnectWithoutConceptoInput | ReciboCreateOrConnectWithoutConceptoInput[]
    upsert?: ReciboUpsertWithWhereUniqueWithoutConceptoInput | ReciboUpsertWithWhereUniqueWithoutConceptoInput[]
    createMany?: ReciboCreateManyConceptoInputEnvelope
    set?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    disconnect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    delete?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    connect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    update?: ReciboUpdateWithWhereUniqueWithoutConceptoInput | ReciboUpdateWithWhereUniqueWithoutConceptoInput[]
    updateMany?: ReciboUpdateManyWithWhereWithoutConceptoInput | ReciboUpdateManyWithWhereWithoutConceptoInput[]
    deleteMany?: ReciboScalarWhereInput | ReciboScalarWhereInput[]
  }

  export type AlumnoCreateNestedOneWithoutRecibosInput = {
    create?: XOR<AlumnoCreateWithoutRecibosInput, AlumnoUncheckedCreateWithoutRecibosInput>
    connectOrCreate?: AlumnoCreateOrConnectWithoutRecibosInput
    connect?: AlumnoWhereUniqueInput
  }

  export type AlumnoSueltoCreateNestedOneWithoutRecibosInput = {
    create?: XOR<AlumnoSueltoCreateWithoutRecibosInput, AlumnoSueltoUncheckedCreateWithoutRecibosInput>
    connectOrCreate?: AlumnoSueltoCreateOrConnectWithoutRecibosInput
    connect?: AlumnoSueltoWhereUniqueInput
  }

  export type ConceptoCreateNestedOneWithoutRecibosInput = {
    create?: XOR<ConceptoCreateWithoutRecibosInput, ConceptoUncheckedCreateWithoutRecibosInput>
    connectOrCreate?: ConceptoCreateOrConnectWithoutRecibosInput
    connect?: ConceptoWhereUniqueInput
  }

  export type PagoDeudaCreateNestedManyWithoutReciboInput = {
    create?: XOR<PagoDeudaCreateWithoutReciboInput, PagoDeudaUncheckedCreateWithoutReciboInput> | PagoDeudaCreateWithoutReciboInput[] | PagoDeudaUncheckedCreateWithoutReciboInput[]
    connectOrCreate?: PagoDeudaCreateOrConnectWithoutReciboInput | PagoDeudaCreateOrConnectWithoutReciboInput[]
    createMany?: PagoDeudaCreateManyReciboInputEnvelope
    connect?: PagoDeudaWhereUniqueInput | PagoDeudaWhereUniqueInput[]
  }

  export type DetalleLiquidacionCreateNestedManyWithoutReciboInput = {
    create?: XOR<DetalleLiquidacionCreateWithoutReciboInput, DetalleLiquidacionUncheckedCreateWithoutReciboInput> | DetalleLiquidacionCreateWithoutReciboInput[] | DetalleLiquidacionUncheckedCreateWithoutReciboInput[]
    connectOrCreate?: DetalleLiquidacionCreateOrConnectWithoutReciboInput | DetalleLiquidacionCreateOrConnectWithoutReciboInput[]
    createMany?: DetalleLiquidacionCreateManyReciboInputEnvelope
    connect?: DetalleLiquidacionWhereUniqueInput | DetalleLiquidacionWhereUniqueInput[]
  }

  export type ClaseCreateNestedOneWithoutRecibosInput = {
    create?: XOR<ClaseCreateWithoutRecibosInput, ClaseUncheckedCreateWithoutRecibosInput>
    connectOrCreate?: ClaseCreateOrConnectWithoutRecibosInput
    connect?: ClaseWhereUniqueInput
  }

  export type ReciboCreateNestedOneWithoutRecibosAnuladosInput = {
    create?: XOR<ReciboCreateWithoutRecibosAnuladosInput, ReciboUncheckedCreateWithoutRecibosAnuladosInput>
    connectOrCreate?: ReciboCreateOrConnectWithoutRecibosAnuladosInput
    connect?: ReciboWhereUniqueInput
  }

  export type ReciboCreateNestedManyWithoutReciboAnuladoInput = {
    create?: XOR<ReciboCreateWithoutReciboAnuladoInput, ReciboUncheckedCreateWithoutReciboAnuladoInput> | ReciboCreateWithoutReciboAnuladoInput[] | ReciboUncheckedCreateWithoutReciboAnuladoInput[]
    connectOrCreate?: ReciboCreateOrConnectWithoutReciboAnuladoInput | ReciboCreateOrConnectWithoutReciboAnuladoInput[]
    createMany?: ReciboCreateManyReciboAnuladoInputEnvelope
    connect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
  }

  export type PagoDeudaUncheckedCreateNestedManyWithoutReciboInput = {
    create?: XOR<PagoDeudaCreateWithoutReciboInput, PagoDeudaUncheckedCreateWithoutReciboInput> | PagoDeudaCreateWithoutReciboInput[] | PagoDeudaUncheckedCreateWithoutReciboInput[]
    connectOrCreate?: PagoDeudaCreateOrConnectWithoutReciboInput | PagoDeudaCreateOrConnectWithoutReciboInput[]
    createMany?: PagoDeudaCreateManyReciboInputEnvelope
    connect?: PagoDeudaWhereUniqueInput | PagoDeudaWhereUniqueInput[]
  }

  export type DetalleLiquidacionUncheckedCreateNestedManyWithoutReciboInput = {
    create?: XOR<DetalleLiquidacionCreateWithoutReciboInput, DetalleLiquidacionUncheckedCreateWithoutReciboInput> | DetalleLiquidacionCreateWithoutReciboInput[] | DetalleLiquidacionUncheckedCreateWithoutReciboInput[]
    connectOrCreate?: DetalleLiquidacionCreateOrConnectWithoutReciboInput | DetalleLiquidacionCreateOrConnectWithoutReciboInput[]
    createMany?: DetalleLiquidacionCreateManyReciboInputEnvelope
    connect?: DetalleLiquidacionWhereUniqueInput | DetalleLiquidacionWhereUniqueInput[]
  }

  export type ReciboUncheckedCreateNestedManyWithoutReciboAnuladoInput = {
    create?: XOR<ReciboCreateWithoutReciboAnuladoInput, ReciboUncheckedCreateWithoutReciboAnuladoInput> | ReciboCreateWithoutReciboAnuladoInput[] | ReciboUncheckedCreateWithoutReciboAnuladoInput[]
    connectOrCreate?: ReciboCreateOrConnectWithoutReciboAnuladoInput | ReciboCreateOrConnectWithoutReciboAnuladoInput[]
    createMany?: ReciboCreateManyReciboAnuladoInputEnvelope
    connect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
  }

  export type AlumnoUpdateOneWithoutRecibosNestedInput = {
    create?: XOR<AlumnoCreateWithoutRecibosInput, AlumnoUncheckedCreateWithoutRecibosInput>
    connectOrCreate?: AlumnoCreateOrConnectWithoutRecibosInput
    upsert?: AlumnoUpsertWithoutRecibosInput
    disconnect?: AlumnoWhereInput | boolean
    delete?: AlumnoWhereInput | boolean
    connect?: AlumnoWhereUniqueInput
    update?: XOR<XOR<AlumnoUpdateToOneWithWhereWithoutRecibosInput, AlumnoUpdateWithoutRecibosInput>, AlumnoUncheckedUpdateWithoutRecibosInput>
  }

  export type AlumnoSueltoUpdateOneWithoutRecibosNestedInput = {
    create?: XOR<AlumnoSueltoCreateWithoutRecibosInput, AlumnoSueltoUncheckedCreateWithoutRecibosInput>
    connectOrCreate?: AlumnoSueltoCreateOrConnectWithoutRecibosInput
    upsert?: AlumnoSueltoUpsertWithoutRecibosInput
    disconnect?: AlumnoSueltoWhereInput | boolean
    delete?: AlumnoSueltoWhereInput | boolean
    connect?: AlumnoSueltoWhereUniqueInput
    update?: XOR<XOR<AlumnoSueltoUpdateToOneWithWhereWithoutRecibosInput, AlumnoSueltoUpdateWithoutRecibosInput>, AlumnoSueltoUncheckedUpdateWithoutRecibosInput>
  }

  export type ConceptoUpdateOneRequiredWithoutRecibosNestedInput = {
    create?: XOR<ConceptoCreateWithoutRecibosInput, ConceptoUncheckedCreateWithoutRecibosInput>
    connectOrCreate?: ConceptoCreateOrConnectWithoutRecibosInput
    upsert?: ConceptoUpsertWithoutRecibosInput
    connect?: ConceptoWhereUniqueInput
    update?: XOR<XOR<ConceptoUpdateToOneWithWhereWithoutRecibosInput, ConceptoUpdateWithoutRecibosInput>, ConceptoUncheckedUpdateWithoutRecibosInput>
  }

  export type PagoDeudaUpdateManyWithoutReciboNestedInput = {
    create?: XOR<PagoDeudaCreateWithoutReciboInput, PagoDeudaUncheckedCreateWithoutReciboInput> | PagoDeudaCreateWithoutReciboInput[] | PagoDeudaUncheckedCreateWithoutReciboInput[]
    connectOrCreate?: PagoDeudaCreateOrConnectWithoutReciboInput | PagoDeudaCreateOrConnectWithoutReciboInput[]
    upsert?: PagoDeudaUpsertWithWhereUniqueWithoutReciboInput | PagoDeudaUpsertWithWhereUniqueWithoutReciboInput[]
    createMany?: PagoDeudaCreateManyReciboInputEnvelope
    set?: PagoDeudaWhereUniqueInput | PagoDeudaWhereUniqueInput[]
    disconnect?: PagoDeudaWhereUniqueInput | PagoDeudaWhereUniqueInput[]
    delete?: PagoDeudaWhereUniqueInput | PagoDeudaWhereUniqueInput[]
    connect?: PagoDeudaWhereUniqueInput | PagoDeudaWhereUniqueInput[]
    update?: PagoDeudaUpdateWithWhereUniqueWithoutReciboInput | PagoDeudaUpdateWithWhereUniqueWithoutReciboInput[]
    updateMany?: PagoDeudaUpdateManyWithWhereWithoutReciboInput | PagoDeudaUpdateManyWithWhereWithoutReciboInput[]
    deleteMany?: PagoDeudaScalarWhereInput | PagoDeudaScalarWhereInput[]
  }

  export type DetalleLiquidacionUpdateManyWithoutReciboNestedInput = {
    create?: XOR<DetalleLiquidacionCreateWithoutReciboInput, DetalleLiquidacionUncheckedCreateWithoutReciboInput> | DetalleLiquidacionCreateWithoutReciboInput[] | DetalleLiquidacionUncheckedCreateWithoutReciboInput[]
    connectOrCreate?: DetalleLiquidacionCreateOrConnectWithoutReciboInput | DetalleLiquidacionCreateOrConnectWithoutReciboInput[]
    upsert?: DetalleLiquidacionUpsertWithWhereUniqueWithoutReciboInput | DetalleLiquidacionUpsertWithWhereUniqueWithoutReciboInput[]
    createMany?: DetalleLiquidacionCreateManyReciboInputEnvelope
    set?: DetalleLiquidacionWhereUniqueInput | DetalleLiquidacionWhereUniqueInput[]
    disconnect?: DetalleLiquidacionWhereUniqueInput | DetalleLiquidacionWhereUniqueInput[]
    delete?: DetalleLiquidacionWhereUniqueInput | DetalleLiquidacionWhereUniqueInput[]
    connect?: DetalleLiquidacionWhereUniqueInput | DetalleLiquidacionWhereUniqueInput[]
    update?: DetalleLiquidacionUpdateWithWhereUniqueWithoutReciboInput | DetalleLiquidacionUpdateWithWhereUniqueWithoutReciboInput[]
    updateMany?: DetalleLiquidacionUpdateManyWithWhereWithoutReciboInput | DetalleLiquidacionUpdateManyWithWhereWithoutReciboInput[]
    deleteMany?: DetalleLiquidacionScalarWhereInput | DetalleLiquidacionScalarWhereInput[]
  }

  export type ClaseUpdateOneWithoutRecibosNestedInput = {
    create?: XOR<ClaseCreateWithoutRecibosInput, ClaseUncheckedCreateWithoutRecibosInput>
    connectOrCreate?: ClaseCreateOrConnectWithoutRecibosInput
    upsert?: ClaseUpsertWithoutRecibosInput
    disconnect?: ClaseWhereInput | boolean
    delete?: ClaseWhereInput | boolean
    connect?: ClaseWhereUniqueInput
    update?: XOR<XOR<ClaseUpdateToOneWithWhereWithoutRecibosInput, ClaseUpdateWithoutRecibosInput>, ClaseUncheckedUpdateWithoutRecibosInput>
  }

  export type ReciboUpdateOneWithoutRecibosAnuladosNestedInput = {
    create?: XOR<ReciboCreateWithoutRecibosAnuladosInput, ReciboUncheckedCreateWithoutRecibosAnuladosInput>
    connectOrCreate?: ReciboCreateOrConnectWithoutRecibosAnuladosInput
    upsert?: ReciboUpsertWithoutRecibosAnuladosInput
    disconnect?: ReciboWhereInput | boolean
    delete?: ReciboWhereInput | boolean
    connect?: ReciboWhereUniqueInput
    update?: XOR<XOR<ReciboUpdateToOneWithWhereWithoutRecibosAnuladosInput, ReciboUpdateWithoutRecibosAnuladosInput>, ReciboUncheckedUpdateWithoutRecibosAnuladosInput>
  }

  export type ReciboUpdateManyWithoutReciboAnuladoNestedInput = {
    create?: XOR<ReciboCreateWithoutReciboAnuladoInput, ReciboUncheckedCreateWithoutReciboAnuladoInput> | ReciboCreateWithoutReciboAnuladoInput[] | ReciboUncheckedCreateWithoutReciboAnuladoInput[]
    connectOrCreate?: ReciboCreateOrConnectWithoutReciboAnuladoInput | ReciboCreateOrConnectWithoutReciboAnuladoInput[]
    upsert?: ReciboUpsertWithWhereUniqueWithoutReciboAnuladoInput | ReciboUpsertWithWhereUniqueWithoutReciboAnuladoInput[]
    createMany?: ReciboCreateManyReciboAnuladoInputEnvelope
    set?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    disconnect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    delete?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    connect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    update?: ReciboUpdateWithWhereUniqueWithoutReciboAnuladoInput | ReciboUpdateWithWhereUniqueWithoutReciboAnuladoInput[]
    updateMany?: ReciboUpdateManyWithWhereWithoutReciboAnuladoInput | ReciboUpdateManyWithWhereWithoutReciboAnuladoInput[]
    deleteMany?: ReciboScalarWhereInput | ReciboScalarWhereInput[]
  }

  export type PagoDeudaUncheckedUpdateManyWithoutReciboNestedInput = {
    create?: XOR<PagoDeudaCreateWithoutReciboInput, PagoDeudaUncheckedCreateWithoutReciboInput> | PagoDeudaCreateWithoutReciboInput[] | PagoDeudaUncheckedCreateWithoutReciboInput[]
    connectOrCreate?: PagoDeudaCreateOrConnectWithoutReciboInput | PagoDeudaCreateOrConnectWithoutReciboInput[]
    upsert?: PagoDeudaUpsertWithWhereUniqueWithoutReciboInput | PagoDeudaUpsertWithWhereUniqueWithoutReciboInput[]
    createMany?: PagoDeudaCreateManyReciboInputEnvelope
    set?: PagoDeudaWhereUniqueInput | PagoDeudaWhereUniqueInput[]
    disconnect?: PagoDeudaWhereUniqueInput | PagoDeudaWhereUniqueInput[]
    delete?: PagoDeudaWhereUniqueInput | PagoDeudaWhereUniqueInput[]
    connect?: PagoDeudaWhereUniqueInput | PagoDeudaWhereUniqueInput[]
    update?: PagoDeudaUpdateWithWhereUniqueWithoutReciboInput | PagoDeudaUpdateWithWhereUniqueWithoutReciboInput[]
    updateMany?: PagoDeudaUpdateManyWithWhereWithoutReciboInput | PagoDeudaUpdateManyWithWhereWithoutReciboInput[]
    deleteMany?: PagoDeudaScalarWhereInput | PagoDeudaScalarWhereInput[]
  }

  export type DetalleLiquidacionUncheckedUpdateManyWithoutReciboNestedInput = {
    create?: XOR<DetalleLiquidacionCreateWithoutReciboInput, DetalleLiquidacionUncheckedCreateWithoutReciboInput> | DetalleLiquidacionCreateWithoutReciboInput[] | DetalleLiquidacionUncheckedCreateWithoutReciboInput[]
    connectOrCreate?: DetalleLiquidacionCreateOrConnectWithoutReciboInput | DetalleLiquidacionCreateOrConnectWithoutReciboInput[]
    upsert?: DetalleLiquidacionUpsertWithWhereUniqueWithoutReciboInput | DetalleLiquidacionUpsertWithWhereUniqueWithoutReciboInput[]
    createMany?: DetalleLiquidacionCreateManyReciboInputEnvelope
    set?: DetalleLiquidacionWhereUniqueInput | DetalleLiquidacionWhereUniqueInput[]
    disconnect?: DetalleLiquidacionWhereUniqueInput | DetalleLiquidacionWhereUniqueInput[]
    delete?: DetalleLiquidacionWhereUniqueInput | DetalleLiquidacionWhereUniqueInput[]
    connect?: DetalleLiquidacionWhereUniqueInput | DetalleLiquidacionWhereUniqueInput[]
    update?: DetalleLiquidacionUpdateWithWhereUniqueWithoutReciboInput | DetalleLiquidacionUpdateWithWhereUniqueWithoutReciboInput[]
    updateMany?: DetalleLiquidacionUpdateManyWithWhereWithoutReciboInput | DetalleLiquidacionUpdateManyWithWhereWithoutReciboInput[]
    deleteMany?: DetalleLiquidacionScalarWhereInput | DetalleLiquidacionScalarWhereInput[]
  }

  export type ReciboUncheckedUpdateManyWithoutReciboAnuladoNestedInput = {
    create?: XOR<ReciboCreateWithoutReciboAnuladoInput, ReciboUncheckedCreateWithoutReciboAnuladoInput> | ReciboCreateWithoutReciboAnuladoInput[] | ReciboUncheckedCreateWithoutReciboAnuladoInput[]
    connectOrCreate?: ReciboCreateOrConnectWithoutReciboAnuladoInput | ReciboCreateOrConnectWithoutReciboAnuladoInput[]
    upsert?: ReciboUpsertWithWhereUniqueWithoutReciboAnuladoInput | ReciboUpsertWithWhereUniqueWithoutReciboAnuladoInput[]
    createMany?: ReciboCreateManyReciboAnuladoInputEnvelope
    set?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    disconnect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    delete?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    connect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    update?: ReciboUpdateWithWhereUniqueWithoutReciboAnuladoInput | ReciboUpdateWithWhereUniqueWithoutReciboAnuladoInput[]
    updateMany?: ReciboUpdateManyWithWhereWithoutReciboAnuladoInput | ReciboUpdateManyWithWhereWithoutReciboAnuladoInput[]
    deleteMany?: ReciboScalarWhereInput | ReciboScalarWhereInput[]
  }

  export type DeudaCreateNestedManyWithoutEstiloInput = {
    create?: XOR<DeudaCreateWithoutEstiloInput, DeudaUncheckedCreateWithoutEstiloInput> | DeudaCreateWithoutEstiloInput[] | DeudaUncheckedCreateWithoutEstiloInput[]
    connectOrCreate?: DeudaCreateOrConnectWithoutEstiloInput | DeudaCreateOrConnectWithoutEstiloInput[]
    createMany?: DeudaCreateManyEstiloInputEnvelope
    connect?: DeudaWhereUniqueInput | DeudaWhereUniqueInput[]
  }

  export type ConceptoCreateNestedManyWithoutEstiloInput = {
    create?: XOR<ConceptoCreateWithoutEstiloInput, ConceptoUncheckedCreateWithoutEstiloInput> | ConceptoCreateWithoutEstiloInput[] | ConceptoUncheckedCreateWithoutEstiloInput[]
    connectOrCreate?: ConceptoCreateOrConnectWithoutEstiloInput | ConceptoCreateOrConnectWithoutEstiloInput[]
    createMany?: ConceptoCreateManyEstiloInputEnvelope
    connect?: ConceptoWhereUniqueInput | ConceptoWhereUniqueInput[]
  }

  export type ClaseCreateNestedManyWithoutEstiloInput = {
    create?: XOR<ClaseCreateWithoutEstiloInput, ClaseUncheckedCreateWithoutEstiloInput> | ClaseCreateWithoutEstiloInput[] | ClaseUncheckedCreateWithoutEstiloInput[]
    connectOrCreate?: ClaseCreateOrConnectWithoutEstiloInput | ClaseCreateOrConnectWithoutEstiloInput[]
    createMany?: ClaseCreateManyEstiloInputEnvelope
    connect?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
  }

  export type AlumnoEstilosCreateNestedManyWithoutEstiloInput = {
    create?: XOR<AlumnoEstilosCreateWithoutEstiloInput, AlumnoEstilosUncheckedCreateWithoutEstiloInput> | AlumnoEstilosCreateWithoutEstiloInput[] | AlumnoEstilosUncheckedCreateWithoutEstiloInput[]
    connectOrCreate?: AlumnoEstilosCreateOrConnectWithoutEstiloInput | AlumnoEstilosCreateOrConnectWithoutEstiloInput[]
    createMany?: AlumnoEstilosCreateManyEstiloInputEnvelope
    connect?: AlumnoEstilosWhereUniqueInput | AlumnoEstilosWhereUniqueInput[]
  }

  export type ProfesorCreateNestedOneWithoutEstilosInput = {
    create?: XOR<ProfesorCreateWithoutEstilosInput, ProfesorUncheckedCreateWithoutEstilosInput>
    connectOrCreate?: ProfesorCreateOrConnectWithoutEstilosInput
    connect?: ProfesorWhereUniqueInput
  }

  export type AlumnoCreateNestedManyWithoutEstilosInput = {
    create?: XOR<AlumnoCreateWithoutEstilosInput, AlumnoUncheckedCreateWithoutEstilosInput> | AlumnoCreateWithoutEstilosInput[] | AlumnoUncheckedCreateWithoutEstilosInput[]
    connectOrCreate?: AlumnoCreateOrConnectWithoutEstilosInput | AlumnoCreateOrConnectWithoutEstilosInput[]
    connect?: AlumnoWhereUniqueInput | AlumnoWhereUniqueInput[]
  }

  export type DeudaUncheckedCreateNestedManyWithoutEstiloInput = {
    create?: XOR<DeudaCreateWithoutEstiloInput, DeudaUncheckedCreateWithoutEstiloInput> | DeudaCreateWithoutEstiloInput[] | DeudaUncheckedCreateWithoutEstiloInput[]
    connectOrCreate?: DeudaCreateOrConnectWithoutEstiloInput | DeudaCreateOrConnectWithoutEstiloInput[]
    createMany?: DeudaCreateManyEstiloInputEnvelope
    connect?: DeudaWhereUniqueInput | DeudaWhereUniqueInput[]
  }

  export type ConceptoUncheckedCreateNestedManyWithoutEstiloInput = {
    create?: XOR<ConceptoCreateWithoutEstiloInput, ConceptoUncheckedCreateWithoutEstiloInput> | ConceptoCreateWithoutEstiloInput[] | ConceptoUncheckedCreateWithoutEstiloInput[]
    connectOrCreate?: ConceptoCreateOrConnectWithoutEstiloInput | ConceptoCreateOrConnectWithoutEstiloInput[]
    createMany?: ConceptoCreateManyEstiloInputEnvelope
    connect?: ConceptoWhereUniqueInput | ConceptoWhereUniqueInput[]
  }

  export type ClaseUncheckedCreateNestedManyWithoutEstiloInput = {
    create?: XOR<ClaseCreateWithoutEstiloInput, ClaseUncheckedCreateWithoutEstiloInput> | ClaseCreateWithoutEstiloInput[] | ClaseUncheckedCreateWithoutEstiloInput[]
    connectOrCreate?: ClaseCreateOrConnectWithoutEstiloInput | ClaseCreateOrConnectWithoutEstiloInput[]
    createMany?: ClaseCreateManyEstiloInputEnvelope
    connect?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
  }

  export type AlumnoEstilosUncheckedCreateNestedManyWithoutEstiloInput = {
    create?: XOR<AlumnoEstilosCreateWithoutEstiloInput, AlumnoEstilosUncheckedCreateWithoutEstiloInput> | AlumnoEstilosCreateWithoutEstiloInput[] | AlumnoEstilosUncheckedCreateWithoutEstiloInput[]
    connectOrCreate?: AlumnoEstilosCreateOrConnectWithoutEstiloInput | AlumnoEstilosCreateOrConnectWithoutEstiloInput[]
    createMany?: AlumnoEstilosCreateManyEstiloInputEnvelope
    connect?: AlumnoEstilosWhereUniqueInput | AlumnoEstilosWhereUniqueInput[]
  }

  export type AlumnoUncheckedCreateNestedManyWithoutEstilosInput = {
    create?: XOR<AlumnoCreateWithoutEstilosInput, AlumnoUncheckedCreateWithoutEstilosInput> | AlumnoCreateWithoutEstilosInput[] | AlumnoUncheckedCreateWithoutEstilosInput[]
    connectOrCreate?: AlumnoCreateOrConnectWithoutEstilosInput | AlumnoCreateOrConnectWithoutEstilosInput[]
    connect?: AlumnoWhereUniqueInput | AlumnoWhereUniqueInput[]
  }

  export type DeudaUpdateManyWithoutEstiloNestedInput = {
    create?: XOR<DeudaCreateWithoutEstiloInput, DeudaUncheckedCreateWithoutEstiloInput> | DeudaCreateWithoutEstiloInput[] | DeudaUncheckedCreateWithoutEstiloInput[]
    connectOrCreate?: DeudaCreateOrConnectWithoutEstiloInput | DeudaCreateOrConnectWithoutEstiloInput[]
    upsert?: DeudaUpsertWithWhereUniqueWithoutEstiloInput | DeudaUpsertWithWhereUniqueWithoutEstiloInput[]
    createMany?: DeudaCreateManyEstiloInputEnvelope
    set?: DeudaWhereUniqueInput | DeudaWhereUniqueInput[]
    disconnect?: DeudaWhereUniqueInput | DeudaWhereUniqueInput[]
    delete?: DeudaWhereUniqueInput | DeudaWhereUniqueInput[]
    connect?: DeudaWhereUniqueInput | DeudaWhereUniqueInput[]
    update?: DeudaUpdateWithWhereUniqueWithoutEstiloInput | DeudaUpdateWithWhereUniqueWithoutEstiloInput[]
    updateMany?: DeudaUpdateManyWithWhereWithoutEstiloInput | DeudaUpdateManyWithWhereWithoutEstiloInput[]
    deleteMany?: DeudaScalarWhereInput | DeudaScalarWhereInput[]
  }

  export type ConceptoUpdateManyWithoutEstiloNestedInput = {
    create?: XOR<ConceptoCreateWithoutEstiloInput, ConceptoUncheckedCreateWithoutEstiloInput> | ConceptoCreateWithoutEstiloInput[] | ConceptoUncheckedCreateWithoutEstiloInput[]
    connectOrCreate?: ConceptoCreateOrConnectWithoutEstiloInput | ConceptoCreateOrConnectWithoutEstiloInput[]
    upsert?: ConceptoUpsertWithWhereUniqueWithoutEstiloInput | ConceptoUpsertWithWhereUniqueWithoutEstiloInput[]
    createMany?: ConceptoCreateManyEstiloInputEnvelope
    set?: ConceptoWhereUniqueInput | ConceptoWhereUniqueInput[]
    disconnect?: ConceptoWhereUniqueInput | ConceptoWhereUniqueInput[]
    delete?: ConceptoWhereUniqueInput | ConceptoWhereUniqueInput[]
    connect?: ConceptoWhereUniqueInput | ConceptoWhereUniqueInput[]
    update?: ConceptoUpdateWithWhereUniqueWithoutEstiloInput | ConceptoUpdateWithWhereUniqueWithoutEstiloInput[]
    updateMany?: ConceptoUpdateManyWithWhereWithoutEstiloInput | ConceptoUpdateManyWithWhereWithoutEstiloInput[]
    deleteMany?: ConceptoScalarWhereInput | ConceptoScalarWhereInput[]
  }

  export type ClaseUpdateManyWithoutEstiloNestedInput = {
    create?: XOR<ClaseCreateWithoutEstiloInput, ClaseUncheckedCreateWithoutEstiloInput> | ClaseCreateWithoutEstiloInput[] | ClaseUncheckedCreateWithoutEstiloInput[]
    connectOrCreate?: ClaseCreateOrConnectWithoutEstiloInput | ClaseCreateOrConnectWithoutEstiloInput[]
    upsert?: ClaseUpsertWithWhereUniqueWithoutEstiloInput | ClaseUpsertWithWhereUniqueWithoutEstiloInput[]
    createMany?: ClaseCreateManyEstiloInputEnvelope
    set?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
    disconnect?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
    delete?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
    connect?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
    update?: ClaseUpdateWithWhereUniqueWithoutEstiloInput | ClaseUpdateWithWhereUniqueWithoutEstiloInput[]
    updateMany?: ClaseUpdateManyWithWhereWithoutEstiloInput | ClaseUpdateManyWithWhereWithoutEstiloInput[]
    deleteMany?: ClaseScalarWhereInput | ClaseScalarWhereInput[]
  }

  export type AlumnoEstilosUpdateManyWithoutEstiloNestedInput = {
    create?: XOR<AlumnoEstilosCreateWithoutEstiloInput, AlumnoEstilosUncheckedCreateWithoutEstiloInput> | AlumnoEstilosCreateWithoutEstiloInput[] | AlumnoEstilosUncheckedCreateWithoutEstiloInput[]
    connectOrCreate?: AlumnoEstilosCreateOrConnectWithoutEstiloInput | AlumnoEstilosCreateOrConnectWithoutEstiloInput[]
    upsert?: AlumnoEstilosUpsertWithWhereUniqueWithoutEstiloInput | AlumnoEstilosUpsertWithWhereUniqueWithoutEstiloInput[]
    createMany?: AlumnoEstilosCreateManyEstiloInputEnvelope
    set?: AlumnoEstilosWhereUniqueInput | AlumnoEstilosWhereUniqueInput[]
    disconnect?: AlumnoEstilosWhereUniqueInput | AlumnoEstilosWhereUniqueInput[]
    delete?: AlumnoEstilosWhereUniqueInput | AlumnoEstilosWhereUniqueInput[]
    connect?: AlumnoEstilosWhereUniqueInput | AlumnoEstilosWhereUniqueInput[]
    update?: AlumnoEstilosUpdateWithWhereUniqueWithoutEstiloInput | AlumnoEstilosUpdateWithWhereUniqueWithoutEstiloInput[]
    updateMany?: AlumnoEstilosUpdateManyWithWhereWithoutEstiloInput | AlumnoEstilosUpdateManyWithWhereWithoutEstiloInput[]
    deleteMany?: AlumnoEstilosScalarWhereInput | AlumnoEstilosScalarWhereInput[]
  }

  export type ProfesorUpdateOneWithoutEstilosNestedInput = {
    create?: XOR<ProfesorCreateWithoutEstilosInput, ProfesorUncheckedCreateWithoutEstilosInput>
    connectOrCreate?: ProfesorCreateOrConnectWithoutEstilosInput
    upsert?: ProfesorUpsertWithoutEstilosInput
    disconnect?: ProfesorWhereInput | boolean
    delete?: ProfesorWhereInput | boolean
    connect?: ProfesorWhereUniqueInput
    update?: XOR<XOR<ProfesorUpdateToOneWithWhereWithoutEstilosInput, ProfesorUpdateWithoutEstilosInput>, ProfesorUncheckedUpdateWithoutEstilosInput>
  }

  export type AlumnoUpdateManyWithoutEstilosNestedInput = {
    create?: XOR<AlumnoCreateWithoutEstilosInput, AlumnoUncheckedCreateWithoutEstilosInput> | AlumnoCreateWithoutEstilosInput[] | AlumnoUncheckedCreateWithoutEstilosInput[]
    connectOrCreate?: AlumnoCreateOrConnectWithoutEstilosInput | AlumnoCreateOrConnectWithoutEstilosInput[]
    upsert?: AlumnoUpsertWithWhereUniqueWithoutEstilosInput | AlumnoUpsertWithWhereUniqueWithoutEstilosInput[]
    set?: AlumnoWhereUniqueInput | AlumnoWhereUniqueInput[]
    disconnect?: AlumnoWhereUniqueInput | AlumnoWhereUniqueInput[]
    delete?: AlumnoWhereUniqueInput | AlumnoWhereUniqueInput[]
    connect?: AlumnoWhereUniqueInput | AlumnoWhereUniqueInput[]
    update?: AlumnoUpdateWithWhereUniqueWithoutEstilosInput | AlumnoUpdateWithWhereUniqueWithoutEstilosInput[]
    updateMany?: AlumnoUpdateManyWithWhereWithoutEstilosInput | AlumnoUpdateManyWithWhereWithoutEstilosInput[]
    deleteMany?: AlumnoScalarWhereInput | AlumnoScalarWhereInput[]
  }

  export type DeudaUncheckedUpdateManyWithoutEstiloNestedInput = {
    create?: XOR<DeudaCreateWithoutEstiloInput, DeudaUncheckedCreateWithoutEstiloInput> | DeudaCreateWithoutEstiloInput[] | DeudaUncheckedCreateWithoutEstiloInput[]
    connectOrCreate?: DeudaCreateOrConnectWithoutEstiloInput | DeudaCreateOrConnectWithoutEstiloInput[]
    upsert?: DeudaUpsertWithWhereUniqueWithoutEstiloInput | DeudaUpsertWithWhereUniqueWithoutEstiloInput[]
    createMany?: DeudaCreateManyEstiloInputEnvelope
    set?: DeudaWhereUniqueInput | DeudaWhereUniqueInput[]
    disconnect?: DeudaWhereUniqueInput | DeudaWhereUniqueInput[]
    delete?: DeudaWhereUniqueInput | DeudaWhereUniqueInput[]
    connect?: DeudaWhereUniqueInput | DeudaWhereUniqueInput[]
    update?: DeudaUpdateWithWhereUniqueWithoutEstiloInput | DeudaUpdateWithWhereUniqueWithoutEstiloInput[]
    updateMany?: DeudaUpdateManyWithWhereWithoutEstiloInput | DeudaUpdateManyWithWhereWithoutEstiloInput[]
    deleteMany?: DeudaScalarWhereInput | DeudaScalarWhereInput[]
  }

  export type ConceptoUncheckedUpdateManyWithoutEstiloNestedInput = {
    create?: XOR<ConceptoCreateWithoutEstiloInput, ConceptoUncheckedCreateWithoutEstiloInput> | ConceptoCreateWithoutEstiloInput[] | ConceptoUncheckedCreateWithoutEstiloInput[]
    connectOrCreate?: ConceptoCreateOrConnectWithoutEstiloInput | ConceptoCreateOrConnectWithoutEstiloInput[]
    upsert?: ConceptoUpsertWithWhereUniqueWithoutEstiloInput | ConceptoUpsertWithWhereUniqueWithoutEstiloInput[]
    createMany?: ConceptoCreateManyEstiloInputEnvelope
    set?: ConceptoWhereUniqueInput | ConceptoWhereUniqueInput[]
    disconnect?: ConceptoWhereUniqueInput | ConceptoWhereUniqueInput[]
    delete?: ConceptoWhereUniqueInput | ConceptoWhereUniqueInput[]
    connect?: ConceptoWhereUniqueInput | ConceptoWhereUniqueInput[]
    update?: ConceptoUpdateWithWhereUniqueWithoutEstiloInput | ConceptoUpdateWithWhereUniqueWithoutEstiloInput[]
    updateMany?: ConceptoUpdateManyWithWhereWithoutEstiloInput | ConceptoUpdateManyWithWhereWithoutEstiloInput[]
    deleteMany?: ConceptoScalarWhereInput | ConceptoScalarWhereInput[]
  }

  export type ClaseUncheckedUpdateManyWithoutEstiloNestedInput = {
    create?: XOR<ClaseCreateWithoutEstiloInput, ClaseUncheckedCreateWithoutEstiloInput> | ClaseCreateWithoutEstiloInput[] | ClaseUncheckedCreateWithoutEstiloInput[]
    connectOrCreate?: ClaseCreateOrConnectWithoutEstiloInput | ClaseCreateOrConnectWithoutEstiloInput[]
    upsert?: ClaseUpsertWithWhereUniqueWithoutEstiloInput | ClaseUpsertWithWhereUniqueWithoutEstiloInput[]
    createMany?: ClaseCreateManyEstiloInputEnvelope
    set?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
    disconnect?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
    delete?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
    connect?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
    update?: ClaseUpdateWithWhereUniqueWithoutEstiloInput | ClaseUpdateWithWhereUniqueWithoutEstiloInput[]
    updateMany?: ClaseUpdateManyWithWhereWithoutEstiloInput | ClaseUpdateManyWithWhereWithoutEstiloInput[]
    deleteMany?: ClaseScalarWhereInput | ClaseScalarWhereInput[]
  }

  export type AlumnoEstilosUncheckedUpdateManyWithoutEstiloNestedInput = {
    create?: XOR<AlumnoEstilosCreateWithoutEstiloInput, AlumnoEstilosUncheckedCreateWithoutEstiloInput> | AlumnoEstilosCreateWithoutEstiloInput[] | AlumnoEstilosUncheckedCreateWithoutEstiloInput[]
    connectOrCreate?: AlumnoEstilosCreateOrConnectWithoutEstiloInput | AlumnoEstilosCreateOrConnectWithoutEstiloInput[]
    upsert?: AlumnoEstilosUpsertWithWhereUniqueWithoutEstiloInput | AlumnoEstilosUpsertWithWhereUniqueWithoutEstiloInput[]
    createMany?: AlumnoEstilosCreateManyEstiloInputEnvelope
    set?: AlumnoEstilosWhereUniqueInput | AlumnoEstilosWhereUniqueInput[]
    disconnect?: AlumnoEstilosWhereUniqueInput | AlumnoEstilosWhereUniqueInput[]
    delete?: AlumnoEstilosWhereUniqueInput | AlumnoEstilosWhereUniqueInput[]
    connect?: AlumnoEstilosWhereUniqueInput | AlumnoEstilosWhereUniqueInput[]
    update?: AlumnoEstilosUpdateWithWhereUniqueWithoutEstiloInput | AlumnoEstilosUpdateWithWhereUniqueWithoutEstiloInput[]
    updateMany?: AlumnoEstilosUpdateManyWithWhereWithoutEstiloInput | AlumnoEstilosUpdateManyWithWhereWithoutEstiloInput[]
    deleteMany?: AlumnoEstilosScalarWhereInput | AlumnoEstilosScalarWhereInput[]
  }

  export type AlumnoUncheckedUpdateManyWithoutEstilosNestedInput = {
    create?: XOR<AlumnoCreateWithoutEstilosInput, AlumnoUncheckedCreateWithoutEstilosInput> | AlumnoCreateWithoutEstilosInput[] | AlumnoUncheckedCreateWithoutEstilosInput[]
    connectOrCreate?: AlumnoCreateOrConnectWithoutEstilosInput | AlumnoCreateOrConnectWithoutEstilosInput[]
    upsert?: AlumnoUpsertWithWhereUniqueWithoutEstilosInput | AlumnoUpsertWithWhereUniqueWithoutEstilosInput[]
    set?: AlumnoWhereUniqueInput | AlumnoWhereUniqueInput[]
    disconnect?: AlumnoWhereUniqueInput | AlumnoWhereUniqueInput[]
    delete?: AlumnoWhereUniqueInput | AlumnoWhereUniqueInput[]
    connect?: AlumnoWhereUniqueInput | AlumnoWhereUniqueInput[]
    update?: AlumnoUpdateWithWhereUniqueWithoutEstilosInput | AlumnoUpdateWithWhereUniqueWithoutEstilosInput[]
    updateMany?: AlumnoUpdateManyWithWhereWithoutEstilosInput | AlumnoUpdateManyWithWhereWithoutEstilosInput[]
    deleteMany?: AlumnoScalarWhereInput | AlumnoScalarWhereInput[]
  }

  export type AlumnoCreateNestedOneWithoutAlumnoEstilosInput = {
    create?: XOR<AlumnoCreateWithoutAlumnoEstilosInput, AlumnoUncheckedCreateWithoutAlumnoEstilosInput>
    connectOrCreate?: AlumnoCreateOrConnectWithoutAlumnoEstilosInput
    connect?: AlumnoWhereUniqueInput
  }

  export type EstiloCreateNestedOneWithoutAlumnoEstilosInput = {
    create?: XOR<EstiloCreateWithoutAlumnoEstilosInput, EstiloUncheckedCreateWithoutAlumnoEstilosInput>
    connectOrCreate?: EstiloCreateOrConnectWithoutAlumnoEstilosInput
    connect?: EstiloWhereUniqueInput
  }

  export type AlumnoUpdateOneRequiredWithoutAlumnoEstilosNestedInput = {
    create?: XOR<AlumnoCreateWithoutAlumnoEstilosInput, AlumnoUncheckedCreateWithoutAlumnoEstilosInput>
    connectOrCreate?: AlumnoCreateOrConnectWithoutAlumnoEstilosInput
    upsert?: AlumnoUpsertWithoutAlumnoEstilosInput
    connect?: AlumnoWhereUniqueInput
    update?: XOR<XOR<AlumnoUpdateToOneWithWhereWithoutAlumnoEstilosInput, AlumnoUpdateWithoutAlumnoEstilosInput>, AlumnoUncheckedUpdateWithoutAlumnoEstilosInput>
  }

  export type EstiloUpdateOneRequiredWithoutAlumnoEstilosNestedInput = {
    create?: XOR<EstiloCreateWithoutAlumnoEstilosInput, EstiloUncheckedCreateWithoutAlumnoEstilosInput>
    connectOrCreate?: EstiloCreateOrConnectWithoutAlumnoEstilosInput
    upsert?: EstiloUpsertWithoutAlumnoEstilosInput
    connect?: EstiloWhereUniqueInput
    update?: XOR<XOR<EstiloUpdateToOneWithWhereWithoutAlumnoEstilosInput, EstiloUpdateWithoutAlumnoEstilosInput>, EstiloUncheckedUpdateWithoutAlumnoEstilosInput>
  }

  export type ClaseCreateNestedManyWithoutProfesorInput = {
    create?: XOR<ClaseCreateWithoutProfesorInput, ClaseUncheckedCreateWithoutProfesorInput> | ClaseCreateWithoutProfesorInput[] | ClaseUncheckedCreateWithoutProfesorInput[]
    connectOrCreate?: ClaseCreateOrConnectWithoutProfesorInput | ClaseCreateOrConnectWithoutProfesorInput[]
    createMany?: ClaseCreateManyProfesorInputEnvelope
    connect?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
  }

  export type EstiloCreateNestedManyWithoutProfesorInput = {
    create?: XOR<EstiloCreateWithoutProfesorInput, EstiloUncheckedCreateWithoutProfesorInput> | EstiloCreateWithoutProfesorInput[] | EstiloUncheckedCreateWithoutProfesorInput[]
    connectOrCreate?: EstiloCreateOrConnectWithoutProfesorInput | EstiloCreateOrConnectWithoutProfesorInput[]
    createMany?: EstiloCreateManyProfesorInputEnvelope
    connect?: EstiloWhereUniqueInput | EstiloWhereUniqueInput[]
  }

  export type LiquidacionCreateNestedManyWithoutProfesorInput = {
    create?: XOR<LiquidacionCreateWithoutProfesorInput, LiquidacionUncheckedCreateWithoutProfesorInput> | LiquidacionCreateWithoutProfesorInput[] | LiquidacionUncheckedCreateWithoutProfesorInput[]
    connectOrCreate?: LiquidacionCreateOrConnectWithoutProfesorInput | LiquidacionCreateOrConnectWithoutProfesorInput[]
    createMany?: LiquidacionCreateManyProfesorInputEnvelope
    connect?: LiquidacionWhereUniqueInput | LiquidacionWhereUniqueInput[]
  }

  export type ClaseUncheckedCreateNestedManyWithoutProfesorInput = {
    create?: XOR<ClaseCreateWithoutProfesorInput, ClaseUncheckedCreateWithoutProfesorInput> | ClaseCreateWithoutProfesorInput[] | ClaseUncheckedCreateWithoutProfesorInput[]
    connectOrCreate?: ClaseCreateOrConnectWithoutProfesorInput | ClaseCreateOrConnectWithoutProfesorInput[]
    createMany?: ClaseCreateManyProfesorInputEnvelope
    connect?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
  }

  export type EstiloUncheckedCreateNestedManyWithoutProfesorInput = {
    create?: XOR<EstiloCreateWithoutProfesorInput, EstiloUncheckedCreateWithoutProfesorInput> | EstiloCreateWithoutProfesorInput[] | EstiloUncheckedCreateWithoutProfesorInput[]
    connectOrCreate?: EstiloCreateOrConnectWithoutProfesorInput | EstiloCreateOrConnectWithoutProfesorInput[]
    createMany?: EstiloCreateManyProfesorInputEnvelope
    connect?: EstiloWhereUniqueInput | EstiloWhereUniqueInput[]
  }

  export type LiquidacionUncheckedCreateNestedManyWithoutProfesorInput = {
    create?: XOR<LiquidacionCreateWithoutProfesorInput, LiquidacionUncheckedCreateWithoutProfesorInput> | LiquidacionCreateWithoutProfesorInput[] | LiquidacionUncheckedCreateWithoutProfesorInput[]
    connectOrCreate?: LiquidacionCreateOrConnectWithoutProfesorInput | LiquidacionCreateOrConnectWithoutProfesorInput[]
    createMany?: LiquidacionCreateManyProfesorInputEnvelope
    connect?: LiquidacionWhereUniqueInput | LiquidacionWhereUniqueInput[]
  }

  export type ClaseUpdateManyWithoutProfesorNestedInput = {
    create?: XOR<ClaseCreateWithoutProfesorInput, ClaseUncheckedCreateWithoutProfesorInput> | ClaseCreateWithoutProfesorInput[] | ClaseUncheckedCreateWithoutProfesorInput[]
    connectOrCreate?: ClaseCreateOrConnectWithoutProfesorInput | ClaseCreateOrConnectWithoutProfesorInput[]
    upsert?: ClaseUpsertWithWhereUniqueWithoutProfesorInput | ClaseUpsertWithWhereUniqueWithoutProfesorInput[]
    createMany?: ClaseCreateManyProfesorInputEnvelope
    set?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
    disconnect?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
    delete?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
    connect?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
    update?: ClaseUpdateWithWhereUniqueWithoutProfesorInput | ClaseUpdateWithWhereUniqueWithoutProfesorInput[]
    updateMany?: ClaseUpdateManyWithWhereWithoutProfesorInput | ClaseUpdateManyWithWhereWithoutProfesorInput[]
    deleteMany?: ClaseScalarWhereInput | ClaseScalarWhereInput[]
  }

  export type EstiloUpdateManyWithoutProfesorNestedInput = {
    create?: XOR<EstiloCreateWithoutProfesorInput, EstiloUncheckedCreateWithoutProfesorInput> | EstiloCreateWithoutProfesorInput[] | EstiloUncheckedCreateWithoutProfesorInput[]
    connectOrCreate?: EstiloCreateOrConnectWithoutProfesorInput | EstiloCreateOrConnectWithoutProfesorInput[]
    upsert?: EstiloUpsertWithWhereUniqueWithoutProfesorInput | EstiloUpsertWithWhereUniqueWithoutProfesorInput[]
    createMany?: EstiloCreateManyProfesorInputEnvelope
    set?: EstiloWhereUniqueInput | EstiloWhereUniqueInput[]
    disconnect?: EstiloWhereUniqueInput | EstiloWhereUniqueInput[]
    delete?: EstiloWhereUniqueInput | EstiloWhereUniqueInput[]
    connect?: EstiloWhereUniqueInput | EstiloWhereUniqueInput[]
    update?: EstiloUpdateWithWhereUniqueWithoutProfesorInput | EstiloUpdateWithWhereUniqueWithoutProfesorInput[]
    updateMany?: EstiloUpdateManyWithWhereWithoutProfesorInput | EstiloUpdateManyWithWhereWithoutProfesorInput[]
    deleteMany?: EstiloScalarWhereInput | EstiloScalarWhereInput[]
  }

  export type LiquidacionUpdateManyWithoutProfesorNestedInput = {
    create?: XOR<LiquidacionCreateWithoutProfesorInput, LiquidacionUncheckedCreateWithoutProfesorInput> | LiquidacionCreateWithoutProfesorInput[] | LiquidacionUncheckedCreateWithoutProfesorInput[]
    connectOrCreate?: LiquidacionCreateOrConnectWithoutProfesorInput | LiquidacionCreateOrConnectWithoutProfesorInput[]
    upsert?: LiquidacionUpsertWithWhereUniqueWithoutProfesorInput | LiquidacionUpsertWithWhereUniqueWithoutProfesorInput[]
    createMany?: LiquidacionCreateManyProfesorInputEnvelope
    set?: LiquidacionWhereUniqueInput | LiquidacionWhereUniqueInput[]
    disconnect?: LiquidacionWhereUniqueInput | LiquidacionWhereUniqueInput[]
    delete?: LiquidacionWhereUniqueInput | LiquidacionWhereUniqueInput[]
    connect?: LiquidacionWhereUniqueInput | LiquidacionWhereUniqueInput[]
    update?: LiquidacionUpdateWithWhereUniqueWithoutProfesorInput | LiquidacionUpdateWithWhereUniqueWithoutProfesorInput[]
    updateMany?: LiquidacionUpdateManyWithWhereWithoutProfesorInput | LiquidacionUpdateManyWithWhereWithoutProfesorInput[]
    deleteMany?: LiquidacionScalarWhereInput | LiquidacionScalarWhereInput[]
  }

  export type ClaseUncheckedUpdateManyWithoutProfesorNestedInput = {
    create?: XOR<ClaseCreateWithoutProfesorInput, ClaseUncheckedCreateWithoutProfesorInput> | ClaseCreateWithoutProfesorInput[] | ClaseUncheckedCreateWithoutProfesorInput[]
    connectOrCreate?: ClaseCreateOrConnectWithoutProfesorInput | ClaseCreateOrConnectWithoutProfesorInput[]
    upsert?: ClaseUpsertWithWhereUniqueWithoutProfesorInput | ClaseUpsertWithWhereUniqueWithoutProfesorInput[]
    createMany?: ClaseCreateManyProfesorInputEnvelope
    set?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
    disconnect?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
    delete?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
    connect?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
    update?: ClaseUpdateWithWhereUniqueWithoutProfesorInput | ClaseUpdateWithWhereUniqueWithoutProfesorInput[]
    updateMany?: ClaseUpdateManyWithWhereWithoutProfesorInput | ClaseUpdateManyWithWhereWithoutProfesorInput[]
    deleteMany?: ClaseScalarWhereInput | ClaseScalarWhereInput[]
  }

  export type EstiloUncheckedUpdateManyWithoutProfesorNestedInput = {
    create?: XOR<EstiloCreateWithoutProfesorInput, EstiloUncheckedCreateWithoutProfesorInput> | EstiloCreateWithoutProfesorInput[] | EstiloUncheckedCreateWithoutProfesorInput[]
    connectOrCreate?: EstiloCreateOrConnectWithoutProfesorInput | EstiloCreateOrConnectWithoutProfesorInput[]
    upsert?: EstiloUpsertWithWhereUniqueWithoutProfesorInput | EstiloUpsertWithWhereUniqueWithoutProfesorInput[]
    createMany?: EstiloCreateManyProfesorInputEnvelope
    set?: EstiloWhereUniqueInput | EstiloWhereUniqueInput[]
    disconnect?: EstiloWhereUniqueInput | EstiloWhereUniqueInput[]
    delete?: EstiloWhereUniqueInput | EstiloWhereUniqueInput[]
    connect?: EstiloWhereUniqueInput | EstiloWhereUniqueInput[]
    update?: EstiloUpdateWithWhereUniqueWithoutProfesorInput | EstiloUpdateWithWhereUniqueWithoutProfesorInput[]
    updateMany?: EstiloUpdateManyWithWhereWithoutProfesorInput | EstiloUpdateManyWithWhereWithoutProfesorInput[]
    deleteMany?: EstiloScalarWhereInput | EstiloScalarWhereInput[]
  }

  export type LiquidacionUncheckedUpdateManyWithoutProfesorNestedInput = {
    create?: XOR<LiquidacionCreateWithoutProfesorInput, LiquidacionUncheckedCreateWithoutProfesorInput> | LiquidacionCreateWithoutProfesorInput[] | LiquidacionUncheckedCreateWithoutProfesorInput[]
    connectOrCreate?: LiquidacionCreateOrConnectWithoutProfesorInput | LiquidacionCreateOrConnectWithoutProfesorInput[]
    upsert?: LiquidacionUpsertWithWhereUniqueWithoutProfesorInput | LiquidacionUpsertWithWhereUniqueWithoutProfesorInput[]
    createMany?: LiquidacionCreateManyProfesorInputEnvelope
    set?: LiquidacionWhereUniqueInput | LiquidacionWhereUniqueInput[]
    disconnect?: LiquidacionWhereUniqueInput | LiquidacionWhereUniqueInput[]
    delete?: LiquidacionWhereUniqueInput | LiquidacionWhereUniqueInput[]
    connect?: LiquidacionWhereUniqueInput | LiquidacionWhereUniqueInput[]
    update?: LiquidacionUpdateWithWhereUniqueWithoutProfesorInput | LiquidacionUpdateWithWhereUniqueWithoutProfesorInput[]
    updateMany?: LiquidacionUpdateManyWithWhereWithoutProfesorInput | LiquidacionUpdateManyWithWhereWithoutProfesorInput[]
    deleteMany?: LiquidacionScalarWhereInput | LiquidacionScalarWhereInput[]
  }

  export type AlumnoCreateNestedOneWithoutCtaCteInput = {
    create?: XOR<AlumnoCreateWithoutCtaCteInput, AlumnoUncheckedCreateWithoutCtaCteInput>
    connectOrCreate?: AlumnoCreateOrConnectWithoutCtaCteInput
    connect?: AlumnoWhereUniqueInput
  }

  export type AlumnoUpdateOneRequiredWithoutCtaCteNestedInput = {
    create?: XOR<AlumnoCreateWithoutCtaCteInput, AlumnoUncheckedCreateWithoutCtaCteInput>
    connectOrCreate?: AlumnoCreateOrConnectWithoutCtaCteInput
    upsert?: AlumnoUpsertWithoutCtaCteInput
    connect?: AlumnoWhereUniqueInput
    update?: XOR<XOR<AlumnoUpdateToOneWithWhereWithoutCtaCteInput, AlumnoUpdateWithoutCtaCteInput>, AlumnoUncheckedUpdateWithoutCtaCteInput>
  }

  export type ProfesorCreateNestedOneWithoutClasesInput = {
    create?: XOR<ProfesorCreateWithoutClasesInput, ProfesorUncheckedCreateWithoutClasesInput>
    connectOrCreate?: ProfesorCreateOrConnectWithoutClasesInput
    connect?: ProfesorWhereUniqueInput
  }

  export type EstiloCreateNestedOneWithoutClasesInput = {
    create?: XOR<EstiloCreateWithoutClasesInput, EstiloUncheckedCreateWithoutClasesInput>
    connectOrCreate?: EstiloCreateOrConnectWithoutClasesInput
    connect?: EstiloWhereUniqueInput
  }

  export type AsistenciaCreateNestedManyWithoutClaseInput = {
    create?: XOR<AsistenciaCreateWithoutClaseInput, AsistenciaUncheckedCreateWithoutClaseInput> | AsistenciaCreateWithoutClaseInput[] | AsistenciaUncheckedCreateWithoutClaseInput[]
    connectOrCreate?: AsistenciaCreateOrConnectWithoutClaseInput | AsistenciaCreateOrConnectWithoutClaseInput[]
    createMany?: AsistenciaCreateManyClaseInputEnvelope
    connect?: AsistenciaWhereUniqueInput | AsistenciaWhereUniqueInput[]
  }

  export type AlumnoSueltoCreateNestedManyWithoutClasesInput = {
    create?: XOR<AlumnoSueltoCreateWithoutClasesInput, AlumnoSueltoUncheckedCreateWithoutClasesInput> | AlumnoSueltoCreateWithoutClasesInput[] | AlumnoSueltoUncheckedCreateWithoutClasesInput[]
    connectOrCreate?: AlumnoSueltoCreateOrConnectWithoutClasesInput | AlumnoSueltoCreateOrConnectWithoutClasesInput[]
    connect?: AlumnoSueltoWhereUniqueInput | AlumnoSueltoWhereUniqueInput[]
  }

  export type ReciboCreateNestedManyWithoutClaseInput = {
    create?: XOR<ReciboCreateWithoutClaseInput, ReciboUncheckedCreateWithoutClaseInput> | ReciboCreateWithoutClaseInput[] | ReciboUncheckedCreateWithoutClaseInput[]
    connectOrCreate?: ReciboCreateOrConnectWithoutClaseInput | ReciboCreateOrConnectWithoutClaseInput[]
    createMany?: ReciboCreateManyClaseInputEnvelope
    connect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
  }

  export type AsistenciaUncheckedCreateNestedManyWithoutClaseInput = {
    create?: XOR<AsistenciaCreateWithoutClaseInput, AsistenciaUncheckedCreateWithoutClaseInput> | AsistenciaCreateWithoutClaseInput[] | AsistenciaUncheckedCreateWithoutClaseInput[]
    connectOrCreate?: AsistenciaCreateOrConnectWithoutClaseInput | AsistenciaCreateOrConnectWithoutClaseInput[]
    createMany?: AsistenciaCreateManyClaseInputEnvelope
    connect?: AsistenciaWhereUniqueInput | AsistenciaWhereUniqueInput[]
  }

  export type AlumnoSueltoUncheckedCreateNestedManyWithoutClasesInput = {
    create?: XOR<AlumnoSueltoCreateWithoutClasesInput, AlumnoSueltoUncheckedCreateWithoutClasesInput> | AlumnoSueltoCreateWithoutClasesInput[] | AlumnoSueltoUncheckedCreateWithoutClasesInput[]
    connectOrCreate?: AlumnoSueltoCreateOrConnectWithoutClasesInput | AlumnoSueltoCreateOrConnectWithoutClasesInput[]
    connect?: AlumnoSueltoWhereUniqueInput | AlumnoSueltoWhereUniqueInput[]
  }

  export type ReciboUncheckedCreateNestedManyWithoutClaseInput = {
    create?: XOR<ReciboCreateWithoutClaseInput, ReciboUncheckedCreateWithoutClaseInput> | ReciboCreateWithoutClaseInput[] | ReciboUncheckedCreateWithoutClaseInput[]
    connectOrCreate?: ReciboCreateOrConnectWithoutClaseInput | ReciboCreateOrConnectWithoutClaseInput[]
    createMany?: ReciboCreateManyClaseInputEnvelope
    connect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
  }

  export type ProfesorUpdateOneRequiredWithoutClasesNestedInput = {
    create?: XOR<ProfesorCreateWithoutClasesInput, ProfesorUncheckedCreateWithoutClasesInput>
    connectOrCreate?: ProfesorCreateOrConnectWithoutClasesInput
    upsert?: ProfesorUpsertWithoutClasesInput
    connect?: ProfesorWhereUniqueInput
    update?: XOR<XOR<ProfesorUpdateToOneWithWhereWithoutClasesInput, ProfesorUpdateWithoutClasesInput>, ProfesorUncheckedUpdateWithoutClasesInput>
  }

  export type EstiloUpdateOneRequiredWithoutClasesNestedInput = {
    create?: XOR<EstiloCreateWithoutClasesInput, EstiloUncheckedCreateWithoutClasesInput>
    connectOrCreate?: EstiloCreateOrConnectWithoutClasesInput
    upsert?: EstiloUpsertWithoutClasesInput
    connect?: EstiloWhereUniqueInput
    update?: XOR<XOR<EstiloUpdateToOneWithWhereWithoutClasesInput, EstiloUpdateWithoutClasesInput>, EstiloUncheckedUpdateWithoutClasesInput>
  }

  export type AsistenciaUpdateManyWithoutClaseNestedInput = {
    create?: XOR<AsistenciaCreateWithoutClaseInput, AsistenciaUncheckedCreateWithoutClaseInput> | AsistenciaCreateWithoutClaseInput[] | AsistenciaUncheckedCreateWithoutClaseInput[]
    connectOrCreate?: AsistenciaCreateOrConnectWithoutClaseInput | AsistenciaCreateOrConnectWithoutClaseInput[]
    upsert?: AsistenciaUpsertWithWhereUniqueWithoutClaseInput | AsistenciaUpsertWithWhereUniqueWithoutClaseInput[]
    createMany?: AsistenciaCreateManyClaseInputEnvelope
    set?: AsistenciaWhereUniqueInput | AsistenciaWhereUniqueInput[]
    disconnect?: AsistenciaWhereUniqueInput | AsistenciaWhereUniqueInput[]
    delete?: AsistenciaWhereUniqueInput | AsistenciaWhereUniqueInput[]
    connect?: AsistenciaWhereUniqueInput | AsistenciaWhereUniqueInput[]
    update?: AsistenciaUpdateWithWhereUniqueWithoutClaseInput | AsistenciaUpdateWithWhereUniqueWithoutClaseInput[]
    updateMany?: AsistenciaUpdateManyWithWhereWithoutClaseInput | AsistenciaUpdateManyWithWhereWithoutClaseInput[]
    deleteMany?: AsistenciaScalarWhereInput | AsistenciaScalarWhereInput[]
  }

  export type AlumnoSueltoUpdateManyWithoutClasesNestedInput = {
    create?: XOR<AlumnoSueltoCreateWithoutClasesInput, AlumnoSueltoUncheckedCreateWithoutClasesInput> | AlumnoSueltoCreateWithoutClasesInput[] | AlumnoSueltoUncheckedCreateWithoutClasesInput[]
    connectOrCreate?: AlumnoSueltoCreateOrConnectWithoutClasesInput | AlumnoSueltoCreateOrConnectWithoutClasesInput[]
    upsert?: AlumnoSueltoUpsertWithWhereUniqueWithoutClasesInput | AlumnoSueltoUpsertWithWhereUniqueWithoutClasesInput[]
    set?: AlumnoSueltoWhereUniqueInput | AlumnoSueltoWhereUniqueInput[]
    disconnect?: AlumnoSueltoWhereUniqueInput | AlumnoSueltoWhereUniqueInput[]
    delete?: AlumnoSueltoWhereUniqueInput | AlumnoSueltoWhereUniqueInput[]
    connect?: AlumnoSueltoWhereUniqueInput | AlumnoSueltoWhereUniqueInput[]
    update?: AlumnoSueltoUpdateWithWhereUniqueWithoutClasesInput | AlumnoSueltoUpdateWithWhereUniqueWithoutClasesInput[]
    updateMany?: AlumnoSueltoUpdateManyWithWhereWithoutClasesInput | AlumnoSueltoUpdateManyWithWhereWithoutClasesInput[]
    deleteMany?: AlumnoSueltoScalarWhereInput | AlumnoSueltoScalarWhereInput[]
  }

  export type ReciboUpdateManyWithoutClaseNestedInput = {
    create?: XOR<ReciboCreateWithoutClaseInput, ReciboUncheckedCreateWithoutClaseInput> | ReciboCreateWithoutClaseInput[] | ReciboUncheckedCreateWithoutClaseInput[]
    connectOrCreate?: ReciboCreateOrConnectWithoutClaseInput | ReciboCreateOrConnectWithoutClaseInput[]
    upsert?: ReciboUpsertWithWhereUniqueWithoutClaseInput | ReciboUpsertWithWhereUniqueWithoutClaseInput[]
    createMany?: ReciboCreateManyClaseInputEnvelope
    set?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    disconnect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    delete?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    connect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    update?: ReciboUpdateWithWhereUniqueWithoutClaseInput | ReciboUpdateWithWhereUniqueWithoutClaseInput[]
    updateMany?: ReciboUpdateManyWithWhereWithoutClaseInput | ReciboUpdateManyWithWhereWithoutClaseInput[]
    deleteMany?: ReciboScalarWhereInput | ReciboScalarWhereInput[]
  }

  export type AsistenciaUncheckedUpdateManyWithoutClaseNestedInput = {
    create?: XOR<AsistenciaCreateWithoutClaseInput, AsistenciaUncheckedCreateWithoutClaseInput> | AsistenciaCreateWithoutClaseInput[] | AsistenciaUncheckedCreateWithoutClaseInput[]
    connectOrCreate?: AsistenciaCreateOrConnectWithoutClaseInput | AsistenciaCreateOrConnectWithoutClaseInput[]
    upsert?: AsistenciaUpsertWithWhereUniqueWithoutClaseInput | AsistenciaUpsertWithWhereUniqueWithoutClaseInput[]
    createMany?: AsistenciaCreateManyClaseInputEnvelope
    set?: AsistenciaWhereUniqueInput | AsistenciaWhereUniqueInput[]
    disconnect?: AsistenciaWhereUniqueInput | AsistenciaWhereUniqueInput[]
    delete?: AsistenciaWhereUniqueInput | AsistenciaWhereUniqueInput[]
    connect?: AsistenciaWhereUniqueInput | AsistenciaWhereUniqueInput[]
    update?: AsistenciaUpdateWithWhereUniqueWithoutClaseInput | AsistenciaUpdateWithWhereUniqueWithoutClaseInput[]
    updateMany?: AsistenciaUpdateManyWithWhereWithoutClaseInput | AsistenciaUpdateManyWithWhereWithoutClaseInput[]
    deleteMany?: AsistenciaScalarWhereInput | AsistenciaScalarWhereInput[]
  }

  export type AlumnoSueltoUncheckedUpdateManyWithoutClasesNestedInput = {
    create?: XOR<AlumnoSueltoCreateWithoutClasesInput, AlumnoSueltoUncheckedCreateWithoutClasesInput> | AlumnoSueltoCreateWithoutClasesInput[] | AlumnoSueltoUncheckedCreateWithoutClasesInput[]
    connectOrCreate?: AlumnoSueltoCreateOrConnectWithoutClasesInput | AlumnoSueltoCreateOrConnectWithoutClasesInput[]
    upsert?: AlumnoSueltoUpsertWithWhereUniqueWithoutClasesInput | AlumnoSueltoUpsertWithWhereUniqueWithoutClasesInput[]
    set?: AlumnoSueltoWhereUniqueInput | AlumnoSueltoWhereUniqueInput[]
    disconnect?: AlumnoSueltoWhereUniqueInput | AlumnoSueltoWhereUniqueInput[]
    delete?: AlumnoSueltoWhereUniqueInput | AlumnoSueltoWhereUniqueInput[]
    connect?: AlumnoSueltoWhereUniqueInput | AlumnoSueltoWhereUniqueInput[]
    update?: AlumnoSueltoUpdateWithWhereUniqueWithoutClasesInput | AlumnoSueltoUpdateWithWhereUniqueWithoutClasesInput[]
    updateMany?: AlumnoSueltoUpdateManyWithWhereWithoutClasesInput | AlumnoSueltoUpdateManyWithWhereWithoutClasesInput[]
    deleteMany?: AlumnoSueltoScalarWhereInput | AlumnoSueltoScalarWhereInput[]
  }

  export type ReciboUncheckedUpdateManyWithoutClaseNestedInput = {
    create?: XOR<ReciboCreateWithoutClaseInput, ReciboUncheckedCreateWithoutClaseInput> | ReciboCreateWithoutClaseInput[] | ReciboUncheckedCreateWithoutClaseInput[]
    connectOrCreate?: ReciboCreateOrConnectWithoutClaseInput | ReciboCreateOrConnectWithoutClaseInput[]
    upsert?: ReciboUpsertWithWhereUniqueWithoutClaseInput | ReciboUpsertWithWhereUniqueWithoutClaseInput[]
    createMany?: ReciboCreateManyClaseInputEnvelope
    set?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    disconnect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    delete?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    connect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    update?: ReciboUpdateWithWhereUniqueWithoutClaseInput | ReciboUpdateWithWhereUniqueWithoutClaseInput[]
    updateMany?: ReciboUpdateManyWithWhereWithoutClaseInput | ReciboUpdateManyWithWhereWithoutClaseInput[]
    deleteMany?: ReciboScalarWhereInput | ReciboScalarWhereInput[]
  }

  export type ClaseCreateNestedOneWithoutAsistenciasInput = {
    create?: XOR<ClaseCreateWithoutAsistenciasInput, ClaseUncheckedCreateWithoutAsistenciasInput>
    connectOrCreate?: ClaseCreateOrConnectWithoutAsistenciasInput
    connect?: ClaseWhereUniqueInput
  }

  export type AlumnoCreateNestedOneWithoutAsistenciasInput = {
    create?: XOR<AlumnoCreateWithoutAsistenciasInput, AlumnoUncheckedCreateWithoutAsistenciasInput>
    connectOrCreate?: AlumnoCreateOrConnectWithoutAsistenciasInput
    connect?: AlumnoWhereUniqueInput
  }

  export type ClaseUpdateOneRequiredWithoutAsistenciasNestedInput = {
    create?: XOR<ClaseCreateWithoutAsistenciasInput, ClaseUncheckedCreateWithoutAsistenciasInput>
    connectOrCreate?: ClaseCreateOrConnectWithoutAsistenciasInput
    upsert?: ClaseUpsertWithoutAsistenciasInput
    connect?: ClaseWhereUniqueInput
    update?: XOR<XOR<ClaseUpdateToOneWithWhereWithoutAsistenciasInput, ClaseUpdateWithoutAsistenciasInput>, ClaseUncheckedUpdateWithoutAsistenciasInput>
  }

  export type AlumnoUpdateOneRequiredWithoutAsistenciasNestedInput = {
    create?: XOR<AlumnoCreateWithoutAsistenciasInput, AlumnoUncheckedCreateWithoutAsistenciasInput>
    connectOrCreate?: AlumnoCreateOrConnectWithoutAsistenciasInput
    upsert?: AlumnoUpsertWithoutAsistenciasInput
    connect?: AlumnoWhereUniqueInput
    update?: XOR<XOR<AlumnoUpdateToOneWithWhereWithoutAsistenciasInput, AlumnoUpdateWithoutAsistenciasInput>, AlumnoUncheckedUpdateWithoutAsistenciasInput>
  }

  export type ReciboCreateNestedManyWithoutAlumnoSueltoInput = {
    create?: XOR<ReciboCreateWithoutAlumnoSueltoInput, ReciboUncheckedCreateWithoutAlumnoSueltoInput> | ReciboCreateWithoutAlumnoSueltoInput[] | ReciboUncheckedCreateWithoutAlumnoSueltoInput[]
    connectOrCreate?: ReciboCreateOrConnectWithoutAlumnoSueltoInput | ReciboCreateOrConnectWithoutAlumnoSueltoInput[]
    createMany?: ReciboCreateManyAlumnoSueltoInputEnvelope
    connect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
  }

  export type ClaseCreateNestedManyWithoutAlumnosSueltosInput = {
    create?: XOR<ClaseCreateWithoutAlumnosSueltosInput, ClaseUncheckedCreateWithoutAlumnosSueltosInput> | ClaseCreateWithoutAlumnosSueltosInput[] | ClaseUncheckedCreateWithoutAlumnosSueltosInput[]
    connectOrCreate?: ClaseCreateOrConnectWithoutAlumnosSueltosInput | ClaseCreateOrConnectWithoutAlumnosSueltosInput[]
    connect?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
  }

  export type AlumnoCreateNestedOneWithoutAlumnosSueltosAnterioresInput = {
    create?: XOR<AlumnoCreateWithoutAlumnosSueltosAnterioresInput, AlumnoUncheckedCreateWithoutAlumnosSueltosAnterioresInput>
    connectOrCreate?: AlumnoCreateOrConnectWithoutAlumnosSueltosAnterioresInput
    connect?: AlumnoWhereUniqueInput
  }

  export type ReciboUncheckedCreateNestedManyWithoutAlumnoSueltoInput = {
    create?: XOR<ReciboCreateWithoutAlumnoSueltoInput, ReciboUncheckedCreateWithoutAlumnoSueltoInput> | ReciboCreateWithoutAlumnoSueltoInput[] | ReciboUncheckedCreateWithoutAlumnoSueltoInput[]
    connectOrCreate?: ReciboCreateOrConnectWithoutAlumnoSueltoInput | ReciboCreateOrConnectWithoutAlumnoSueltoInput[]
    createMany?: ReciboCreateManyAlumnoSueltoInputEnvelope
    connect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
  }

  export type ClaseUncheckedCreateNestedManyWithoutAlumnosSueltosInput = {
    create?: XOR<ClaseCreateWithoutAlumnosSueltosInput, ClaseUncheckedCreateWithoutAlumnosSueltosInput> | ClaseCreateWithoutAlumnosSueltosInput[] | ClaseUncheckedCreateWithoutAlumnosSueltosInput[]
    connectOrCreate?: ClaseCreateOrConnectWithoutAlumnosSueltosInput | ClaseCreateOrConnectWithoutAlumnosSueltosInput[]
    connect?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
  }

  export type ReciboUpdateManyWithoutAlumnoSueltoNestedInput = {
    create?: XOR<ReciboCreateWithoutAlumnoSueltoInput, ReciboUncheckedCreateWithoutAlumnoSueltoInput> | ReciboCreateWithoutAlumnoSueltoInput[] | ReciboUncheckedCreateWithoutAlumnoSueltoInput[]
    connectOrCreate?: ReciboCreateOrConnectWithoutAlumnoSueltoInput | ReciboCreateOrConnectWithoutAlumnoSueltoInput[]
    upsert?: ReciboUpsertWithWhereUniqueWithoutAlumnoSueltoInput | ReciboUpsertWithWhereUniqueWithoutAlumnoSueltoInput[]
    createMany?: ReciboCreateManyAlumnoSueltoInputEnvelope
    set?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    disconnect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    delete?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    connect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    update?: ReciboUpdateWithWhereUniqueWithoutAlumnoSueltoInput | ReciboUpdateWithWhereUniqueWithoutAlumnoSueltoInput[]
    updateMany?: ReciboUpdateManyWithWhereWithoutAlumnoSueltoInput | ReciboUpdateManyWithWhereWithoutAlumnoSueltoInput[]
    deleteMany?: ReciboScalarWhereInput | ReciboScalarWhereInput[]
  }

  export type ClaseUpdateManyWithoutAlumnosSueltosNestedInput = {
    create?: XOR<ClaseCreateWithoutAlumnosSueltosInput, ClaseUncheckedCreateWithoutAlumnosSueltosInput> | ClaseCreateWithoutAlumnosSueltosInput[] | ClaseUncheckedCreateWithoutAlumnosSueltosInput[]
    connectOrCreate?: ClaseCreateOrConnectWithoutAlumnosSueltosInput | ClaseCreateOrConnectWithoutAlumnosSueltosInput[]
    upsert?: ClaseUpsertWithWhereUniqueWithoutAlumnosSueltosInput | ClaseUpsertWithWhereUniqueWithoutAlumnosSueltosInput[]
    set?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
    disconnect?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
    delete?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
    connect?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
    update?: ClaseUpdateWithWhereUniqueWithoutAlumnosSueltosInput | ClaseUpdateWithWhereUniqueWithoutAlumnosSueltosInput[]
    updateMany?: ClaseUpdateManyWithWhereWithoutAlumnosSueltosInput | ClaseUpdateManyWithWhereWithoutAlumnosSueltosInput[]
    deleteMany?: ClaseScalarWhereInput | ClaseScalarWhereInput[]
  }

  export type AlumnoUpdateOneWithoutAlumnosSueltosAnterioresNestedInput = {
    create?: XOR<AlumnoCreateWithoutAlumnosSueltosAnterioresInput, AlumnoUncheckedCreateWithoutAlumnosSueltosAnterioresInput>
    connectOrCreate?: AlumnoCreateOrConnectWithoutAlumnosSueltosAnterioresInput
    upsert?: AlumnoUpsertWithoutAlumnosSueltosAnterioresInput
    disconnect?: AlumnoWhereInput | boolean
    delete?: AlumnoWhereInput | boolean
    connect?: AlumnoWhereUniqueInput
    update?: XOR<XOR<AlumnoUpdateToOneWithWhereWithoutAlumnosSueltosAnterioresInput, AlumnoUpdateWithoutAlumnosSueltosAnterioresInput>, AlumnoUncheckedUpdateWithoutAlumnosSueltosAnterioresInput>
  }

  export type ReciboUncheckedUpdateManyWithoutAlumnoSueltoNestedInput = {
    create?: XOR<ReciboCreateWithoutAlumnoSueltoInput, ReciboUncheckedCreateWithoutAlumnoSueltoInput> | ReciboCreateWithoutAlumnoSueltoInput[] | ReciboUncheckedCreateWithoutAlumnoSueltoInput[]
    connectOrCreate?: ReciboCreateOrConnectWithoutAlumnoSueltoInput | ReciboCreateOrConnectWithoutAlumnoSueltoInput[]
    upsert?: ReciboUpsertWithWhereUniqueWithoutAlumnoSueltoInput | ReciboUpsertWithWhereUniqueWithoutAlumnoSueltoInput[]
    createMany?: ReciboCreateManyAlumnoSueltoInputEnvelope
    set?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    disconnect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    delete?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    connect?: ReciboWhereUniqueInput | ReciboWhereUniqueInput[]
    update?: ReciboUpdateWithWhereUniqueWithoutAlumnoSueltoInput | ReciboUpdateWithWhereUniqueWithoutAlumnoSueltoInput[]
    updateMany?: ReciboUpdateManyWithWhereWithoutAlumnoSueltoInput | ReciboUpdateManyWithWhereWithoutAlumnoSueltoInput[]
    deleteMany?: ReciboScalarWhereInput | ReciboScalarWhereInput[]
  }

  export type ClaseUncheckedUpdateManyWithoutAlumnosSueltosNestedInput = {
    create?: XOR<ClaseCreateWithoutAlumnosSueltosInput, ClaseUncheckedCreateWithoutAlumnosSueltosInput> | ClaseCreateWithoutAlumnosSueltosInput[] | ClaseUncheckedCreateWithoutAlumnosSueltosInput[]
    connectOrCreate?: ClaseCreateOrConnectWithoutAlumnosSueltosInput | ClaseCreateOrConnectWithoutAlumnosSueltosInput[]
    upsert?: ClaseUpsertWithWhereUniqueWithoutAlumnosSueltosInput | ClaseUpsertWithWhereUniqueWithoutAlumnosSueltosInput[]
    set?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
    disconnect?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
    delete?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
    connect?: ClaseWhereUniqueInput | ClaseWhereUniqueInput[]
    update?: ClaseUpdateWithWhereUniqueWithoutAlumnosSueltosInput | ClaseUpdateWithWhereUniqueWithoutAlumnosSueltosInput[]
    updateMany?: ClaseUpdateManyWithWhereWithoutAlumnosSueltosInput | ClaseUpdateManyWithWhereWithoutAlumnosSueltosInput[]
    deleteMany?: ClaseScalarWhereInput | ClaseScalarWhereInput[]
  }

  export type ProfesorCreateNestedOneWithoutLiquidacionesInput = {
    create?: XOR<ProfesorCreateWithoutLiquidacionesInput, ProfesorUncheckedCreateWithoutLiquidacionesInput>
    connectOrCreate?: ProfesorCreateOrConnectWithoutLiquidacionesInput
    connect?: ProfesorWhereUniqueInput
  }

  export type DetalleLiquidacionCreateNestedManyWithoutLiquidacionInput = {
    create?: XOR<DetalleLiquidacionCreateWithoutLiquidacionInput, DetalleLiquidacionUncheckedCreateWithoutLiquidacionInput> | DetalleLiquidacionCreateWithoutLiquidacionInput[] | DetalleLiquidacionUncheckedCreateWithoutLiquidacionInput[]
    connectOrCreate?: DetalleLiquidacionCreateOrConnectWithoutLiquidacionInput | DetalleLiquidacionCreateOrConnectWithoutLiquidacionInput[]
    createMany?: DetalleLiquidacionCreateManyLiquidacionInputEnvelope
    connect?: DetalleLiquidacionWhereUniqueInput | DetalleLiquidacionWhereUniqueInput[]
  }

  export type DetalleLiquidacionUncheckedCreateNestedManyWithoutLiquidacionInput = {
    create?: XOR<DetalleLiquidacionCreateWithoutLiquidacionInput, DetalleLiquidacionUncheckedCreateWithoutLiquidacionInput> | DetalleLiquidacionCreateWithoutLiquidacionInput[] | DetalleLiquidacionUncheckedCreateWithoutLiquidacionInput[]
    connectOrCreate?: DetalleLiquidacionCreateOrConnectWithoutLiquidacionInput | DetalleLiquidacionCreateOrConnectWithoutLiquidacionInput[]
    createMany?: DetalleLiquidacionCreateManyLiquidacionInputEnvelope
    connect?: DetalleLiquidacionWhereUniqueInput | DetalleLiquidacionWhereUniqueInput[]
  }

  export type EnumEstadoLiquidacionFieldUpdateOperationsInput = {
    set?: $Enums.EstadoLiquidacion
  }

  export type NullableEnumTipoPagoFieldUpdateOperationsInput = {
    set?: $Enums.TipoPago | null
  }

  export type ProfesorUpdateOneWithoutLiquidacionesNestedInput = {
    create?: XOR<ProfesorCreateWithoutLiquidacionesInput, ProfesorUncheckedCreateWithoutLiquidacionesInput>
    connectOrCreate?: ProfesorCreateOrConnectWithoutLiquidacionesInput
    upsert?: ProfesorUpsertWithoutLiquidacionesInput
    disconnect?: ProfesorWhereInput | boolean
    delete?: ProfesorWhereInput | boolean
    connect?: ProfesorWhereUniqueInput
    update?: XOR<XOR<ProfesorUpdateToOneWithWhereWithoutLiquidacionesInput, ProfesorUpdateWithoutLiquidacionesInput>, ProfesorUncheckedUpdateWithoutLiquidacionesInput>
  }

  export type DetalleLiquidacionUpdateManyWithoutLiquidacionNestedInput = {
    create?: XOR<DetalleLiquidacionCreateWithoutLiquidacionInput, DetalleLiquidacionUncheckedCreateWithoutLiquidacionInput> | DetalleLiquidacionCreateWithoutLiquidacionInput[] | DetalleLiquidacionUncheckedCreateWithoutLiquidacionInput[]
    connectOrCreate?: DetalleLiquidacionCreateOrConnectWithoutLiquidacionInput | DetalleLiquidacionCreateOrConnectWithoutLiquidacionInput[]
    upsert?: DetalleLiquidacionUpsertWithWhereUniqueWithoutLiquidacionInput | DetalleLiquidacionUpsertWithWhereUniqueWithoutLiquidacionInput[]
    createMany?: DetalleLiquidacionCreateManyLiquidacionInputEnvelope
    set?: DetalleLiquidacionWhereUniqueInput | DetalleLiquidacionWhereUniqueInput[]
    disconnect?: DetalleLiquidacionWhereUniqueInput | DetalleLiquidacionWhereUniqueInput[]
    delete?: DetalleLiquidacionWhereUniqueInput | DetalleLiquidacionWhereUniqueInput[]
    connect?: DetalleLiquidacionWhereUniqueInput | DetalleLiquidacionWhereUniqueInput[]
    update?: DetalleLiquidacionUpdateWithWhereUniqueWithoutLiquidacionInput | DetalleLiquidacionUpdateWithWhereUniqueWithoutLiquidacionInput[]
    updateMany?: DetalleLiquidacionUpdateManyWithWhereWithoutLiquidacionInput | DetalleLiquidacionUpdateManyWithWhereWithoutLiquidacionInput[]
    deleteMany?: DetalleLiquidacionScalarWhereInput | DetalleLiquidacionScalarWhereInput[]
  }

  export type DetalleLiquidacionUncheckedUpdateManyWithoutLiquidacionNestedInput = {
    create?: XOR<DetalleLiquidacionCreateWithoutLiquidacionInput, DetalleLiquidacionUncheckedCreateWithoutLiquidacionInput> | DetalleLiquidacionCreateWithoutLiquidacionInput[] | DetalleLiquidacionUncheckedCreateWithoutLiquidacionInput[]
    connectOrCreate?: DetalleLiquidacionCreateOrConnectWithoutLiquidacionInput | DetalleLiquidacionCreateOrConnectWithoutLiquidacionInput[]
    upsert?: DetalleLiquidacionUpsertWithWhereUniqueWithoutLiquidacionInput | DetalleLiquidacionUpsertWithWhereUniqueWithoutLiquidacionInput[]
    createMany?: DetalleLiquidacionCreateManyLiquidacionInputEnvelope
    set?: DetalleLiquidacionWhereUniqueInput | DetalleLiquidacionWhereUniqueInput[]
    disconnect?: DetalleLiquidacionWhereUniqueInput | DetalleLiquidacionWhereUniqueInput[]
    delete?: DetalleLiquidacionWhereUniqueInput | DetalleLiquidacionWhereUniqueInput[]
    connect?: DetalleLiquidacionWhereUniqueInput | DetalleLiquidacionWhereUniqueInput[]
    update?: DetalleLiquidacionUpdateWithWhereUniqueWithoutLiquidacionInput | DetalleLiquidacionUpdateWithWhereUniqueWithoutLiquidacionInput[]
    updateMany?: DetalleLiquidacionUpdateManyWithWhereWithoutLiquidacionInput | DetalleLiquidacionUpdateManyWithWhereWithoutLiquidacionInput[]
    deleteMany?: DetalleLiquidacionScalarWhereInput | DetalleLiquidacionScalarWhereInput[]
  }

  export type LiquidacionCreateNestedOneWithoutDetallesInput = {
    create?: XOR<LiquidacionCreateWithoutDetallesInput, LiquidacionUncheckedCreateWithoutDetallesInput>
    connectOrCreate?: LiquidacionCreateOrConnectWithoutDetallesInput
    connect?: LiquidacionWhereUniqueInput
  }

  export type ReciboCreateNestedOneWithoutDetallesLiquidacionInput = {
    create?: XOR<ReciboCreateWithoutDetallesLiquidacionInput, ReciboUncheckedCreateWithoutDetallesLiquidacionInput>
    connectOrCreate?: ReciboCreateOrConnectWithoutDetallesLiquidacionInput
    connect?: ReciboWhereUniqueInput
  }

  export type LiquidacionUpdateOneRequiredWithoutDetallesNestedInput = {
    create?: XOR<LiquidacionCreateWithoutDetallesInput, LiquidacionUncheckedCreateWithoutDetallesInput>
    connectOrCreate?: LiquidacionCreateOrConnectWithoutDetallesInput
    upsert?: LiquidacionUpsertWithoutDetallesInput
    connect?: LiquidacionWhereUniqueInput
    update?: XOR<XOR<LiquidacionUpdateToOneWithWhereWithoutDetallesInput, LiquidacionUpdateWithoutDetallesInput>, LiquidacionUncheckedUpdateWithoutDetallesInput>
  }

  export type ReciboUpdateOneWithoutDetallesLiquidacionNestedInput = {
    create?: XOR<ReciboCreateWithoutDetallesLiquidacionInput, ReciboUncheckedCreateWithoutDetallesLiquidacionInput>
    connectOrCreate?: ReciboCreateOrConnectWithoutDetallesLiquidacionInput
    upsert?: ReciboUpsertWithoutDetallesLiquidacionInput
    disconnect?: ReciboWhereInput | boolean
    delete?: ReciboWhereInput | boolean
    connect?: ReciboWhereUniqueInput
    update?: XOR<XOR<ReciboUpdateToOneWithWhereWithoutDetallesLiquidacionInput, ReciboUpdateWithoutDetallesLiquidacionInput>, ReciboUncheckedUpdateWithoutDetallesLiquidacionInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTipoPagoFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoPago | EnumTipoPagoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoPago[] | ListEnumTipoPagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoPago[] | ListEnumTipoPagoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoPagoFilter<$PrismaModel> | $Enums.TipoPago
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumTipoPagoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoPago | EnumTipoPagoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoPago[] | ListEnumTipoPagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoPago[] | ListEnumTipoPagoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoPagoWithAggregatesFilter<$PrismaModel> | $Enums.TipoPago
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoPagoFilter<$PrismaModel>
    _max?: NestedEnumTipoPagoFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumEstadoLiquidacionFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoLiquidacion | EnumEstadoLiquidacionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoLiquidacion[] | ListEnumEstadoLiquidacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoLiquidacion[] | ListEnumEstadoLiquidacionFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoLiquidacionFilter<$PrismaModel> | $Enums.EstadoLiquidacion
  }

  export type NestedEnumTipoPagoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoPago | EnumTipoPagoFieldRefInput<$PrismaModel> | null
    in?: $Enums.TipoPago[] | ListEnumTipoPagoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TipoPago[] | ListEnumTipoPagoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTipoPagoNullableFilter<$PrismaModel> | $Enums.TipoPago | null
  }

  export type NestedEnumEstadoLiquidacionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoLiquidacion | EnumEstadoLiquidacionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoLiquidacion[] | ListEnumEstadoLiquidacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoLiquidacion[] | ListEnumEstadoLiquidacionFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoLiquidacionWithAggregatesFilter<$PrismaModel> | $Enums.EstadoLiquidacion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoLiquidacionFilter<$PrismaModel>
    _max?: NestedEnumEstadoLiquidacionFilter<$PrismaModel>
  }

  export type NestedEnumTipoPagoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoPago | EnumTipoPagoFieldRefInput<$PrismaModel> | null
    in?: $Enums.TipoPago[] | ListEnumTipoPagoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TipoPago[] | ListEnumTipoPagoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTipoPagoNullableWithAggregatesFilter<$PrismaModel> | $Enums.TipoPago | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTipoPagoNullableFilter<$PrismaModel>
    _max?: NestedEnumTipoPagoNullableFilter<$PrismaModel>
  }

  export type ReciboCreateWithoutAlumnoInput = {
    numeroRecibo?: number
    fecha?: Date | string
    fechaEfecto?: Date | string
    monto: number
    montoOriginal: number
    descuento?: number | null
    periodoPago: string
    tipoPago: $Enums.TipoPago
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    anulado?: boolean
    motivoAnulacion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alumnoSuelto?: AlumnoSueltoCreateNestedOneWithoutRecibosInput
    concepto: ConceptoCreateNestedOneWithoutRecibosInput
    pagosDeuda?: PagoDeudaCreateNestedManyWithoutReciboInput
    detallesLiquidacion?: DetalleLiquidacionCreateNestedManyWithoutReciboInput
    clase?: ClaseCreateNestedOneWithoutRecibosInput
    reciboAnulado?: ReciboCreateNestedOneWithoutRecibosAnuladosInput
    recibosAnulados?: ReciboCreateNestedManyWithoutReciboAnuladoInput
  }

  export type ReciboUncheckedCreateWithoutAlumnoInput = {
    id?: number
    numeroRecibo?: number
    fecha?: Date | string
    fechaEfecto?: Date | string
    monto: number
    montoOriginal: number
    descuento?: number | null
    periodoPago: string
    tipoPago: $Enums.TipoPago
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    alumnoSueltoId?: number | null
    conceptoId: number
    claseId?: number | null
    anulado?: boolean
    motivoAnulacion?: string | null
    referenciaRecibo?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pagosDeuda?: PagoDeudaUncheckedCreateNestedManyWithoutReciboInput
    detallesLiquidacion?: DetalleLiquidacionUncheckedCreateNestedManyWithoutReciboInput
    recibosAnulados?: ReciboUncheckedCreateNestedManyWithoutReciboAnuladoInput
  }

  export type ReciboCreateOrConnectWithoutAlumnoInput = {
    where: ReciboWhereUniqueInput
    create: XOR<ReciboCreateWithoutAlumnoInput, ReciboUncheckedCreateWithoutAlumnoInput>
  }

  export type ReciboCreateManyAlumnoInputEnvelope = {
    data: ReciboCreateManyAlumnoInput | ReciboCreateManyAlumnoInput[]
    skipDuplicates?: boolean
  }

  export type AlumnoSueltoCreateWithoutAlumnoRegularInput = {
    nombre: string
    apellido: string
    dni: string
    telefono?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recibos?: ReciboCreateNestedManyWithoutAlumnoSueltoInput
    clases?: ClaseCreateNestedManyWithoutAlumnosSueltosInput
  }

  export type AlumnoSueltoUncheckedCreateWithoutAlumnoRegularInput = {
    id?: number
    nombre: string
    apellido: string
    dni: string
    telefono?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recibos?: ReciboUncheckedCreateNestedManyWithoutAlumnoSueltoInput
    clases?: ClaseUncheckedCreateNestedManyWithoutAlumnosSueltosInput
  }

  export type AlumnoSueltoCreateOrConnectWithoutAlumnoRegularInput = {
    where: AlumnoSueltoWhereUniqueInput
    create: XOR<AlumnoSueltoCreateWithoutAlumnoRegularInput, AlumnoSueltoUncheckedCreateWithoutAlumnoRegularInput>
  }

  export type AlumnoSueltoCreateManyAlumnoRegularInputEnvelope = {
    data: AlumnoSueltoCreateManyAlumnoRegularInput | AlumnoSueltoCreateManyAlumnoRegularInput[]
    skipDuplicates?: boolean
  }

  export type CtaCteCreateWithoutAlumnoInput = {
    saldo: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CtaCteUncheckedCreateWithoutAlumnoInput = {
    id?: number
    saldo: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CtaCteCreateOrConnectWithoutAlumnoInput = {
    where: CtaCteWhereUniqueInput
    create: XOR<CtaCteCreateWithoutAlumnoInput, CtaCteUncheckedCreateWithoutAlumnoInput>
  }

  export type EstiloCreateWithoutAlumnosInput = {
    nombre: string
    monto?: number
    descripcion?: string | null
    importe?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deudas?: DeudaCreateNestedManyWithoutEstiloInput
    conceptos?: ConceptoCreateNestedManyWithoutEstiloInput
    clases?: ClaseCreateNestedManyWithoutEstiloInput
    alumnoEstilos?: AlumnoEstilosCreateNestedManyWithoutEstiloInput
    profesor?: ProfesorCreateNestedOneWithoutEstilosInput
  }

  export type EstiloUncheckedCreateWithoutAlumnosInput = {
    id?: number
    nombre: string
    monto?: number
    descripcion?: string | null
    importe?: number
    profesorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deudas?: DeudaUncheckedCreateNestedManyWithoutEstiloInput
    conceptos?: ConceptoUncheckedCreateNestedManyWithoutEstiloInput
    clases?: ClaseUncheckedCreateNestedManyWithoutEstiloInput
    alumnoEstilos?: AlumnoEstilosUncheckedCreateNestedManyWithoutEstiloInput
  }

  export type EstiloCreateOrConnectWithoutAlumnosInput = {
    where: EstiloWhereUniqueInput
    create: XOR<EstiloCreateWithoutAlumnosInput, EstiloUncheckedCreateWithoutAlumnosInput>
  }

  export type AsistenciaCreateWithoutAlumnoInput = {
    asistio: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clase: ClaseCreateNestedOneWithoutAsistenciasInput
  }

  export type AsistenciaUncheckedCreateWithoutAlumnoInput = {
    id?: number
    claseId: number
    asistio: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AsistenciaCreateOrConnectWithoutAlumnoInput = {
    where: AsistenciaWhereUniqueInput
    create: XOR<AsistenciaCreateWithoutAlumnoInput, AsistenciaUncheckedCreateWithoutAlumnoInput>
  }

  export type AsistenciaCreateManyAlumnoInputEnvelope = {
    data: AsistenciaCreateManyAlumnoInput | AsistenciaCreateManyAlumnoInput[]
    skipDuplicates?: boolean
  }

  export type AlumnoEstilosCreateWithoutAlumnoInput = {
    activo?: boolean
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    montoPersonalizado?: number | null
    descuentoPersonalizado?: number | null
    observaciones?: string | null
    estilo: EstiloCreateNestedOneWithoutAlumnoEstilosInput
  }

  export type AlumnoEstilosUncheckedCreateWithoutAlumnoInput = {
    id?: number
    estiloId: number
    activo?: boolean
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    montoPersonalizado?: number | null
    descuentoPersonalizado?: number | null
    observaciones?: string | null
  }

  export type AlumnoEstilosCreateOrConnectWithoutAlumnoInput = {
    where: AlumnoEstilosWhereUniqueInput
    create: XOR<AlumnoEstilosCreateWithoutAlumnoInput, AlumnoEstilosUncheckedCreateWithoutAlumnoInput>
  }

  export type AlumnoEstilosCreateManyAlumnoInputEnvelope = {
    data: AlumnoEstilosCreateManyAlumnoInput | AlumnoEstilosCreateManyAlumnoInput[]
    skipDuplicates?: boolean
  }

  export type DeudaCreateWithoutAlumnoInput = {
    monto: number
    montoOriginal: number
    mes: string
    anio: number
    pagada?: boolean
    fechaPago?: Date | string | null
    fechaVencimiento: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    estilo: EstiloCreateNestedOneWithoutDeudasInput
    pagos?: PagoDeudaCreateNestedManyWithoutDeudaInput
  }

  export type DeudaUncheckedCreateWithoutAlumnoInput = {
    id?: number
    monto: number
    montoOriginal: number
    mes: string
    anio: number
    estiloId: number
    pagada?: boolean
    fechaPago?: Date | string | null
    fechaVencimiento: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    pagos?: PagoDeudaUncheckedCreateNestedManyWithoutDeudaInput
  }

  export type DeudaCreateOrConnectWithoutAlumnoInput = {
    where: DeudaWhereUniqueInput
    create: XOR<DeudaCreateWithoutAlumnoInput, DeudaUncheckedCreateWithoutAlumnoInput>
  }

  export type DeudaCreateManyAlumnoInputEnvelope = {
    data: DeudaCreateManyAlumnoInput | DeudaCreateManyAlumnoInput[]
    skipDuplicates?: boolean
  }

  export type DescuentoAplicadoCreateWithoutAlumnoInput = {
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    descuento: DescuentoCreateNestedOneWithoutAplicadoAInput
  }

  export type DescuentoAplicadoUncheckedCreateWithoutAlumnoInput = {
    id?: number
    descuentoId: number
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DescuentoAplicadoCreateOrConnectWithoutAlumnoInput = {
    where: DescuentoAplicadoWhereUniqueInput
    create: XOR<DescuentoAplicadoCreateWithoutAlumnoInput, DescuentoAplicadoUncheckedCreateWithoutAlumnoInput>
  }

  export type DescuentoAplicadoCreateManyAlumnoInputEnvelope = {
    data: DescuentoAplicadoCreateManyAlumnoInput | DescuentoAplicadoCreateManyAlumnoInput[]
    skipDuplicates?: boolean
  }

  export type ConfiguracionPagoAlumnoCreateWithoutAlumnoInput = {
    diaPago?: number | null
    metodoPago?: $Enums.TipoPago
    descuentoFijo?: number | null
    observaciones?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfiguracionPagoAlumnoUncheckedCreateWithoutAlumnoInput = {
    id?: number
    diaPago?: number | null
    metodoPago?: $Enums.TipoPago
    descuentoFijo?: number | null
    observaciones?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfiguracionPagoAlumnoCreateOrConnectWithoutAlumnoInput = {
    where: ConfiguracionPagoAlumnoWhereUniqueInput
    create: XOR<ConfiguracionPagoAlumnoCreateWithoutAlumnoInput, ConfiguracionPagoAlumnoUncheckedCreateWithoutAlumnoInput>
  }

  export type ReciboUpsertWithWhereUniqueWithoutAlumnoInput = {
    where: ReciboWhereUniqueInput
    update: XOR<ReciboUpdateWithoutAlumnoInput, ReciboUncheckedUpdateWithoutAlumnoInput>
    create: XOR<ReciboCreateWithoutAlumnoInput, ReciboUncheckedCreateWithoutAlumnoInput>
  }

  export type ReciboUpdateWithWhereUniqueWithoutAlumnoInput = {
    where: ReciboWhereUniqueInput
    data: XOR<ReciboUpdateWithoutAlumnoInput, ReciboUncheckedUpdateWithoutAlumnoInput>
  }

  export type ReciboUpdateManyWithWhereWithoutAlumnoInput = {
    where: ReciboScalarWhereInput
    data: XOR<ReciboUpdateManyMutationInput, ReciboUncheckedUpdateManyWithoutAlumnoInput>
  }

  export type ReciboScalarWhereInput = {
    AND?: ReciboScalarWhereInput | ReciboScalarWhereInput[]
    OR?: ReciboScalarWhereInput[]
    NOT?: ReciboScalarWhereInput | ReciboScalarWhereInput[]
    id?: IntFilter<"Recibo"> | number
    numeroRecibo?: IntFilter<"Recibo"> | number
    fecha?: DateTimeFilter<"Recibo"> | Date | string
    fechaEfecto?: DateTimeFilter<"Recibo"> | Date | string
    monto?: FloatFilter<"Recibo"> | number
    montoOriginal?: FloatFilter<"Recibo"> | number
    descuento?: FloatNullableFilter<"Recibo"> | number | null
    periodoPago?: StringFilter<"Recibo"> | string
    tipoPago?: EnumTipoPagoFilter<"Recibo"> | $Enums.TipoPago
    fueraDeTermino?: BoolFilter<"Recibo"> | boolean
    esClaseSuelta?: BoolFilter<"Recibo"> | boolean
    esMesCompleto?: BoolFilter<"Recibo"> | boolean
    alumnoId?: IntNullableFilter<"Recibo"> | number | null
    alumnoSueltoId?: IntNullableFilter<"Recibo"> | number | null
    conceptoId?: IntFilter<"Recibo"> | number
    claseId?: IntNullableFilter<"Recibo"> | number | null
    anulado?: BoolFilter<"Recibo"> | boolean
    motivoAnulacion?: StringNullableFilter<"Recibo"> | string | null
    referenciaRecibo?: IntNullableFilter<"Recibo"> | number | null
    createdAt?: DateTimeFilter<"Recibo"> | Date | string
    updatedAt?: DateTimeFilter<"Recibo"> | Date | string
  }

  export type AlumnoSueltoUpsertWithWhereUniqueWithoutAlumnoRegularInput = {
    where: AlumnoSueltoWhereUniqueInput
    update: XOR<AlumnoSueltoUpdateWithoutAlumnoRegularInput, AlumnoSueltoUncheckedUpdateWithoutAlumnoRegularInput>
    create: XOR<AlumnoSueltoCreateWithoutAlumnoRegularInput, AlumnoSueltoUncheckedCreateWithoutAlumnoRegularInput>
  }

  export type AlumnoSueltoUpdateWithWhereUniqueWithoutAlumnoRegularInput = {
    where: AlumnoSueltoWhereUniqueInput
    data: XOR<AlumnoSueltoUpdateWithoutAlumnoRegularInput, AlumnoSueltoUncheckedUpdateWithoutAlumnoRegularInput>
  }

  export type AlumnoSueltoUpdateManyWithWhereWithoutAlumnoRegularInput = {
    where: AlumnoSueltoScalarWhereInput
    data: XOR<AlumnoSueltoUpdateManyMutationInput, AlumnoSueltoUncheckedUpdateManyWithoutAlumnoRegularInput>
  }

  export type AlumnoSueltoScalarWhereInput = {
    AND?: AlumnoSueltoScalarWhereInput | AlumnoSueltoScalarWhereInput[]
    OR?: AlumnoSueltoScalarWhereInput[]
    NOT?: AlumnoSueltoScalarWhereInput | AlumnoSueltoScalarWhereInput[]
    id?: IntFilter<"AlumnoSuelto"> | number
    nombre?: StringFilter<"AlumnoSuelto"> | string
    apellido?: StringFilter<"AlumnoSuelto"> | string
    dni?: StringFilter<"AlumnoSuelto"> | string
    telefono?: StringNullableFilter<"AlumnoSuelto"> | string | null
    email?: StringNullableFilter<"AlumnoSuelto"> | string | null
    alumnoRegularId?: IntNullableFilter<"AlumnoSuelto"> | number | null
    createdAt?: DateTimeFilter<"AlumnoSuelto"> | Date | string
    updatedAt?: DateTimeFilter<"AlumnoSuelto"> | Date | string
  }

  export type CtaCteUpsertWithoutAlumnoInput = {
    update: XOR<CtaCteUpdateWithoutAlumnoInput, CtaCteUncheckedUpdateWithoutAlumnoInput>
    create: XOR<CtaCteCreateWithoutAlumnoInput, CtaCteUncheckedCreateWithoutAlumnoInput>
    where?: CtaCteWhereInput
  }

  export type CtaCteUpdateToOneWithWhereWithoutAlumnoInput = {
    where?: CtaCteWhereInput
    data: XOR<CtaCteUpdateWithoutAlumnoInput, CtaCteUncheckedUpdateWithoutAlumnoInput>
  }

  export type CtaCteUpdateWithoutAlumnoInput = {
    saldo?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CtaCteUncheckedUpdateWithoutAlumnoInput = {
    id?: IntFieldUpdateOperationsInput | number
    saldo?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EstiloUpsertWithWhereUniqueWithoutAlumnosInput = {
    where: EstiloWhereUniqueInput
    update: XOR<EstiloUpdateWithoutAlumnosInput, EstiloUncheckedUpdateWithoutAlumnosInput>
    create: XOR<EstiloCreateWithoutAlumnosInput, EstiloUncheckedCreateWithoutAlumnosInput>
  }

  export type EstiloUpdateWithWhereUniqueWithoutAlumnosInput = {
    where: EstiloWhereUniqueInput
    data: XOR<EstiloUpdateWithoutAlumnosInput, EstiloUncheckedUpdateWithoutAlumnosInput>
  }

  export type EstiloUpdateManyWithWhereWithoutAlumnosInput = {
    where: EstiloScalarWhereInput
    data: XOR<EstiloUpdateManyMutationInput, EstiloUncheckedUpdateManyWithoutAlumnosInput>
  }

  export type EstiloScalarWhereInput = {
    AND?: EstiloScalarWhereInput | EstiloScalarWhereInput[]
    OR?: EstiloScalarWhereInput[]
    NOT?: EstiloScalarWhereInput | EstiloScalarWhereInput[]
    id?: IntFilter<"Estilo"> | number
    nombre?: StringFilter<"Estilo"> | string
    monto?: FloatFilter<"Estilo"> | number
    descripcion?: StringNullableFilter<"Estilo"> | string | null
    importe?: FloatFilter<"Estilo"> | number
    profesorId?: IntNullableFilter<"Estilo"> | number | null
    createdAt?: DateTimeFilter<"Estilo"> | Date | string
    updatedAt?: DateTimeFilter<"Estilo"> | Date | string
  }

  export type AsistenciaUpsertWithWhereUniqueWithoutAlumnoInput = {
    where: AsistenciaWhereUniqueInput
    update: XOR<AsistenciaUpdateWithoutAlumnoInput, AsistenciaUncheckedUpdateWithoutAlumnoInput>
    create: XOR<AsistenciaCreateWithoutAlumnoInput, AsistenciaUncheckedCreateWithoutAlumnoInput>
  }

  export type AsistenciaUpdateWithWhereUniqueWithoutAlumnoInput = {
    where: AsistenciaWhereUniqueInput
    data: XOR<AsistenciaUpdateWithoutAlumnoInput, AsistenciaUncheckedUpdateWithoutAlumnoInput>
  }

  export type AsistenciaUpdateManyWithWhereWithoutAlumnoInput = {
    where: AsistenciaScalarWhereInput
    data: XOR<AsistenciaUpdateManyMutationInput, AsistenciaUncheckedUpdateManyWithoutAlumnoInput>
  }

  export type AsistenciaScalarWhereInput = {
    AND?: AsistenciaScalarWhereInput | AsistenciaScalarWhereInput[]
    OR?: AsistenciaScalarWhereInput[]
    NOT?: AsistenciaScalarWhereInput | AsistenciaScalarWhereInput[]
    id?: IntFilter<"Asistencia"> | number
    claseId?: IntFilter<"Asistencia"> | number
    alumnoId?: IntFilter<"Asistencia"> | number
    asistio?: BoolFilter<"Asistencia"> | boolean
    createdAt?: DateTimeFilter<"Asistencia"> | Date | string
    updatedAt?: DateTimeFilter<"Asistencia"> | Date | string
  }

  export type AlumnoEstilosUpsertWithWhereUniqueWithoutAlumnoInput = {
    where: AlumnoEstilosWhereUniqueInput
    update: XOR<AlumnoEstilosUpdateWithoutAlumnoInput, AlumnoEstilosUncheckedUpdateWithoutAlumnoInput>
    create: XOR<AlumnoEstilosCreateWithoutAlumnoInput, AlumnoEstilosUncheckedCreateWithoutAlumnoInput>
  }

  export type AlumnoEstilosUpdateWithWhereUniqueWithoutAlumnoInput = {
    where: AlumnoEstilosWhereUniqueInput
    data: XOR<AlumnoEstilosUpdateWithoutAlumnoInput, AlumnoEstilosUncheckedUpdateWithoutAlumnoInput>
  }

  export type AlumnoEstilosUpdateManyWithWhereWithoutAlumnoInput = {
    where: AlumnoEstilosScalarWhereInput
    data: XOR<AlumnoEstilosUpdateManyMutationInput, AlumnoEstilosUncheckedUpdateManyWithoutAlumnoInput>
  }

  export type AlumnoEstilosScalarWhereInput = {
    AND?: AlumnoEstilosScalarWhereInput | AlumnoEstilosScalarWhereInput[]
    OR?: AlumnoEstilosScalarWhereInput[]
    NOT?: AlumnoEstilosScalarWhereInput | AlumnoEstilosScalarWhereInput[]
    id?: IntFilter<"AlumnoEstilos"> | number
    alumnoId?: IntFilter<"AlumnoEstilos"> | number
    estiloId?: IntFilter<"AlumnoEstilos"> | number
    activo?: BoolFilter<"AlumnoEstilos"> | boolean
    fechaInicio?: DateTimeFilter<"AlumnoEstilos"> | Date | string
    fechaFin?: DateTimeNullableFilter<"AlumnoEstilos"> | Date | string | null
    montoPersonalizado?: FloatNullableFilter<"AlumnoEstilos"> | number | null
    descuentoPersonalizado?: FloatNullableFilter<"AlumnoEstilos"> | number | null
    observaciones?: StringNullableFilter<"AlumnoEstilos"> | string | null
  }

  export type DeudaUpsertWithWhereUniqueWithoutAlumnoInput = {
    where: DeudaWhereUniqueInput
    update: XOR<DeudaUpdateWithoutAlumnoInput, DeudaUncheckedUpdateWithoutAlumnoInput>
    create: XOR<DeudaCreateWithoutAlumnoInput, DeudaUncheckedCreateWithoutAlumnoInput>
  }

  export type DeudaUpdateWithWhereUniqueWithoutAlumnoInput = {
    where: DeudaWhereUniqueInput
    data: XOR<DeudaUpdateWithoutAlumnoInput, DeudaUncheckedUpdateWithoutAlumnoInput>
  }

  export type DeudaUpdateManyWithWhereWithoutAlumnoInput = {
    where: DeudaScalarWhereInput
    data: XOR<DeudaUpdateManyMutationInput, DeudaUncheckedUpdateManyWithoutAlumnoInput>
  }

  export type DeudaScalarWhereInput = {
    AND?: DeudaScalarWhereInput | DeudaScalarWhereInput[]
    OR?: DeudaScalarWhereInput[]
    NOT?: DeudaScalarWhereInput | DeudaScalarWhereInput[]
    id?: IntFilter<"Deuda"> | number
    alumnoId?: IntFilter<"Deuda"> | number
    monto?: FloatFilter<"Deuda"> | number
    montoOriginal?: FloatFilter<"Deuda"> | number
    mes?: StringFilter<"Deuda"> | string
    anio?: IntFilter<"Deuda"> | number
    estiloId?: IntFilter<"Deuda"> | number
    pagada?: BoolFilter<"Deuda"> | boolean
    fechaPago?: DateTimeNullableFilter<"Deuda"> | Date | string | null
    fechaVencimiento?: DateTimeFilter<"Deuda"> | Date | string
    createdAt?: DateTimeFilter<"Deuda"> | Date | string
    updatedAt?: DateTimeFilter<"Deuda"> | Date | string
  }

  export type DescuentoAplicadoUpsertWithWhereUniqueWithoutAlumnoInput = {
    where: DescuentoAplicadoWhereUniqueInput
    update: XOR<DescuentoAplicadoUpdateWithoutAlumnoInput, DescuentoAplicadoUncheckedUpdateWithoutAlumnoInput>
    create: XOR<DescuentoAplicadoCreateWithoutAlumnoInput, DescuentoAplicadoUncheckedCreateWithoutAlumnoInput>
  }

  export type DescuentoAplicadoUpdateWithWhereUniqueWithoutAlumnoInput = {
    where: DescuentoAplicadoWhereUniqueInput
    data: XOR<DescuentoAplicadoUpdateWithoutAlumnoInput, DescuentoAplicadoUncheckedUpdateWithoutAlumnoInput>
  }

  export type DescuentoAplicadoUpdateManyWithWhereWithoutAlumnoInput = {
    where: DescuentoAplicadoScalarWhereInput
    data: XOR<DescuentoAplicadoUpdateManyMutationInput, DescuentoAplicadoUncheckedUpdateManyWithoutAlumnoInput>
  }

  export type DescuentoAplicadoScalarWhereInput = {
    AND?: DescuentoAplicadoScalarWhereInput | DescuentoAplicadoScalarWhereInput[]
    OR?: DescuentoAplicadoScalarWhereInput[]
    NOT?: DescuentoAplicadoScalarWhereInput | DescuentoAplicadoScalarWhereInput[]
    id?: IntFilter<"DescuentoAplicado"> | number
    descuentoId?: IntFilter<"DescuentoAplicado"> | number
    alumnoId?: IntFilter<"DescuentoAplicado"> | number
    fechaInicio?: DateTimeFilter<"DescuentoAplicado"> | Date | string
    fechaFin?: DateTimeNullableFilter<"DescuentoAplicado"> | Date | string | null
    activo?: BoolFilter<"DescuentoAplicado"> | boolean
    createdAt?: DateTimeFilter<"DescuentoAplicado"> | Date | string
    updatedAt?: DateTimeFilter<"DescuentoAplicado"> | Date | string
  }

  export type ConfiguracionPagoAlumnoUpsertWithoutAlumnoInput = {
    update: XOR<ConfiguracionPagoAlumnoUpdateWithoutAlumnoInput, ConfiguracionPagoAlumnoUncheckedUpdateWithoutAlumnoInput>
    create: XOR<ConfiguracionPagoAlumnoCreateWithoutAlumnoInput, ConfiguracionPagoAlumnoUncheckedCreateWithoutAlumnoInput>
    where?: ConfiguracionPagoAlumnoWhereInput
  }

  export type ConfiguracionPagoAlumnoUpdateToOneWithWhereWithoutAlumnoInput = {
    where?: ConfiguracionPagoAlumnoWhereInput
    data: XOR<ConfiguracionPagoAlumnoUpdateWithoutAlumnoInput, ConfiguracionPagoAlumnoUncheckedUpdateWithoutAlumnoInput>
  }

  export type ConfiguracionPagoAlumnoUpdateWithoutAlumnoInput = {
    diaPago?: NullableIntFieldUpdateOperationsInput | number | null
    metodoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    descuentoFijo?: NullableFloatFieldUpdateOperationsInput | number | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfiguracionPagoAlumnoUncheckedUpdateWithoutAlumnoInput = {
    id?: IntFieldUpdateOperationsInput | number
    diaPago?: NullableIntFieldUpdateOperationsInput | number | null
    metodoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    descuentoFijo?: NullableFloatFieldUpdateOperationsInput | number | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlumnoCreateWithoutConfiguracionPagoInput = {
    nombre: string
    apellido: string
    dni: string
    activo?: boolean
    fechaNacimiento: Date | string
    email?: string | null
    telefono?: string | null
    numeroEmergencia?: string | null
    direccion?: string | null
    obraSocial?: string | null
    nombreTutor?: string | null
    dniTutor?: string | null
    notas?: string | null
    fechaIngreso?: Date | string
    fechaBaja?: Date | string | null
    motivoBaja?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recibos?: ReciboCreateNestedManyWithoutAlumnoInput
    alumnosSueltosAnteriores?: AlumnoSueltoCreateNestedManyWithoutAlumnoRegularInput
    ctaCte?: CtaCteCreateNestedOneWithoutAlumnoInput
    estilos?: EstiloCreateNestedManyWithoutAlumnosInput
    asistencias?: AsistenciaCreateNestedManyWithoutAlumnoInput
    alumnoEstilos?: AlumnoEstilosCreateNestedManyWithoutAlumnoInput
    deudas?: DeudaCreateNestedManyWithoutAlumnoInput
    descuentosVigentes?: DescuentoAplicadoCreateNestedManyWithoutAlumnoInput
  }

  export type AlumnoUncheckedCreateWithoutConfiguracionPagoInput = {
    id?: number
    nombre: string
    apellido: string
    dni: string
    activo?: boolean
    fechaNacimiento: Date | string
    email?: string | null
    telefono?: string | null
    numeroEmergencia?: string | null
    direccion?: string | null
    obraSocial?: string | null
    nombreTutor?: string | null
    dniTutor?: string | null
    notas?: string | null
    fechaIngreso?: Date | string
    fechaBaja?: Date | string | null
    motivoBaja?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recibos?: ReciboUncheckedCreateNestedManyWithoutAlumnoInput
    alumnosSueltosAnteriores?: AlumnoSueltoUncheckedCreateNestedManyWithoutAlumnoRegularInput
    ctaCte?: CtaCteUncheckedCreateNestedOneWithoutAlumnoInput
    estilos?: EstiloUncheckedCreateNestedManyWithoutAlumnosInput
    asistencias?: AsistenciaUncheckedCreateNestedManyWithoutAlumnoInput
    alumnoEstilos?: AlumnoEstilosUncheckedCreateNestedManyWithoutAlumnoInput
    deudas?: DeudaUncheckedCreateNestedManyWithoutAlumnoInput
    descuentosVigentes?: DescuentoAplicadoUncheckedCreateNestedManyWithoutAlumnoInput
  }

  export type AlumnoCreateOrConnectWithoutConfiguracionPagoInput = {
    where: AlumnoWhereUniqueInput
    create: XOR<AlumnoCreateWithoutConfiguracionPagoInput, AlumnoUncheckedCreateWithoutConfiguracionPagoInput>
  }

  export type AlumnoUpsertWithoutConfiguracionPagoInput = {
    update: XOR<AlumnoUpdateWithoutConfiguracionPagoInput, AlumnoUncheckedUpdateWithoutConfiguracionPagoInput>
    create: XOR<AlumnoCreateWithoutConfiguracionPagoInput, AlumnoUncheckedCreateWithoutConfiguracionPagoInput>
    where?: AlumnoWhereInput
  }

  export type AlumnoUpdateToOneWithWhereWithoutConfiguracionPagoInput = {
    where?: AlumnoWhereInput
    data: XOR<AlumnoUpdateWithoutConfiguracionPagoInput, AlumnoUncheckedUpdateWithoutConfiguracionPagoInput>
  }

  export type AlumnoUpdateWithoutConfiguracionPagoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    numeroEmergencia?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    obraSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nombreTutor?: NullableStringFieldUpdateOperationsInput | string | null
    dniTutor?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoBaja?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibos?: ReciboUpdateManyWithoutAlumnoNestedInput
    alumnosSueltosAnteriores?: AlumnoSueltoUpdateManyWithoutAlumnoRegularNestedInput
    ctaCte?: CtaCteUpdateOneWithoutAlumnoNestedInput
    estilos?: EstiloUpdateManyWithoutAlumnosNestedInput
    asistencias?: AsistenciaUpdateManyWithoutAlumnoNestedInput
    alumnoEstilos?: AlumnoEstilosUpdateManyWithoutAlumnoNestedInput
    deudas?: DeudaUpdateManyWithoutAlumnoNestedInput
    descuentosVigentes?: DescuentoAplicadoUpdateManyWithoutAlumnoNestedInput
  }

  export type AlumnoUncheckedUpdateWithoutConfiguracionPagoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    numeroEmergencia?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    obraSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nombreTutor?: NullableStringFieldUpdateOperationsInput | string | null
    dniTutor?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoBaja?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibos?: ReciboUncheckedUpdateManyWithoutAlumnoNestedInput
    alumnosSueltosAnteriores?: AlumnoSueltoUncheckedUpdateManyWithoutAlumnoRegularNestedInput
    ctaCte?: CtaCteUncheckedUpdateOneWithoutAlumnoNestedInput
    estilos?: EstiloUncheckedUpdateManyWithoutAlumnosNestedInput
    asistencias?: AsistenciaUncheckedUpdateManyWithoutAlumnoNestedInput
    alumnoEstilos?: AlumnoEstilosUncheckedUpdateManyWithoutAlumnoNestedInput
    deudas?: DeudaUncheckedUpdateManyWithoutAlumnoNestedInput
    descuentosVigentes?: DescuentoAplicadoUncheckedUpdateManyWithoutAlumnoNestedInput
  }

  export type DescuentoAplicadoCreateWithoutDescuentoInput = {
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    alumno: AlumnoCreateNestedOneWithoutDescuentosVigentesInput
  }

  export type DescuentoAplicadoUncheckedCreateWithoutDescuentoInput = {
    id?: number
    alumnoId: number
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DescuentoAplicadoCreateOrConnectWithoutDescuentoInput = {
    where: DescuentoAplicadoWhereUniqueInput
    create: XOR<DescuentoAplicadoCreateWithoutDescuentoInput, DescuentoAplicadoUncheckedCreateWithoutDescuentoInput>
  }

  export type DescuentoAplicadoCreateManyDescuentoInputEnvelope = {
    data: DescuentoAplicadoCreateManyDescuentoInput | DescuentoAplicadoCreateManyDescuentoInput[]
    skipDuplicates?: boolean
  }

  export type DescuentoAplicadoUpsertWithWhereUniqueWithoutDescuentoInput = {
    where: DescuentoAplicadoWhereUniqueInput
    update: XOR<DescuentoAplicadoUpdateWithoutDescuentoInput, DescuentoAplicadoUncheckedUpdateWithoutDescuentoInput>
    create: XOR<DescuentoAplicadoCreateWithoutDescuentoInput, DescuentoAplicadoUncheckedCreateWithoutDescuentoInput>
  }

  export type DescuentoAplicadoUpdateWithWhereUniqueWithoutDescuentoInput = {
    where: DescuentoAplicadoWhereUniqueInput
    data: XOR<DescuentoAplicadoUpdateWithoutDescuentoInput, DescuentoAplicadoUncheckedUpdateWithoutDescuentoInput>
  }

  export type DescuentoAplicadoUpdateManyWithWhereWithoutDescuentoInput = {
    where: DescuentoAplicadoScalarWhereInput
    data: XOR<DescuentoAplicadoUpdateManyMutationInput, DescuentoAplicadoUncheckedUpdateManyWithoutDescuentoInput>
  }

  export type DescuentoCreateWithoutAplicadoAInput = {
    nombre: string
    porcentaje: number
    activo?: boolean
    esAutomatico?: boolean
    minEstilos?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DescuentoUncheckedCreateWithoutAplicadoAInput = {
    id?: number
    nombre: string
    porcentaje: number
    activo?: boolean
    esAutomatico?: boolean
    minEstilos?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DescuentoCreateOrConnectWithoutAplicadoAInput = {
    where: DescuentoWhereUniqueInput
    create: XOR<DescuentoCreateWithoutAplicadoAInput, DescuentoUncheckedCreateWithoutAplicadoAInput>
  }

  export type AlumnoCreateWithoutDescuentosVigentesInput = {
    nombre: string
    apellido: string
    dni: string
    activo?: boolean
    fechaNacimiento: Date | string
    email?: string | null
    telefono?: string | null
    numeroEmergencia?: string | null
    direccion?: string | null
    obraSocial?: string | null
    nombreTutor?: string | null
    dniTutor?: string | null
    notas?: string | null
    fechaIngreso?: Date | string
    fechaBaja?: Date | string | null
    motivoBaja?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recibos?: ReciboCreateNestedManyWithoutAlumnoInput
    alumnosSueltosAnteriores?: AlumnoSueltoCreateNestedManyWithoutAlumnoRegularInput
    ctaCte?: CtaCteCreateNestedOneWithoutAlumnoInput
    estilos?: EstiloCreateNestedManyWithoutAlumnosInput
    asistencias?: AsistenciaCreateNestedManyWithoutAlumnoInput
    alumnoEstilos?: AlumnoEstilosCreateNestedManyWithoutAlumnoInput
    deudas?: DeudaCreateNestedManyWithoutAlumnoInput
    configuracionPago?: ConfiguracionPagoAlumnoCreateNestedOneWithoutAlumnoInput
  }

  export type AlumnoUncheckedCreateWithoutDescuentosVigentesInput = {
    id?: number
    nombre: string
    apellido: string
    dni: string
    activo?: boolean
    fechaNacimiento: Date | string
    email?: string | null
    telefono?: string | null
    numeroEmergencia?: string | null
    direccion?: string | null
    obraSocial?: string | null
    nombreTutor?: string | null
    dniTutor?: string | null
    notas?: string | null
    fechaIngreso?: Date | string
    fechaBaja?: Date | string | null
    motivoBaja?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recibos?: ReciboUncheckedCreateNestedManyWithoutAlumnoInput
    alumnosSueltosAnteriores?: AlumnoSueltoUncheckedCreateNestedManyWithoutAlumnoRegularInput
    ctaCte?: CtaCteUncheckedCreateNestedOneWithoutAlumnoInput
    estilos?: EstiloUncheckedCreateNestedManyWithoutAlumnosInput
    asistencias?: AsistenciaUncheckedCreateNestedManyWithoutAlumnoInput
    alumnoEstilos?: AlumnoEstilosUncheckedCreateNestedManyWithoutAlumnoInput
    deudas?: DeudaUncheckedCreateNestedManyWithoutAlumnoInput
    configuracionPago?: ConfiguracionPagoAlumnoUncheckedCreateNestedOneWithoutAlumnoInput
  }

  export type AlumnoCreateOrConnectWithoutDescuentosVigentesInput = {
    where: AlumnoWhereUniqueInput
    create: XOR<AlumnoCreateWithoutDescuentosVigentesInput, AlumnoUncheckedCreateWithoutDescuentosVigentesInput>
  }

  export type DescuentoUpsertWithoutAplicadoAInput = {
    update: XOR<DescuentoUpdateWithoutAplicadoAInput, DescuentoUncheckedUpdateWithoutAplicadoAInput>
    create: XOR<DescuentoCreateWithoutAplicadoAInput, DescuentoUncheckedCreateWithoutAplicadoAInput>
    where?: DescuentoWhereInput
  }

  export type DescuentoUpdateToOneWithWhereWithoutAplicadoAInput = {
    where?: DescuentoWhereInput
    data: XOR<DescuentoUpdateWithoutAplicadoAInput, DescuentoUncheckedUpdateWithoutAplicadoAInput>
  }

  export type DescuentoUpdateWithoutAplicadoAInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    porcentaje?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    esAutomatico?: BoolFieldUpdateOperationsInput | boolean
    minEstilos?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DescuentoUncheckedUpdateWithoutAplicadoAInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    porcentaje?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    esAutomatico?: BoolFieldUpdateOperationsInput | boolean
    minEstilos?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlumnoUpsertWithoutDescuentosVigentesInput = {
    update: XOR<AlumnoUpdateWithoutDescuentosVigentesInput, AlumnoUncheckedUpdateWithoutDescuentosVigentesInput>
    create: XOR<AlumnoCreateWithoutDescuentosVigentesInput, AlumnoUncheckedCreateWithoutDescuentosVigentesInput>
    where?: AlumnoWhereInput
  }

  export type AlumnoUpdateToOneWithWhereWithoutDescuentosVigentesInput = {
    where?: AlumnoWhereInput
    data: XOR<AlumnoUpdateWithoutDescuentosVigentesInput, AlumnoUncheckedUpdateWithoutDescuentosVigentesInput>
  }

  export type AlumnoUpdateWithoutDescuentosVigentesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    numeroEmergencia?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    obraSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nombreTutor?: NullableStringFieldUpdateOperationsInput | string | null
    dniTutor?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoBaja?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibos?: ReciboUpdateManyWithoutAlumnoNestedInput
    alumnosSueltosAnteriores?: AlumnoSueltoUpdateManyWithoutAlumnoRegularNestedInput
    ctaCte?: CtaCteUpdateOneWithoutAlumnoNestedInput
    estilos?: EstiloUpdateManyWithoutAlumnosNestedInput
    asistencias?: AsistenciaUpdateManyWithoutAlumnoNestedInput
    alumnoEstilos?: AlumnoEstilosUpdateManyWithoutAlumnoNestedInput
    deudas?: DeudaUpdateManyWithoutAlumnoNestedInput
    configuracionPago?: ConfiguracionPagoAlumnoUpdateOneWithoutAlumnoNestedInput
  }

  export type AlumnoUncheckedUpdateWithoutDescuentosVigentesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    numeroEmergencia?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    obraSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nombreTutor?: NullableStringFieldUpdateOperationsInput | string | null
    dniTutor?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoBaja?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibos?: ReciboUncheckedUpdateManyWithoutAlumnoNestedInput
    alumnosSueltosAnteriores?: AlumnoSueltoUncheckedUpdateManyWithoutAlumnoRegularNestedInput
    ctaCte?: CtaCteUncheckedUpdateOneWithoutAlumnoNestedInput
    estilos?: EstiloUncheckedUpdateManyWithoutAlumnosNestedInput
    asistencias?: AsistenciaUncheckedUpdateManyWithoutAlumnoNestedInput
    alumnoEstilos?: AlumnoEstilosUncheckedUpdateManyWithoutAlumnoNestedInput
    deudas?: DeudaUncheckedUpdateManyWithoutAlumnoNestedInput
    configuracionPago?: ConfiguracionPagoAlumnoUncheckedUpdateOneWithoutAlumnoNestedInput
  }

  export type AlumnoCreateWithoutDeudasInput = {
    nombre: string
    apellido: string
    dni: string
    activo?: boolean
    fechaNacimiento: Date | string
    email?: string | null
    telefono?: string | null
    numeroEmergencia?: string | null
    direccion?: string | null
    obraSocial?: string | null
    nombreTutor?: string | null
    dniTutor?: string | null
    notas?: string | null
    fechaIngreso?: Date | string
    fechaBaja?: Date | string | null
    motivoBaja?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recibos?: ReciboCreateNestedManyWithoutAlumnoInput
    alumnosSueltosAnteriores?: AlumnoSueltoCreateNestedManyWithoutAlumnoRegularInput
    ctaCte?: CtaCteCreateNestedOneWithoutAlumnoInput
    estilos?: EstiloCreateNestedManyWithoutAlumnosInput
    asistencias?: AsistenciaCreateNestedManyWithoutAlumnoInput
    alumnoEstilos?: AlumnoEstilosCreateNestedManyWithoutAlumnoInput
    descuentosVigentes?: DescuentoAplicadoCreateNestedManyWithoutAlumnoInput
    configuracionPago?: ConfiguracionPagoAlumnoCreateNestedOneWithoutAlumnoInput
  }

  export type AlumnoUncheckedCreateWithoutDeudasInput = {
    id?: number
    nombre: string
    apellido: string
    dni: string
    activo?: boolean
    fechaNacimiento: Date | string
    email?: string | null
    telefono?: string | null
    numeroEmergencia?: string | null
    direccion?: string | null
    obraSocial?: string | null
    nombreTutor?: string | null
    dniTutor?: string | null
    notas?: string | null
    fechaIngreso?: Date | string
    fechaBaja?: Date | string | null
    motivoBaja?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recibos?: ReciboUncheckedCreateNestedManyWithoutAlumnoInput
    alumnosSueltosAnteriores?: AlumnoSueltoUncheckedCreateNestedManyWithoutAlumnoRegularInput
    ctaCte?: CtaCteUncheckedCreateNestedOneWithoutAlumnoInput
    estilos?: EstiloUncheckedCreateNestedManyWithoutAlumnosInput
    asistencias?: AsistenciaUncheckedCreateNestedManyWithoutAlumnoInput
    alumnoEstilos?: AlumnoEstilosUncheckedCreateNestedManyWithoutAlumnoInput
    descuentosVigentes?: DescuentoAplicadoUncheckedCreateNestedManyWithoutAlumnoInput
    configuracionPago?: ConfiguracionPagoAlumnoUncheckedCreateNestedOneWithoutAlumnoInput
  }

  export type AlumnoCreateOrConnectWithoutDeudasInput = {
    where: AlumnoWhereUniqueInput
    create: XOR<AlumnoCreateWithoutDeudasInput, AlumnoUncheckedCreateWithoutDeudasInput>
  }

  export type EstiloCreateWithoutDeudasInput = {
    nombre: string
    monto?: number
    descripcion?: string | null
    importe?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conceptos?: ConceptoCreateNestedManyWithoutEstiloInput
    clases?: ClaseCreateNestedManyWithoutEstiloInput
    alumnoEstilos?: AlumnoEstilosCreateNestedManyWithoutEstiloInput
    profesor?: ProfesorCreateNestedOneWithoutEstilosInput
    alumnos?: AlumnoCreateNestedManyWithoutEstilosInput
  }

  export type EstiloUncheckedCreateWithoutDeudasInput = {
    id?: number
    nombre: string
    monto?: number
    descripcion?: string | null
    importe?: number
    profesorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conceptos?: ConceptoUncheckedCreateNestedManyWithoutEstiloInput
    clases?: ClaseUncheckedCreateNestedManyWithoutEstiloInput
    alumnoEstilos?: AlumnoEstilosUncheckedCreateNestedManyWithoutEstiloInput
    alumnos?: AlumnoUncheckedCreateNestedManyWithoutEstilosInput
  }

  export type EstiloCreateOrConnectWithoutDeudasInput = {
    where: EstiloWhereUniqueInput
    create: XOR<EstiloCreateWithoutDeudasInput, EstiloUncheckedCreateWithoutDeudasInput>
  }

  export type PagoDeudaCreateWithoutDeudaInput = {
    monto: number
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    recibo: ReciboCreateNestedOneWithoutPagosDeudaInput
  }

  export type PagoDeudaUncheckedCreateWithoutDeudaInput = {
    id?: number
    reciboId: number
    monto: number
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PagoDeudaCreateOrConnectWithoutDeudaInput = {
    where: PagoDeudaWhereUniqueInput
    create: XOR<PagoDeudaCreateWithoutDeudaInput, PagoDeudaUncheckedCreateWithoutDeudaInput>
  }

  export type PagoDeudaCreateManyDeudaInputEnvelope = {
    data: PagoDeudaCreateManyDeudaInput | PagoDeudaCreateManyDeudaInput[]
    skipDuplicates?: boolean
  }

  export type AlumnoUpsertWithoutDeudasInput = {
    update: XOR<AlumnoUpdateWithoutDeudasInput, AlumnoUncheckedUpdateWithoutDeudasInput>
    create: XOR<AlumnoCreateWithoutDeudasInput, AlumnoUncheckedCreateWithoutDeudasInput>
    where?: AlumnoWhereInput
  }

  export type AlumnoUpdateToOneWithWhereWithoutDeudasInput = {
    where?: AlumnoWhereInput
    data: XOR<AlumnoUpdateWithoutDeudasInput, AlumnoUncheckedUpdateWithoutDeudasInput>
  }

  export type AlumnoUpdateWithoutDeudasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    numeroEmergencia?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    obraSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nombreTutor?: NullableStringFieldUpdateOperationsInput | string | null
    dniTutor?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoBaja?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibos?: ReciboUpdateManyWithoutAlumnoNestedInput
    alumnosSueltosAnteriores?: AlumnoSueltoUpdateManyWithoutAlumnoRegularNestedInput
    ctaCte?: CtaCteUpdateOneWithoutAlumnoNestedInput
    estilos?: EstiloUpdateManyWithoutAlumnosNestedInput
    asistencias?: AsistenciaUpdateManyWithoutAlumnoNestedInput
    alumnoEstilos?: AlumnoEstilosUpdateManyWithoutAlumnoNestedInput
    descuentosVigentes?: DescuentoAplicadoUpdateManyWithoutAlumnoNestedInput
    configuracionPago?: ConfiguracionPagoAlumnoUpdateOneWithoutAlumnoNestedInput
  }

  export type AlumnoUncheckedUpdateWithoutDeudasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    numeroEmergencia?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    obraSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nombreTutor?: NullableStringFieldUpdateOperationsInput | string | null
    dniTutor?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoBaja?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibos?: ReciboUncheckedUpdateManyWithoutAlumnoNestedInput
    alumnosSueltosAnteriores?: AlumnoSueltoUncheckedUpdateManyWithoutAlumnoRegularNestedInput
    ctaCte?: CtaCteUncheckedUpdateOneWithoutAlumnoNestedInput
    estilos?: EstiloUncheckedUpdateManyWithoutAlumnosNestedInput
    asistencias?: AsistenciaUncheckedUpdateManyWithoutAlumnoNestedInput
    alumnoEstilos?: AlumnoEstilosUncheckedUpdateManyWithoutAlumnoNestedInput
    descuentosVigentes?: DescuentoAplicadoUncheckedUpdateManyWithoutAlumnoNestedInput
    configuracionPago?: ConfiguracionPagoAlumnoUncheckedUpdateOneWithoutAlumnoNestedInput
  }

  export type EstiloUpsertWithoutDeudasInput = {
    update: XOR<EstiloUpdateWithoutDeudasInput, EstiloUncheckedUpdateWithoutDeudasInput>
    create: XOR<EstiloCreateWithoutDeudasInput, EstiloUncheckedCreateWithoutDeudasInput>
    where?: EstiloWhereInput
  }

  export type EstiloUpdateToOneWithWhereWithoutDeudasInput = {
    where?: EstiloWhereInput
    data: XOR<EstiloUpdateWithoutDeudasInput, EstiloUncheckedUpdateWithoutDeudasInput>
  }

  export type EstiloUpdateWithoutDeudasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptos?: ConceptoUpdateManyWithoutEstiloNestedInput
    clases?: ClaseUpdateManyWithoutEstiloNestedInput
    alumnoEstilos?: AlumnoEstilosUpdateManyWithoutEstiloNestedInput
    profesor?: ProfesorUpdateOneWithoutEstilosNestedInput
    alumnos?: AlumnoUpdateManyWithoutEstilosNestedInput
  }

  export type EstiloUncheckedUpdateWithoutDeudasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: FloatFieldUpdateOperationsInput | number
    profesorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptos?: ConceptoUncheckedUpdateManyWithoutEstiloNestedInput
    clases?: ClaseUncheckedUpdateManyWithoutEstiloNestedInput
    alumnoEstilos?: AlumnoEstilosUncheckedUpdateManyWithoutEstiloNestedInput
    alumnos?: AlumnoUncheckedUpdateManyWithoutEstilosNestedInput
  }

  export type PagoDeudaUpsertWithWhereUniqueWithoutDeudaInput = {
    where: PagoDeudaWhereUniqueInput
    update: XOR<PagoDeudaUpdateWithoutDeudaInput, PagoDeudaUncheckedUpdateWithoutDeudaInput>
    create: XOR<PagoDeudaCreateWithoutDeudaInput, PagoDeudaUncheckedCreateWithoutDeudaInput>
  }

  export type PagoDeudaUpdateWithWhereUniqueWithoutDeudaInput = {
    where: PagoDeudaWhereUniqueInput
    data: XOR<PagoDeudaUpdateWithoutDeudaInput, PagoDeudaUncheckedUpdateWithoutDeudaInput>
  }

  export type PagoDeudaUpdateManyWithWhereWithoutDeudaInput = {
    where: PagoDeudaScalarWhereInput
    data: XOR<PagoDeudaUpdateManyMutationInput, PagoDeudaUncheckedUpdateManyWithoutDeudaInput>
  }

  export type PagoDeudaScalarWhereInput = {
    AND?: PagoDeudaScalarWhereInput | PagoDeudaScalarWhereInput[]
    OR?: PagoDeudaScalarWhereInput[]
    NOT?: PagoDeudaScalarWhereInput | PagoDeudaScalarWhereInput[]
    id?: IntFilter<"PagoDeuda"> | number
    deudaId?: IntFilter<"PagoDeuda"> | number
    reciboId?: IntFilter<"PagoDeuda"> | number
    monto?: FloatFilter<"PagoDeuda"> | number
    fecha?: DateTimeFilter<"PagoDeuda"> | Date | string
    createdAt?: DateTimeFilter<"PagoDeuda"> | Date | string
    updatedAt?: DateTimeFilter<"PagoDeuda"> | Date | string
  }

  export type DeudaCreateWithoutPagosInput = {
    monto: number
    montoOriginal: number
    mes: string
    anio: number
    pagada?: boolean
    fechaPago?: Date | string | null
    fechaVencimiento: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    alumno: AlumnoCreateNestedOneWithoutDeudasInput
    estilo: EstiloCreateNestedOneWithoutDeudasInput
  }

  export type DeudaUncheckedCreateWithoutPagosInput = {
    id?: number
    alumnoId: number
    monto: number
    montoOriginal: number
    mes: string
    anio: number
    estiloId: number
    pagada?: boolean
    fechaPago?: Date | string | null
    fechaVencimiento: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeudaCreateOrConnectWithoutPagosInput = {
    where: DeudaWhereUniqueInput
    create: XOR<DeudaCreateWithoutPagosInput, DeudaUncheckedCreateWithoutPagosInput>
  }

  export type ReciboCreateWithoutPagosDeudaInput = {
    numeroRecibo?: number
    fecha?: Date | string
    fechaEfecto?: Date | string
    monto: number
    montoOriginal: number
    descuento?: number | null
    periodoPago: string
    tipoPago: $Enums.TipoPago
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    anulado?: boolean
    motivoAnulacion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alumno?: AlumnoCreateNestedOneWithoutRecibosInput
    alumnoSuelto?: AlumnoSueltoCreateNestedOneWithoutRecibosInput
    concepto: ConceptoCreateNestedOneWithoutRecibosInput
    detallesLiquidacion?: DetalleLiquidacionCreateNestedManyWithoutReciboInput
    clase?: ClaseCreateNestedOneWithoutRecibosInput
    reciboAnulado?: ReciboCreateNestedOneWithoutRecibosAnuladosInput
    recibosAnulados?: ReciboCreateNestedManyWithoutReciboAnuladoInput
  }

  export type ReciboUncheckedCreateWithoutPagosDeudaInput = {
    id?: number
    numeroRecibo?: number
    fecha?: Date | string
    fechaEfecto?: Date | string
    monto: number
    montoOriginal: number
    descuento?: number | null
    periodoPago: string
    tipoPago: $Enums.TipoPago
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    alumnoId?: number | null
    alumnoSueltoId?: number | null
    conceptoId: number
    claseId?: number | null
    anulado?: boolean
    motivoAnulacion?: string | null
    referenciaRecibo?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    detallesLiquidacion?: DetalleLiquidacionUncheckedCreateNestedManyWithoutReciboInput
    recibosAnulados?: ReciboUncheckedCreateNestedManyWithoutReciboAnuladoInput
  }

  export type ReciboCreateOrConnectWithoutPagosDeudaInput = {
    where: ReciboWhereUniqueInput
    create: XOR<ReciboCreateWithoutPagosDeudaInput, ReciboUncheckedCreateWithoutPagosDeudaInput>
  }

  export type DeudaUpsertWithoutPagosInput = {
    update: XOR<DeudaUpdateWithoutPagosInput, DeudaUncheckedUpdateWithoutPagosInput>
    create: XOR<DeudaCreateWithoutPagosInput, DeudaUncheckedCreateWithoutPagosInput>
    where?: DeudaWhereInput
  }

  export type DeudaUpdateToOneWithWhereWithoutPagosInput = {
    where?: DeudaWhereInput
    data: XOR<DeudaUpdateWithoutPagosInput, DeudaUncheckedUpdateWithoutPagosInput>
  }

  export type DeudaUpdateWithoutPagosInput = {
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    mes?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    pagada?: BoolFieldUpdateOperationsInput | boolean
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alumno?: AlumnoUpdateOneRequiredWithoutDeudasNestedInput
    estilo?: EstiloUpdateOneRequiredWithoutDeudasNestedInput
  }

  export type DeudaUncheckedUpdateWithoutPagosInput = {
    id?: IntFieldUpdateOperationsInput | number
    alumnoId?: IntFieldUpdateOperationsInput | number
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    mes?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    estiloId?: IntFieldUpdateOperationsInput | number
    pagada?: BoolFieldUpdateOperationsInput | boolean
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReciboUpsertWithoutPagosDeudaInput = {
    update: XOR<ReciboUpdateWithoutPagosDeudaInput, ReciboUncheckedUpdateWithoutPagosDeudaInput>
    create: XOR<ReciboCreateWithoutPagosDeudaInput, ReciboUncheckedCreateWithoutPagosDeudaInput>
    where?: ReciboWhereInput
  }

  export type ReciboUpdateToOneWithWhereWithoutPagosDeudaInput = {
    where?: ReciboWhereInput
    data: XOR<ReciboUpdateWithoutPagosDeudaInput, ReciboUncheckedUpdateWithoutPagosDeudaInput>
  }

  export type ReciboUpdateWithoutPagosDeudaInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEfecto?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    periodoPago?: StringFieldUpdateOperationsInput | string
    tipoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    fueraDeTermino?: BoolFieldUpdateOperationsInput | boolean
    esClaseSuelta?: BoolFieldUpdateOperationsInput | boolean
    esMesCompleto?: BoolFieldUpdateOperationsInput | boolean
    anulado?: BoolFieldUpdateOperationsInput | boolean
    motivoAnulacion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alumno?: AlumnoUpdateOneWithoutRecibosNestedInput
    alumnoSuelto?: AlumnoSueltoUpdateOneWithoutRecibosNestedInput
    concepto?: ConceptoUpdateOneRequiredWithoutRecibosNestedInput
    detallesLiquidacion?: DetalleLiquidacionUpdateManyWithoutReciboNestedInput
    clase?: ClaseUpdateOneWithoutRecibosNestedInput
    reciboAnulado?: ReciboUpdateOneWithoutRecibosAnuladosNestedInput
    recibosAnulados?: ReciboUpdateManyWithoutReciboAnuladoNestedInput
  }

  export type ReciboUncheckedUpdateWithoutPagosDeudaInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroRecibo?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEfecto?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    periodoPago?: StringFieldUpdateOperationsInput | string
    tipoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    fueraDeTermino?: BoolFieldUpdateOperationsInput | boolean
    esClaseSuelta?: BoolFieldUpdateOperationsInput | boolean
    esMesCompleto?: BoolFieldUpdateOperationsInput | boolean
    alumnoId?: NullableIntFieldUpdateOperationsInput | number | null
    alumnoSueltoId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptoId?: IntFieldUpdateOperationsInput | number
    claseId?: NullableIntFieldUpdateOperationsInput | number | null
    anulado?: BoolFieldUpdateOperationsInput | boolean
    motivoAnulacion?: NullableStringFieldUpdateOperationsInput | string | null
    referenciaRecibo?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detallesLiquidacion?: DetalleLiquidacionUncheckedUpdateManyWithoutReciboNestedInput
    recibosAnulados?: ReciboUncheckedUpdateManyWithoutReciboAnuladoNestedInput
  }

  export type EstiloCreateWithoutConceptosInput = {
    nombre: string
    monto?: number
    descripcion?: string | null
    importe?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deudas?: DeudaCreateNestedManyWithoutEstiloInput
    clases?: ClaseCreateNestedManyWithoutEstiloInput
    alumnoEstilos?: AlumnoEstilosCreateNestedManyWithoutEstiloInput
    profesor?: ProfesorCreateNestedOneWithoutEstilosInput
    alumnos?: AlumnoCreateNestedManyWithoutEstilosInput
  }

  export type EstiloUncheckedCreateWithoutConceptosInput = {
    id?: number
    nombre: string
    monto?: number
    descripcion?: string | null
    importe?: number
    profesorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deudas?: DeudaUncheckedCreateNestedManyWithoutEstiloInput
    clases?: ClaseUncheckedCreateNestedManyWithoutEstiloInput
    alumnoEstilos?: AlumnoEstilosUncheckedCreateNestedManyWithoutEstiloInput
    alumnos?: AlumnoUncheckedCreateNestedManyWithoutEstilosInput
  }

  export type EstiloCreateOrConnectWithoutConceptosInput = {
    where: EstiloWhereUniqueInput
    create: XOR<EstiloCreateWithoutConceptosInput, EstiloUncheckedCreateWithoutConceptosInput>
  }

  export type ReciboCreateWithoutConceptoInput = {
    numeroRecibo?: number
    fecha?: Date | string
    fechaEfecto?: Date | string
    monto: number
    montoOriginal: number
    descuento?: number | null
    periodoPago: string
    tipoPago: $Enums.TipoPago
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    anulado?: boolean
    motivoAnulacion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alumno?: AlumnoCreateNestedOneWithoutRecibosInput
    alumnoSuelto?: AlumnoSueltoCreateNestedOneWithoutRecibosInput
    pagosDeuda?: PagoDeudaCreateNestedManyWithoutReciboInput
    detallesLiquidacion?: DetalleLiquidacionCreateNestedManyWithoutReciboInput
    clase?: ClaseCreateNestedOneWithoutRecibosInput
    reciboAnulado?: ReciboCreateNestedOneWithoutRecibosAnuladosInput
    recibosAnulados?: ReciboCreateNestedManyWithoutReciboAnuladoInput
  }

  export type ReciboUncheckedCreateWithoutConceptoInput = {
    id?: number
    numeroRecibo?: number
    fecha?: Date | string
    fechaEfecto?: Date | string
    monto: number
    montoOriginal: number
    descuento?: number | null
    periodoPago: string
    tipoPago: $Enums.TipoPago
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    alumnoId?: number | null
    alumnoSueltoId?: number | null
    claseId?: number | null
    anulado?: boolean
    motivoAnulacion?: string | null
    referenciaRecibo?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pagosDeuda?: PagoDeudaUncheckedCreateNestedManyWithoutReciboInput
    detallesLiquidacion?: DetalleLiquidacionUncheckedCreateNestedManyWithoutReciboInput
    recibosAnulados?: ReciboUncheckedCreateNestedManyWithoutReciboAnuladoInput
  }

  export type ReciboCreateOrConnectWithoutConceptoInput = {
    where: ReciboWhereUniqueInput
    create: XOR<ReciboCreateWithoutConceptoInput, ReciboUncheckedCreateWithoutConceptoInput>
  }

  export type ReciboCreateManyConceptoInputEnvelope = {
    data: ReciboCreateManyConceptoInput | ReciboCreateManyConceptoInput[]
    skipDuplicates?: boolean
  }

  export type EstiloUpsertWithoutConceptosInput = {
    update: XOR<EstiloUpdateWithoutConceptosInput, EstiloUncheckedUpdateWithoutConceptosInput>
    create: XOR<EstiloCreateWithoutConceptosInput, EstiloUncheckedCreateWithoutConceptosInput>
    where?: EstiloWhereInput
  }

  export type EstiloUpdateToOneWithWhereWithoutConceptosInput = {
    where?: EstiloWhereInput
    data: XOR<EstiloUpdateWithoutConceptosInput, EstiloUncheckedUpdateWithoutConceptosInput>
  }

  export type EstiloUpdateWithoutConceptosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deudas?: DeudaUpdateManyWithoutEstiloNestedInput
    clases?: ClaseUpdateManyWithoutEstiloNestedInput
    alumnoEstilos?: AlumnoEstilosUpdateManyWithoutEstiloNestedInput
    profesor?: ProfesorUpdateOneWithoutEstilosNestedInput
    alumnos?: AlumnoUpdateManyWithoutEstilosNestedInput
  }

  export type EstiloUncheckedUpdateWithoutConceptosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: FloatFieldUpdateOperationsInput | number
    profesorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deudas?: DeudaUncheckedUpdateManyWithoutEstiloNestedInput
    clases?: ClaseUncheckedUpdateManyWithoutEstiloNestedInput
    alumnoEstilos?: AlumnoEstilosUncheckedUpdateManyWithoutEstiloNestedInput
    alumnos?: AlumnoUncheckedUpdateManyWithoutEstilosNestedInput
  }

  export type ReciboUpsertWithWhereUniqueWithoutConceptoInput = {
    where: ReciboWhereUniqueInput
    update: XOR<ReciboUpdateWithoutConceptoInput, ReciboUncheckedUpdateWithoutConceptoInput>
    create: XOR<ReciboCreateWithoutConceptoInput, ReciboUncheckedCreateWithoutConceptoInput>
  }

  export type ReciboUpdateWithWhereUniqueWithoutConceptoInput = {
    where: ReciboWhereUniqueInput
    data: XOR<ReciboUpdateWithoutConceptoInput, ReciboUncheckedUpdateWithoutConceptoInput>
  }

  export type ReciboUpdateManyWithWhereWithoutConceptoInput = {
    where: ReciboScalarWhereInput
    data: XOR<ReciboUpdateManyMutationInput, ReciboUncheckedUpdateManyWithoutConceptoInput>
  }

  export type AlumnoCreateWithoutRecibosInput = {
    nombre: string
    apellido: string
    dni: string
    activo?: boolean
    fechaNacimiento: Date | string
    email?: string | null
    telefono?: string | null
    numeroEmergencia?: string | null
    direccion?: string | null
    obraSocial?: string | null
    nombreTutor?: string | null
    dniTutor?: string | null
    notas?: string | null
    fechaIngreso?: Date | string
    fechaBaja?: Date | string | null
    motivoBaja?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alumnosSueltosAnteriores?: AlumnoSueltoCreateNestedManyWithoutAlumnoRegularInput
    ctaCte?: CtaCteCreateNestedOneWithoutAlumnoInput
    estilos?: EstiloCreateNestedManyWithoutAlumnosInput
    asistencias?: AsistenciaCreateNestedManyWithoutAlumnoInput
    alumnoEstilos?: AlumnoEstilosCreateNestedManyWithoutAlumnoInput
    deudas?: DeudaCreateNestedManyWithoutAlumnoInput
    descuentosVigentes?: DescuentoAplicadoCreateNestedManyWithoutAlumnoInput
    configuracionPago?: ConfiguracionPagoAlumnoCreateNestedOneWithoutAlumnoInput
  }

  export type AlumnoUncheckedCreateWithoutRecibosInput = {
    id?: number
    nombre: string
    apellido: string
    dni: string
    activo?: boolean
    fechaNacimiento: Date | string
    email?: string | null
    telefono?: string | null
    numeroEmergencia?: string | null
    direccion?: string | null
    obraSocial?: string | null
    nombreTutor?: string | null
    dniTutor?: string | null
    notas?: string | null
    fechaIngreso?: Date | string
    fechaBaja?: Date | string | null
    motivoBaja?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alumnosSueltosAnteriores?: AlumnoSueltoUncheckedCreateNestedManyWithoutAlumnoRegularInput
    ctaCte?: CtaCteUncheckedCreateNestedOneWithoutAlumnoInput
    estilos?: EstiloUncheckedCreateNestedManyWithoutAlumnosInput
    asistencias?: AsistenciaUncheckedCreateNestedManyWithoutAlumnoInput
    alumnoEstilos?: AlumnoEstilosUncheckedCreateNestedManyWithoutAlumnoInput
    deudas?: DeudaUncheckedCreateNestedManyWithoutAlumnoInput
    descuentosVigentes?: DescuentoAplicadoUncheckedCreateNestedManyWithoutAlumnoInput
    configuracionPago?: ConfiguracionPagoAlumnoUncheckedCreateNestedOneWithoutAlumnoInput
  }

  export type AlumnoCreateOrConnectWithoutRecibosInput = {
    where: AlumnoWhereUniqueInput
    create: XOR<AlumnoCreateWithoutRecibosInput, AlumnoUncheckedCreateWithoutRecibosInput>
  }

  export type AlumnoSueltoCreateWithoutRecibosInput = {
    nombre: string
    apellido: string
    dni: string
    telefono?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clases?: ClaseCreateNestedManyWithoutAlumnosSueltosInput
    alumnoRegular?: AlumnoCreateNestedOneWithoutAlumnosSueltosAnterioresInput
  }

  export type AlumnoSueltoUncheckedCreateWithoutRecibosInput = {
    id?: number
    nombre: string
    apellido: string
    dni: string
    telefono?: string | null
    email?: string | null
    alumnoRegularId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clases?: ClaseUncheckedCreateNestedManyWithoutAlumnosSueltosInput
  }

  export type AlumnoSueltoCreateOrConnectWithoutRecibosInput = {
    where: AlumnoSueltoWhereUniqueInput
    create: XOR<AlumnoSueltoCreateWithoutRecibosInput, AlumnoSueltoUncheckedCreateWithoutRecibosInput>
  }

  export type ConceptoCreateWithoutRecibosInput = {
    nombre: string
    descripcion?: string | null
    monto: number
    createdAt?: Date | string
    updatedAt?: Date | string
    estilo?: EstiloCreateNestedOneWithoutConceptosInput
  }

  export type ConceptoUncheckedCreateWithoutRecibosInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    monto: number
    estiloId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConceptoCreateOrConnectWithoutRecibosInput = {
    where: ConceptoWhereUniqueInput
    create: XOR<ConceptoCreateWithoutRecibosInput, ConceptoUncheckedCreateWithoutRecibosInput>
  }

  export type PagoDeudaCreateWithoutReciboInput = {
    monto: number
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deuda: DeudaCreateNestedOneWithoutPagosInput
  }

  export type PagoDeudaUncheckedCreateWithoutReciboInput = {
    id?: number
    deudaId: number
    monto: number
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PagoDeudaCreateOrConnectWithoutReciboInput = {
    where: PagoDeudaWhereUniqueInput
    create: XOR<PagoDeudaCreateWithoutReciboInput, PagoDeudaUncheckedCreateWithoutReciboInput>
  }

  export type PagoDeudaCreateManyReciboInputEnvelope = {
    data: PagoDeudaCreateManyReciboInput | PagoDeudaCreateManyReciboInput[]
    skipDuplicates?: boolean
  }

  export type DetalleLiquidacionCreateWithoutReciboInput = {
    montoOriginal: number
    porcentaje: number
    montoLiquidado: number
    createdAt?: Date | string
    updatedAt?: Date | string
    liquidacion: LiquidacionCreateNestedOneWithoutDetallesInput
  }

  export type DetalleLiquidacionUncheckedCreateWithoutReciboInput = {
    id?: number
    liquidacionId: number
    montoOriginal: number
    porcentaje: number
    montoLiquidado: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetalleLiquidacionCreateOrConnectWithoutReciboInput = {
    where: DetalleLiquidacionWhereUniqueInput
    create: XOR<DetalleLiquidacionCreateWithoutReciboInput, DetalleLiquidacionUncheckedCreateWithoutReciboInput>
  }

  export type DetalleLiquidacionCreateManyReciboInputEnvelope = {
    data: DetalleLiquidacionCreateManyReciboInput | DetalleLiquidacionCreateManyReciboInput[]
    skipDuplicates?: boolean
  }

  export type ClaseCreateWithoutRecibosInput = {
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    profesor: ProfesorCreateNestedOneWithoutClasesInput
    estilo: EstiloCreateNestedOneWithoutClasesInput
    asistencias?: AsistenciaCreateNestedManyWithoutClaseInput
    alumnosSueltos?: AlumnoSueltoCreateNestedManyWithoutClasesInput
  }

  export type ClaseUncheckedCreateWithoutRecibosInput = {
    id?: number
    fecha?: Date | string
    profesorId: number
    estiloId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    asistencias?: AsistenciaUncheckedCreateNestedManyWithoutClaseInput
    alumnosSueltos?: AlumnoSueltoUncheckedCreateNestedManyWithoutClasesInput
  }

  export type ClaseCreateOrConnectWithoutRecibosInput = {
    where: ClaseWhereUniqueInput
    create: XOR<ClaseCreateWithoutRecibosInput, ClaseUncheckedCreateWithoutRecibosInput>
  }

  export type ReciboCreateWithoutRecibosAnuladosInput = {
    numeroRecibo?: number
    fecha?: Date | string
    fechaEfecto?: Date | string
    monto: number
    montoOriginal: number
    descuento?: number | null
    periodoPago: string
    tipoPago: $Enums.TipoPago
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    anulado?: boolean
    motivoAnulacion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alumno?: AlumnoCreateNestedOneWithoutRecibosInput
    alumnoSuelto?: AlumnoSueltoCreateNestedOneWithoutRecibosInput
    concepto: ConceptoCreateNestedOneWithoutRecibosInput
    pagosDeuda?: PagoDeudaCreateNestedManyWithoutReciboInput
    detallesLiquidacion?: DetalleLiquidacionCreateNestedManyWithoutReciboInput
    clase?: ClaseCreateNestedOneWithoutRecibosInput
    reciboAnulado?: ReciboCreateNestedOneWithoutRecibosAnuladosInput
  }

  export type ReciboUncheckedCreateWithoutRecibosAnuladosInput = {
    id?: number
    numeroRecibo?: number
    fecha?: Date | string
    fechaEfecto?: Date | string
    monto: number
    montoOriginal: number
    descuento?: number | null
    periodoPago: string
    tipoPago: $Enums.TipoPago
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    alumnoId?: number | null
    alumnoSueltoId?: number | null
    conceptoId: number
    claseId?: number | null
    anulado?: boolean
    motivoAnulacion?: string | null
    referenciaRecibo?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pagosDeuda?: PagoDeudaUncheckedCreateNestedManyWithoutReciboInput
    detallesLiquidacion?: DetalleLiquidacionUncheckedCreateNestedManyWithoutReciboInput
  }

  export type ReciboCreateOrConnectWithoutRecibosAnuladosInput = {
    where: ReciboWhereUniqueInput
    create: XOR<ReciboCreateWithoutRecibosAnuladosInput, ReciboUncheckedCreateWithoutRecibosAnuladosInput>
  }

  export type ReciboCreateWithoutReciboAnuladoInput = {
    numeroRecibo?: number
    fecha?: Date | string
    fechaEfecto?: Date | string
    monto: number
    montoOriginal: number
    descuento?: number | null
    periodoPago: string
    tipoPago: $Enums.TipoPago
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    anulado?: boolean
    motivoAnulacion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alumno?: AlumnoCreateNestedOneWithoutRecibosInput
    alumnoSuelto?: AlumnoSueltoCreateNestedOneWithoutRecibosInput
    concepto: ConceptoCreateNestedOneWithoutRecibosInput
    pagosDeuda?: PagoDeudaCreateNestedManyWithoutReciboInput
    detallesLiquidacion?: DetalleLiquidacionCreateNestedManyWithoutReciboInput
    clase?: ClaseCreateNestedOneWithoutRecibosInput
    recibosAnulados?: ReciboCreateNestedManyWithoutReciboAnuladoInput
  }

  export type ReciboUncheckedCreateWithoutReciboAnuladoInput = {
    id?: number
    numeroRecibo?: number
    fecha?: Date | string
    fechaEfecto?: Date | string
    monto: number
    montoOriginal: number
    descuento?: number | null
    periodoPago: string
    tipoPago: $Enums.TipoPago
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    alumnoId?: number | null
    alumnoSueltoId?: number | null
    conceptoId: number
    claseId?: number | null
    anulado?: boolean
    motivoAnulacion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pagosDeuda?: PagoDeudaUncheckedCreateNestedManyWithoutReciboInput
    detallesLiquidacion?: DetalleLiquidacionUncheckedCreateNestedManyWithoutReciboInput
    recibosAnulados?: ReciboUncheckedCreateNestedManyWithoutReciboAnuladoInput
  }

  export type ReciboCreateOrConnectWithoutReciboAnuladoInput = {
    where: ReciboWhereUniqueInput
    create: XOR<ReciboCreateWithoutReciboAnuladoInput, ReciboUncheckedCreateWithoutReciboAnuladoInput>
  }

  export type ReciboCreateManyReciboAnuladoInputEnvelope = {
    data: ReciboCreateManyReciboAnuladoInput | ReciboCreateManyReciboAnuladoInput[]
    skipDuplicates?: boolean
  }

  export type AlumnoUpsertWithoutRecibosInput = {
    update: XOR<AlumnoUpdateWithoutRecibosInput, AlumnoUncheckedUpdateWithoutRecibosInput>
    create: XOR<AlumnoCreateWithoutRecibosInput, AlumnoUncheckedCreateWithoutRecibosInput>
    where?: AlumnoWhereInput
  }

  export type AlumnoUpdateToOneWithWhereWithoutRecibosInput = {
    where?: AlumnoWhereInput
    data: XOR<AlumnoUpdateWithoutRecibosInput, AlumnoUncheckedUpdateWithoutRecibosInput>
  }

  export type AlumnoUpdateWithoutRecibosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    numeroEmergencia?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    obraSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nombreTutor?: NullableStringFieldUpdateOperationsInput | string | null
    dniTutor?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoBaja?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alumnosSueltosAnteriores?: AlumnoSueltoUpdateManyWithoutAlumnoRegularNestedInput
    ctaCte?: CtaCteUpdateOneWithoutAlumnoNestedInput
    estilos?: EstiloUpdateManyWithoutAlumnosNestedInput
    asistencias?: AsistenciaUpdateManyWithoutAlumnoNestedInput
    alumnoEstilos?: AlumnoEstilosUpdateManyWithoutAlumnoNestedInput
    deudas?: DeudaUpdateManyWithoutAlumnoNestedInput
    descuentosVigentes?: DescuentoAplicadoUpdateManyWithoutAlumnoNestedInput
    configuracionPago?: ConfiguracionPagoAlumnoUpdateOneWithoutAlumnoNestedInput
  }

  export type AlumnoUncheckedUpdateWithoutRecibosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    numeroEmergencia?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    obraSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nombreTutor?: NullableStringFieldUpdateOperationsInput | string | null
    dniTutor?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoBaja?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alumnosSueltosAnteriores?: AlumnoSueltoUncheckedUpdateManyWithoutAlumnoRegularNestedInput
    ctaCte?: CtaCteUncheckedUpdateOneWithoutAlumnoNestedInput
    estilos?: EstiloUncheckedUpdateManyWithoutAlumnosNestedInput
    asistencias?: AsistenciaUncheckedUpdateManyWithoutAlumnoNestedInput
    alumnoEstilos?: AlumnoEstilosUncheckedUpdateManyWithoutAlumnoNestedInput
    deudas?: DeudaUncheckedUpdateManyWithoutAlumnoNestedInput
    descuentosVigentes?: DescuentoAplicadoUncheckedUpdateManyWithoutAlumnoNestedInput
    configuracionPago?: ConfiguracionPagoAlumnoUncheckedUpdateOneWithoutAlumnoNestedInput
  }

  export type AlumnoSueltoUpsertWithoutRecibosInput = {
    update: XOR<AlumnoSueltoUpdateWithoutRecibosInput, AlumnoSueltoUncheckedUpdateWithoutRecibosInput>
    create: XOR<AlumnoSueltoCreateWithoutRecibosInput, AlumnoSueltoUncheckedCreateWithoutRecibosInput>
    where?: AlumnoSueltoWhereInput
  }

  export type AlumnoSueltoUpdateToOneWithWhereWithoutRecibosInput = {
    where?: AlumnoSueltoWhereInput
    data: XOR<AlumnoSueltoUpdateWithoutRecibosInput, AlumnoSueltoUncheckedUpdateWithoutRecibosInput>
  }

  export type AlumnoSueltoUpdateWithoutRecibosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clases?: ClaseUpdateManyWithoutAlumnosSueltosNestedInput
    alumnoRegular?: AlumnoUpdateOneWithoutAlumnosSueltosAnterioresNestedInput
  }

  export type AlumnoSueltoUncheckedUpdateWithoutRecibosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    alumnoRegularId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clases?: ClaseUncheckedUpdateManyWithoutAlumnosSueltosNestedInput
  }

  export type ConceptoUpsertWithoutRecibosInput = {
    update: XOR<ConceptoUpdateWithoutRecibosInput, ConceptoUncheckedUpdateWithoutRecibosInput>
    create: XOR<ConceptoCreateWithoutRecibosInput, ConceptoUncheckedCreateWithoutRecibosInput>
    where?: ConceptoWhereInput
  }

  export type ConceptoUpdateToOneWithWhereWithoutRecibosInput = {
    where?: ConceptoWhereInput
    data: XOR<ConceptoUpdateWithoutRecibosInput, ConceptoUncheckedUpdateWithoutRecibosInput>
  }

  export type ConceptoUpdateWithoutRecibosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estilo?: EstiloUpdateOneWithoutConceptosNestedInput
  }

  export type ConceptoUncheckedUpdateWithoutRecibosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: FloatFieldUpdateOperationsInput | number
    estiloId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoDeudaUpsertWithWhereUniqueWithoutReciboInput = {
    where: PagoDeudaWhereUniqueInput
    update: XOR<PagoDeudaUpdateWithoutReciboInput, PagoDeudaUncheckedUpdateWithoutReciboInput>
    create: XOR<PagoDeudaCreateWithoutReciboInput, PagoDeudaUncheckedCreateWithoutReciboInput>
  }

  export type PagoDeudaUpdateWithWhereUniqueWithoutReciboInput = {
    where: PagoDeudaWhereUniqueInput
    data: XOR<PagoDeudaUpdateWithoutReciboInput, PagoDeudaUncheckedUpdateWithoutReciboInput>
  }

  export type PagoDeudaUpdateManyWithWhereWithoutReciboInput = {
    where: PagoDeudaScalarWhereInput
    data: XOR<PagoDeudaUpdateManyMutationInput, PagoDeudaUncheckedUpdateManyWithoutReciboInput>
  }

  export type DetalleLiquidacionUpsertWithWhereUniqueWithoutReciboInput = {
    where: DetalleLiquidacionWhereUniqueInput
    update: XOR<DetalleLiquidacionUpdateWithoutReciboInput, DetalleLiquidacionUncheckedUpdateWithoutReciboInput>
    create: XOR<DetalleLiquidacionCreateWithoutReciboInput, DetalleLiquidacionUncheckedCreateWithoutReciboInput>
  }

  export type DetalleLiquidacionUpdateWithWhereUniqueWithoutReciboInput = {
    where: DetalleLiquidacionWhereUniqueInput
    data: XOR<DetalleLiquidacionUpdateWithoutReciboInput, DetalleLiquidacionUncheckedUpdateWithoutReciboInput>
  }

  export type DetalleLiquidacionUpdateManyWithWhereWithoutReciboInput = {
    where: DetalleLiquidacionScalarWhereInput
    data: XOR<DetalleLiquidacionUpdateManyMutationInput, DetalleLiquidacionUncheckedUpdateManyWithoutReciboInput>
  }

  export type DetalleLiquidacionScalarWhereInput = {
    AND?: DetalleLiquidacionScalarWhereInput | DetalleLiquidacionScalarWhereInput[]
    OR?: DetalleLiquidacionScalarWhereInput[]
    NOT?: DetalleLiquidacionScalarWhereInput | DetalleLiquidacionScalarWhereInput[]
    id?: IntFilter<"DetalleLiquidacion"> | number
    liquidacionId?: IntFilter<"DetalleLiquidacion"> | number
    reciboId?: IntNullableFilter<"DetalleLiquidacion"> | number | null
    montoOriginal?: FloatFilter<"DetalleLiquidacion"> | number
    porcentaje?: FloatFilter<"DetalleLiquidacion"> | number
    montoLiquidado?: FloatFilter<"DetalleLiquidacion"> | number
    createdAt?: DateTimeFilter<"DetalleLiquidacion"> | Date | string
    updatedAt?: DateTimeFilter<"DetalleLiquidacion"> | Date | string
  }

  export type ClaseUpsertWithoutRecibosInput = {
    update: XOR<ClaseUpdateWithoutRecibosInput, ClaseUncheckedUpdateWithoutRecibosInput>
    create: XOR<ClaseCreateWithoutRecibosInput, ClaseUncheckedCreateWithoutRecibosInput>
    where?: ClaseWhereInput
  }

  export type ClaseUpdateToOneWithWhereWithoutRecibosInput = {
    where?: ClaseWhereInput
    data: XOR<ClaseUpdateWithoutRecibosInput, ClaseUncheckedUpdateWithoutRecibosInput>
  }

  export type ClaseUpdateWithoutRecibosInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profesor?: ProfesorUpdateOneRequiredWithoutClasesNestedInput
    estilo?: EstiloUpdateOneRequiredWithoutClasesNestedInput
    asistencias?: AsistenciaUpdateManyWithoutClaseNestedInput
    alumnosSueltos?: AlumnoSueltoUpdateManyWithoutClasesNestedInput
  }

  export type ClaseUncheckedUpdateWithoutRecibosInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    profesorId?: IntFieldUpdateOperationsInput | number
    estiloId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asistencias?: AsistenciaUncheckedUpdateManyWithoutClaseNestedInput
    alumnosSueltos?: AlumnoSueltoUncheckedUpdateManyWithoutClasesNestedInput
  }

  export type ReciboUpsertWithoutRecibosAnuladosInput = {
    update: XOR<ReciboUpdateWithoutRecibosAnuladosInput, ReciboUncheckedUpdateWithoutRecibosAnuladosInput>
    create: XOR<ReciboCreateWithoutRecibosAnuladosInput, ReciboUncheckedCreateWithoutRecibosAnuladosInput>
    where?: ReciboWhereInput
  }

  export type ReciboUpdateToOneWithWhereWithoutRecibosAnuladosInput = {
    where?: ReciboWhereInput
    data: XOR<ReciboUpdateWithoutRecibosAnuladosInput, ReciboUncheckedUpdateWithoutRecibosAnuladosInput>
  }

  export type ReciboUpdateWithoutRecibosAnuladosInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEfecto?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    periodoPago?: StringFieldUpdateOperationsInput | string
    tipoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    fueraDeTermino?: BoolFieldUpdateOperationsInput | boolean
    esClaseSuelta?: BoolFieldUpdateOperationsInput | boolean
    esMesCompleto?: BoolFieldUpdateOperationsInput | boolean
    anulado?: BoolFieldUpdateOperationsInput | boolean
    motivoAnulacion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alumno?: AlumnoUpdateOneWithoutRecibosNestedInput
    alumnoSuelto?: AlumnoSueltoUpdateOneWithoutRecibosNestedInput
    concepto?: ConceptoUpdateOneRequiredWithoutRecibosNestedInput
    pagosDeuda?: PagoDeudaUpdateManyWithoutReciboNestedInput
    detallesLiquidacion?: DetalleLiquidacionUpdateManyWithoutReciboNestedInput
    clase?: ClaseUpdateOneWithoutRecibosNestedInput
    reciboAnulado?: ReciboUpdateOneWithoutRecibosAnuladosNestedInput
  }

  export type ReciboUncheckedUpdateWithoutRecibosAnuladosInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroRecibo?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEfecto?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    periodoPago?: StringFieldUpdateOperationsInput | string
    tipoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    fueraDeTermino?: BoolFieldUpdateOperationsInput | boolean
    esClaseSuelta?: BoolFieldUpdateOperationsInput | boolean
    esMesCompleto?: BoolFieldUpdateOperationsInput | boolean
    alumnoId?: NullableIntFieldUpdateOperationsInput | number | null
    alumnoSueltoId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptoId?: IntFieldUpdateOperationsInput | number
    claseId?: NullableIntFieldUpdateOperationsInput | number | null
    anulado?: BoolFieldUpdateOperationsInput | boolean
    motivoAnulacion?: NullableStringFieldUpdateOperationsInput | string | null
    referenciaRecibo?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagosDeuda?: PagoDeudaUncheckedUpdateManyWithoutReciboNestedInput
    detallesLiquidacion?: DetalleLiquidacionUncheckedUpdateManyWithoutReciboNestedInput
  }

  export type ReciboUpsertWithWhereUniqueWithoutReciboAnuladoInput = {
    where: ReciboWhereUniqueInput
    update: XOR<ReciboUpdateWithoutReciboAnuladoInput, ReciboUncheckedUpdateWithoutReciboAnuladoInput>
    create: XOR<ReciboCreateWithoutReciboAnuladoInput, ReciboUncheckedCreateWithoutReciboAnuladoInput>
  }

  export type ReciboUpdateWithWhereUniqueWithoutReciboAnuladoInput = {
    where: ReciboWhereUniqueInput
    data: XOR<ReciboUpdateWithoutReciboAnuladoInput, ReciboUncheckedUpdateWithoutReciboAnuladoInput>
  }

  export type ReciboUpdateManyWithWhereWithoutReciboAnuladoInput = {
    where: ReciboScalarWhereInput
    data: XOR<ReciboUpdateManyMutationInput, ReciboUncheckedUpdateManyWithoutReciboAnuladoInput>
  }

  export type DeudaCreateWithoutEstiloInput = {
    monto: number
    montoOriginal: number
    mes: string
    anio: number
    pagada?: boolean
    fechaPago?: Date | string | null
    fechaVencimiento: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    alumno: AlumnoCreateNestedOneWithoutDeudasInput
    pagos?: PagoDeudaCreateNestedManyWithoutDeudaInput
  }

  export type DeudaUncheckedCreateWithoutEstiloInput = {
    id?: number
    alumnoId: number
    monto: number
    montoOriginal: number
    mes: string
    anio: number
    pagada?: boolean
    fechaPago?: Date | string | null
    fechaVencimiento: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    pagos?: PagoDeudaUncheckedCreateNestedManyWithoutDeudaInput
  }

  export type DeudaCreateOrConnectWithoutEstiloInput = {
    where: DeudaWhereUniqueInput
    create: XOR<DeudaCreateWithoutEstiloInput, DeudaUncheckedCreateWithoutEstiloInput>
  }

  export type DeudaCreateManyEstiloInputEnvelope = {
    data: DeudaCreateManyEstiloInput | DeudaCreateManyEstiloInput[]
    skipDuplicates?: boolean
  }

  export type ConceptoCreateWithoutEstiloInput = {
    nombre: string
    descripcion?: string | null
    monto: number
    createdAt?: Date | string
    updatedAt?: Date | string
    recibos?: ReciboCreateNestedManyWithoutConceptoInput
  }

  export type ConceptoUncheckedCreateWithoutEstiloInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    monto: number
    createdAt?: Date | string
    updatedAt?: Date | string
    recibos?: ReciboUncheckedCreateNestedManyWithoutConceptoInput
  }

  export type ConceptoCreateOrConnectWithoutEstiloInput = {
    where: ConceptoWhereUniqueInput
    create: XOR<ConceptoCreateWithoutEstiloInput, ConceptoUncheckedCreateWithoutEstiloInput>
  }

  export type ConceptoCreateManyEstiloInputEnvelope = {
    data: ConceptoCreateManyEstiloInput | ConceptoCreateManyEstiloInput[]
    skipDuplicates?: boolean
  }

  export type ClaseCreateWithoutEstiloInput = {
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    profesor: ProfesorCreateNestedOneWithoutClasesInput
    asistencias?: AsistenciaCreateNestedManyWithoutClaseInput
    alumnosSueltos?: AlumnoSueltoCreateNestedManyWithoutClasesInput
    recibos?: ReciboCreateNestedManyWithoutClaseInput
  }

  export type ClaseUncheckedCreateWithoutEstiloInput = {
    id?: number
    fecha?: Date | string
    profesorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    asistencias?: AsistenciaUncheckedCreateNestedManyWithoutClaseInput
    alumnosSueltos?: AlumnoSueltoUncheckedCreateNestedManyWithoutClasesInput
    recibos?: ReciboUncheckedCreateNestedManyWithoutClaseInput
  }

  export type ClaseCreateOrConnectWithoutEstiloInput = {
    where: ClaseWhereUniqueInput
    create: XOR<ClaseCreateWithoutEstiloInput, ClaseUncheckedCreateWithoutEstiloInput>
  }

  export type ClaseCreateManyEstiloInputEnvelope = {
    data: ClaseCreateManyEstiloInput | ClaseCreateManyEstiloInput[]
    skipDuplicates?: boolean
  }

  export type AlumnoEstilosCreateWithoutEstiloInput = {
    activo?: boolean
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    montoPersonalizado?: number | null
    descuentoPersonalizado?: number | null
    observaciones?: string | null
    alumno: AlumnoCreateNestedOneWithoutAlumnoEstilosInput
  }

  export type AlumnoEstilosUncheckedCreateWithoutEstiloInput = {
    id?: number
    alumnoId: number
    activo?: boolean
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    montoPersonalizado?: number | null
    descuentoPersonalizado?: number | null
    observaciones?: string | null
  }

  export type AlumnoEstilosCreateOrConnectWithoutEstiloInput = {
    where: AlumnoEstilosWhereUniqueInput
    create: XOR<AlumnoEstilosCreateWithoutEstiloInput, AlumnoEstilosUncheckedCreateWithoutEstiloInput>
  }

  export type AlumnoEstilosCreateManyEstiloInputEnvelope = {
    data: AlumnoEstilosCreateManyEstiloInput | AlumnoEstilosCreateManyEstiloInput[]
    skipDuplicates?: boolean
  }

  export type ProfesorCreateWithoutEstilosInput = {
    nombre: string
    apellido: string
    dni: string
    fechaNacimiento?: Date | string | null
    direccion?: string | null
    cuit?: string | null
    email?: string | null
    telefono?: string | null
    fechaIngreso?: Date | string
    porcentajePorDefecto?: number
    porcentajeClasesSueltasPorDefecto?: number
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clases?: ClaseCreateNestedManyWithoutProfesorInput
    liquidaciones?: LiquidacionCreateNestedManyWithoutProfesorInput
  }

  export type ProfesorUncheckedCreateWithoutEstilosInput = {
    id?: number
    nombre: string
    apellido: string
    dni: string
    fechaNacimiento?: Date | string | null
    direccion?: string | null
    cuit?: string | null
    email?: string | null
    telefono?: string | null
    fechaIngreso?: Date | string
    porcentajePorDefecto?: number
    porcentajeClasesSueltasPorDefecto?: number
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clases?: ClaseUncheckedCreateNestedManyWithoutProfesorInput
    liquidaciones?: LiquidacionUncheckedCreateNestedManyWithoutProfesorInput
  }

  export type ProfesorCreateOrConnectWithoutEstilosInput = {
    where: ProfesorWhereUniqueInput
    create: XOR<ProfesorCreateWithoutEstilosInput, ProfesorUncheckedCreateWithoutEstilosInput>
  }

  export type AlumnoCreateWithoutEstilosInput = {
    nombre: string
    apellido: string
    dni: string
    activo?: boolean
    fechaNacimiento: Date | string
    email?: string | null
    telefono?: string | null
    numeroEmergencia?: string | null
    direccion?: string | null
    obraSocial?: string | null
    nombreTutor?: string | null
    dniTutor?: string | null
    notas?: string | null
    fechaIngreso?: Date | string
    fechaBaja?: Date | string | null
    motivoBaja?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recibos?: ReciboCreateNestedManyWithoutAlumnoInput
    alumnosSueltosAnteriores?: AlumnoSueltoCreateNestedManyWithoutAlumnoRegularInput
    ctaCte?: CtaCteCreateNestedOneWithoutAlumnoInput
    asistencias?: AsistenciaCreateNestedManyWithoutAlumnoInput
    alumnoEstilos?: AlumnoEstilosCreateNestedManyWithoutAlumnoInput
    deudas?: DeudaCreateNestedManyWithoutAlumnoInput
    descuentosVigentes?: DescuentoAplicadoCreateNestedManyWithoutAlumnoInput
    configuracionPago?: ConfiguracionPagoAlumnoCreateNestedOneWithoutAlumnoInput
  }

  export type AlumnoUncheckedCreateWithoutEstilosInput = {
    id?: number
    nombre: string
    apellido: string
    dni: string
    activo?: boolean
    fechaNacimiento: Date | string
    email?: string | null
    telefono?: string | null
    numeroEmergencia?: string | null
    direccion?: string | null
    obraSocial?: string | null
    nombreTutor?: string | null
    dniTutor?: string | null
    notas?: string | null
    fechaIngreso?: Date | string
    fechaBaja?: Date | string | null
    motivoBaja?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recibos?: ReciboUncheckedCreateNestedManyWithoutAlumnoInput
    alumnosSueltosAnteriores?: AlumnoSueltoUncheckedCreateNestedManyWithoutAlumnoRegularInput
    ctaCte?: CtaCteUncheckedCreateNestedOneWithoutAlumnoInput
    asistencias?: AsistenciaUncheckedCreateNestedManyWithoutAlumnoInput
    alumnoEstilos?: AlumnoEstilosUncheckedCreateNestedManyWithoutAlumnoInput
    deudas?: DeudaUncheckedCreateNestedManyWithoutAlumnoInput
    descuentosVigentes?: DescuentoAplicadoUncheckedCreateNestedManyWithoutAlumnoInput
    configuracionPago?: ConfiguracionPagoAlumnoUncheckedCreateNestedOneWithoutAlumnoInput
  }

  export type AlumnoCreateOrConnectWithoutEstilosInput = {
    where: AlumnoWhereUniqueInput
    create: XOR<AlumnoCreateWithoutEstilosInput, AlumnoUncheckedCreateWithoutEstilosInput>
  }

  export type DeudaUpsertWithWhereUniqueWithoutEstiloInput = {
    where: DeudaWhereUniqueInput
    update: XOR<DeudaUpdateWithoutEstiloInput, DeudaUncheckedUpdateWithoutEstiloInput>
    create: XOR<DeudaCreateWithoutEstiloInput, DeudaUncheckedCreateWithoutEstiloInput>
  }

  export type DeudaUpdateWithWhereUniqueWithoutEstiloInput = {
    where: DeudaWhereUniqueInput
    data: XOR<DeudaUpdateWithoutEstiloInput, DeudaUncheckedUpdateWithoutEstiloInput>
  }

  export type DeudaUpdateManyWithWhereWithoutEstiloInput = {
    where: DeudaScalarWhereInput
    data: XOR<DeudaUpdateManyMutationInput, DeudaUncheckedUpdateManyWithoutEstiloInput>
  }

  export type ConceptoUpsertWithWhereUniqueWithoutEstiloInput = {
    where: ConceptoWhereUniqueInput
    update: XOR<ConceptoUpdateWithoutEstiloInput, ConceptoUncheckedUpdateWithoutEstiloInput>
    create: XOR<ConceptoCreateWithoutEstiloInput, ConceptoUncheckedCreateWithoutEstiloInput>
  }

  export type ConceptoUpdateWithWhereUniqueWithoutEstiloInput = {
    where: ConceptoWhereUniqueInput
    data: XOR<ConceptoUpdateWithoutEstiloInput, ConceptoUncheckedUpdateWithoutEstiloInput>
  }

  export type ConceptoUpdateManyWithWhereWithoutEstiloInput = {
    where: ConceptoScalarWhereInput
    data: XOR<ConceptoUpdateManyMutationInput, ConceptoUncheckedUpdateManyWithoutEstiloInput>
  }

  export type ConceptoScalarWhereInput = {
    AND?: ConceptoScalarWhereInput | ConceptoScalarWhereInput[]
    OR?: ConceptoScalarWhereInput[]
    NOT?: ConceptoScalarWhereInput | ConceptoScalarWhereInput[]
    id?: IntFilter<"Concepto"> | number
    nombre?: StringFilter<"Concepto"> | string
    descripcion?: StringNullableFilter<"Concepto"> | string | null
    monto?: FloatFilter<"Concepto"> | number
    estiloId?: IntNullableFilter<"Concepto"> | number | null
    createdAt?: DateTimeFilter<"Concepto"> | Date | string
    updatedAt?: DateTimeFilter<"Concepto"> | Date | string
  }

  export type ClaseUpsertWithWhereUniqueWithoutEstiloInput = {
    where: ClaseWhereUniqueInput
    update: XOR<ClaseUpdateWithoutEstiloInput, ClaseUncheckedUpdateWithoutEstiloInput>
    create: XOR<ClaseCreateWithoutEstiloInput, ClaseUncheckedCreateWithoutEstiloInput>
  }

  export type ClaseUpdateWithWhereUniqueWithoutEstiloInput = {
    where: ClaseWhereUniqueInput
    data: XOR<ClaseUpdateWithoutEstiloInput, ClaseUncheckedUpdateWithoutEstiloInput>
  }

  export type ClaseUpdateManyWithWhereWithoutEstiloInput = {
    where: ClaseScalarWhereInput
    data: XOR<ClaseUpdateManyMutationInput, ClaseUncheckedUpdateManyWithoutEstiloInput>
  }

  export type ClaseScalarWhereInput = {
    AND?: ClaseScalarWhereInput | ClaseScalarWhereInput[]
    OR?: ClaseScalarWhereInput[]
    NOT?: ClaseScalarWhereInput | ClaseScalarWhereInput[]
    id?: IntFilter<"Clase"> | number
    fecha?: DateTimeFilter<"Clase"> | Date | string
    profesorId?: IntFilter<"Clase"> | number
    estiloId?: IntFilter<"Clase"> | number
    createdAt?: DateTimeFilter<"Clase"> | Date | string
    updatedAt?: DateTimeFilter<"Clase"> | Date | string
  }

  export type AlumnoEstilosUpsertWithWhereUniqueWithoutEstiloInput = {
    where: AlumnoEstilosWhereUniqueInput
    update: XOR<AlumnoEstilosUpdateWithoutEstiloInput, AlumnoEstilosUncheckedUpdateWithoutEstiloInput>
    create: XOR<AlumnoEstilosCreateWithoutEstiloInput, AlumnoEstilosUncheckedCreateWithoutEstiloInput>
  }

  export type AlumnoEstilosUpdateWithWhereUniqueWithoutEstiloInput = {
    where: AlumnoEstilosWhereUniqueInput
    data: XOR<AlumnoEstilosUpdateWithoutEstiloInput, AlumnoEstilosUncheckedUpdateWithoutEstiloInput>
  }

  export type AlumnoEstilosUpdateManyWithWhereWithoutEstiloInput = {
    where: AlumnoEstilosScalarWhereInput
    data: XOR<AlumnoEstilosUpdateManyMutationInput, AlumnoEstilosUncheckedUpdateManyWithoutEstiloInput>
  }

  export type ProfesorUpsertWithoutEstilosInput = {
    update: XOR<ProfesorUpdateWithoutEstilosInput, ProfesorUncheckedUpdateWithoutEstilosInput>
    create: XOR<ProfesorCreateWithoutEstilosInput, ProfesorUncheckedCreateWithoutEstilosInput>
    where?: ProfesorWhereInput
  }

  export type ProfesorUpdateToOneWithWhereWithoutEstilosInput = {
    where?: ProfesorWhereInput
    data: XOR<ProfesorUpdateWithoutEstilosInput, ProfesorUncheckedUpdateWithoutEstilosInput>
  }

  export type ProfesorUpdateWithoutEstilosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    porcentajePorDefecto?: FloatFieldUpdateOperationsInput | number
    porcentajeClasesSueltasPorDefecto?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clases?: ClaseUpdateManyWithoutProfesorNestedInput
    liquidaciones?: LiquidacionUpdateManyWithoutProfesorNestedInput
  }

  export type ProfesorUncheckedUpdateWithoutEstilosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    porcentajePorDefecto?: FloatFieldUpdateOperationsInput | number
    porcentajeClasesSueltasPorDefecto?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clases?: ClaseUncheckedUpdateManyWithoutProfesorNestedInput
    liquidaciones?: LiquidacionUncheckedUpdateManyWithoutProfesorNestedInput
  }

  export type AlumnoUpsertWithWhereUniqueWithoutEstilosInput = {
    where: AlumnoWhereUniqueInput
    update: XOR<AlumnoUpdateWithoutEstilosInput, AlumnoUncheckedUpdateWithoutEstilosInput>
    create: XOR<AlumnoCreateWithoutEstilosInput, AlumnoUncheckedCreateWithoutEstilosInput>
  }

  export type AlumnoUpdateWithWhereUniqueWithoutEstilosInput = {
    where: AlumnoWhereUniqueInput
    data: XOR<AlumnoUpdateWithoutEstilosInput, AlumnoUncheckedUpdateWithoutEstilosInput>
  }

  export type AlumnoUpdateManyWithWhereWithoutEstilosInput = {
    where: AlumnoScalarWhereInput
    data: XOR<AlumnoUpdateManyMutationInput, AlumnoUncheckedUpdateManyWithoutEstilosInput>
  }

  export type AlumnoScalarWhereInput = {
    AND?: AlumnoScalarWhereInput | AlumnoScalarWhereInput[]
    OR?: AlumnoScalarWhereInput[]
    NOT?: AlumnoScalarWhereInput | AlumnoScalarWhereInput[]
    id?: IntFilter<"Alumno"> | number
    nombre?: StringFilter<"Alumno"> | string
    apellido?: StringFilter<"Alumno"> | string
    dni?: StringFilter<"Alumno"> | string
    activo?: BoolFilter<"Alumno"> | boolean
    fechaNacimiento?: DateTimeFilter<"Alumno"> | Date | string
    email?: StringNullableFilter<"Alumno"> | string | null
    telefono?: StringNullableFilter<"Alumno"> | string | null
    numeroEmergencia?: StringNullableFilter<"Alumno"> | string | null
    direccion?: StringNullableFilter<"Alumno"> | string | null
    obraSocial?: StringNullableFilter<"Alumno"> | string | null
    nombreTutor?: StringNullableFilter<"Alumno"> | string | null
    dniTutor?: StringNullableFilter<"Alumno"> | string | null
    notas?: StringNullableFilter<"Alumno"> | string | null
    fechaIngreso?: DateTimeFilter<"Alumno"> | Date | string
    fechaBaja?: DateTimeNullableFilter<"Alumno"> | Date | string | null
    motivoBaja?: StringNullableFilter<"Alumno"> | string | null
    createdAt?: DateTimeFilter<"Alumno"> | Date | string
    updatedAt?: DateTimeFilter<"Alumno"> | Date | string
  }

  export type AlumnoCreateWithoutAlumnoEstilosInput = {
    nombre: string
    apellido: string
    dni: string
    activo?: boolean
    fechaNacimiento: Date | string
    email?: string | null
    telefono?: string | null
    numeroEmergencia?: string | null
    direccion?: string | null
    obraSocial?: string | null
    nombreTutor?: string | null
    dniTutor?: string | null
    notas?: string | null
    fechaIngreso?: Date | string
    fechaBaja?: Date | string | null
    motivoBaja?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recibos?: ReciboCreateNestedManyWithoutAlumnoInput
    alumnosSueltosAnteriores?: AlumnoSueltoCreateNestedManyWithoutAlumnoRegularInput
    ctaCte?: CtaCteCreateNestedOneWithoutAlumnoInput
    estilos?: EstiloCreateNestedManyWithoutAlumnosInput
    asistencias?: AsistenciaCreateNestedManyWithoutAlumnoInput
    deudas?: DeudaCreateNestedManyWithoutAlumnoInput
    descuentosVigentes?: DescuentoAplicadoCreateNestedManyWithoutAlumnoInput
    configuracionPago?: ConfiguracionPagoAlumnoCreateNestedOneWithoutAlumnoInput
  }

  export type AlumnoUncheckedCreateWithoutAlumnoEstilosInput = {
    id?: number
    nombre: string
    apellido: string
    dni: string
    activo?: boolean
    fechaNacimiento: Date | string
    email?: string | null
    telefono?: string | null
    numeroEmergencia?: string | null
    direccion?: string | null
    obraSocial?: string | null
    nombreTutor?: string | null
    dniTutor?: string | null
    notas?: string | null
    fechaIngreso?: Date | string
    fechaBaja?: Date | string | null
    motivoBaja?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recibos?: ReciboUncheckedCreateNestedManyWithoutAlumnoInput
    alumnosSueltosAnteriores?: AlumnoSueltoUncheckedCreateNestedManyWithoutAlumnoRegularInput
    ctaCte?: CtaCteUncheckedCreateNestedOneWithoutAlumnoInput
    estilos?: EstiloUncheckedCreateNestedManyWithoutAlumnosInput
    asistencias?: AsistenciaUncheckedCreateNestedManyWithoutAlumnoInput
    deudas?: DeudaUncheckedCreateNestedManyWithoutAlumnoInput
    descuentosVigentes?: DescuentoAplicadoUncheckedCreateNestedManyWithoutAlumnoInput
    configuracionPago?: ConfiguracionPagoAlumnoUncheckedCreateNestedOneWithoutAlumnoInput
  }

  export type AlumnoCreateOrConnectWithoutAlumnoEstilosInput = {
    where: AlumnoWhereUniqueInput
    create: XOR<AlumnoCreateWithoutAlumnoEstilosInput, AlumnoUncheckedCreateWithoutAlumnoEstilosInput>
  }

  export type EstiloCreateWithoutAlumnoEstilosInput = {
    nombre: string
    monto?: number
    descripcion?: string | null
    importe?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deudas?: DeudaCreateNestedManyWithoutEstiloInput
    conceptos?: ConceptoCreateNestedManyWithoutEstiloInput
    clases?: ClaseCreateNestedManyWithoutEstiloInput
    profesor?: ProfesorCreateNestedOneWithoutEstilosInput
    alumnos?: AlumnoCreateNestedManyWithoutEstilosInput
  }

  export type EstiloUncheckedCreateWithoutAlumnoEstilosInput = {
    id?: number
    nombre: string
    monto?: number
    descripcion?: string | null
    importe?: number
    profesorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deudas?: DeudaUncheckedCreateNestedManyWithoutEstiloInput
    conceptos?: ConceptoUncheckedCreateNestedManyWithoutEstiloInput
    clases?: ClaseUncheckedCreateNestedManyWithoutEstiloInput
    alumnos?: AlumnoUncheckedCreateNestedManyWithoutEstilosInput
  }

  export type EstiloCreateOrConnectWithoutAlumnoEstilosInput = {
    where: EstiloWhereUniqueInput
    create: XOR<EstiloCreateWithoutAlumnoEstilosInput, EstiloUncheckedCreateWithoutAlumnoEstilosInput>
  }

  export type AlumnoUpsertWithoutAlumnoEstilosInput = {
    update: XOR<AlumnoUpdateWithoutAlumnoEstilosInput, AlumnoUncheckedUpdateWithoutAlumnoEstilosInput>
    create: XOR<AlumnoCreateWithoutAlumnoEstilosInput, AlumnoUncheckedCreateWithoutAlumnoEstilosInput>
    where?: AlumnoWhereInput
  }

  export type AlumnoUpdateToOneWithWhereWithoutAlumnoEstilosInput = {
    where?: AlumnoWhereInput
    data: XOR<AlumnoUpdateWithoutAlumnoEstilosInput, AlumnoUncheckedUpdateWithoutAlumnoEstilosInput>
  }

  export type AlumnoUpdateWithoutAlumnoEstilosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    numeroEmergencia?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    obraSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nombreTutor?: NullableStringFieldUpdateOperationsInput | string | null
    dniTutor?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoBaja?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibos?: ReciboUpdateManyWithoutAlumnoNestedInput
    alumnosSueltosAnteriores?: AlumnoSueltoUpdateManyWithoutAlumnoRegularNestedInput
    ctaCte?: CtaCteUpdateOneWithoutAlumnoNestedInput
    estilos?: EstiloUpdateManyWithoutAlumnosNestedInput
    asistencias?: AsistenciaUpdateManyWithoutAlumnoNestedInput
    deudas?: DeudaUpdateManyWithoutAlumnoNestedInput
    descuentosVigentes?: DescuentoAplicadoUpdateManyWithoutAlumnoNestedInput
    configuracionPago?: ConfiguracionPagoAlumnoUpdateOneWithoutAlumnoNestedInput
  }

  export type AlumnoUncheckedUpdateWithoutAlumnoEstilosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    numeroEmergencia?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    obraSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nombreTutor?: NullableStringFieldUpdateOperationsInput | string | null
    dniTutor?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoBaja?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibos?: ReciboUncheckedUpdateManyWithoutAlumnoNestedInput
    alumnosSueltosAnteriores?: AlumnoSueltoUncheckedUpdateManyWithoutAlumnoRegularNestedInput
    ctaCte?: CtaCteUncheckedUpdateOneWithoutAlumnoNestedInput
    estilos?: EstiloUncheckedUpdateManyWithoutAlumnosNestedInput
    asistencias?: AsistenciaUncheckedUpdateManyWithoutAlumnoNestedInput
    deudas?: DeudaUncheckedUpdateManyWithoutAlumnoNestedInput
    descuentosVigentes?: DescuentoAplicadoUncheckedUpdateManyWithoutAlumnoNestedInput
    configuracionPago?: ConfiguracionPagoAlumnoUncheckedUpdateOneWithoutAlumnoNestedInput
  }

  export type EstiloUpsertWithoutAlumnoEstilosInput = {
    update: XOR<EstiloUpdateWithoutAlumnoEstilosInput, EstiloUncheckedUpdateWithoutAlumnoEstilosInput>
    create: XOR<EstiloCreateWithoutAlumnoEstilosInput, EstiloUncheckedCreateWithoutAlumnoEstilosInput>
    where?: EstiloWhereInput
  }

  export type EstiloUpdateToOneWithWhereWithoutAlumnoEstilosInput = {
    where?: EstiloWhereInput
    data: XOR<EstiloUpdateWithoutAlumnoEstilosInput, EstiloUncheckedUpdateWithoutAlumnoEstilosInput>
  }

  export type EstiloUpdateWithoutAlumnoEstilosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deudas?: DeudaUpdateManyWithoutEstiloNestedInput
    conceptos?: ConceptoUpdateManyWithoutEstiloNestedInput
    clases?: ClaseUpdateManyWithoutEstiloNestedInput
    profesor?: ProfesorUpdateOneWithoutEstilosNestedInput
    alumnos?: AlumnoUpdateManyWithoutEstilosNestedInput
  }

  export type EstiloUncheckedUpdateWithoutAlumnoEstilosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: FloatFieldUpdateOperationsInput | number
    profesorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deudas?: DeudaUncheckedUpdateManyWithoutEstiloNestedInput
    conceptos?: ConceptoUncheckedUpdateManyWithoutEstiloNestedInput
    clases?: ClaseUncheckedUpdateManyWithoutEstiloNestedInput
    alumnos?: AlumnoUncheckedUpdateManyWithoutEstilosNestedInput
  }

  export type ClaseCreateWithoutProfesorInput = {
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    estilo: EstiloCreateNestedOneWithoutClasesInput
    asistencias?: AsistenciaCreateNestedManyWithoutClaseInput
    alumnosSueltos?: AlumnoSueltoCreateNestedManyWithoutClasesInput
    recibos?: ReciboCreateNestedManyWithoutClaseInput
  }

  export type ClaseUncheckedCreateWithoutProfesorInput = {
    id?: number
    fecha?: Date | string
    estiloId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    asistencias?: AsistenciaUncheckedCreateNestedManyWithoutClaseInput
    alumnosSueltos?: AlumnoSueltoUncheckedCreateNestedManyWithoutClasesInput
    recibos?: ReciboUncheckedCreateNestedManyWithoutClaseInput
  }

  export type ClaseCreateOrConnectWithoutProfesorInput = {
    where: ClaseWhereUniqueInput
    create: XOR<ClaseCreateWithoutProfesorInput, ClaseUncheckedCreateWithoutProfesorInput>
  }

  export type ClaseCreateManyProfesorInputEnvelope = {
    data: ClaseCreateManyProfesorInput | ClaseCreateManyProfesorInput[]
    skipDuplicates?: boolean
  }

  export type EstiloCreateWithoutProfesorInput = {
    nombre: string
    monto?: number
    descripcion?: string | null
    importe?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deudas?: DeudaCreateNestedManyWithoutEstiloInput
    conceptos?: ConceptoCreateNestedManyWithoutEstiloInput
    clases?: ClaseCreateNestedManyWithoutEstiloInput
    alumnoEstilos?: AlumnoEstilosCreateNestedManyWithoutEstiloInput
    alumnos?: AlumnoCreateNestedManyWithoutEstilosInput
  }

  export type EstiloUncheckedCreateWithoutProfesorInput = {
    id?: number
    nombre: string
    monto?: number
    descripcion?: string | null
    importe?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deudas?: DeudaUncheckedCreateNestedManyWithoutEstiloInput
    conceptos?: ConceptoUncheckedCreateNestedManyWithoutEstiloInput
    clases?: ClaseUncheckedCreateNestedManyWithoutEstiloInput
    alumnoEstilos?: AlumnoEstilosUncheckedCreateNestedManyWithoutEstiloInput
    alumnos?: AlumnoUncheckedCreateNestedManyWithoutEstilosInput
  }

  export type EstiloCreateOrConnectWithoutProfesorInput = {
    where: EstiloWhereUniqueInput
    create: XOR<EstiloCreateWithoutProfesorInput, EstiloUncheckedCreateWithoutProfesorInput>
  }

  export type EstiloCreateManyProfesorInputEnvelope = {
    data: EstiloCreateManyProfesorInput | EstiloCreateManyProfesorInput[]
    skipDuplicates?: boolean
  }

  export type LiquidacionCreateWithoutProfesorInput = {
    fecha?: Date | string
    mes: number
    anio: number
    montoTotal: number
    montoCursos: number
    montoClasesSueltas: number
    porcentajeCursos?: number
    porcentajeClasesSueltas?: number
    estado?: $Enums.EstadoLiquidacion
    metodoPago?: $Enums.TipoPago | null
    fechaPago?: Date | string | null
    observaciones?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    detalles?: DetalleLiquidacionCreateNestedManyWithoutLiquidacionInput
  }

  export type LiquidacionUncheckedCreateWithoutProfesorInput = {
    id?: number
    fecha?: Date | string
    mes: number
    anio: number
    montoTotal: number
    montoCursos: number
    montoClasesSueltas: number
    porcentajeCursos?: number
    porcentajeClasesSueltas?: number
    estado?: $Enums.EstadoLiquidacion
    metodoPago?: $Enums.TipoPago | null
    fechaPago?: Date | string | null
    observaciones?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    detalles?: DetalleLiquidacionUncheckedCreateNestedManyWithoutLiquidacionInput
  }

  export type LiquidacionCreateOrConnectWithoutProfesorInput = {
    where: LiquidacionWhereUniqueInput
    create: XOR<LiquidacionCreateWithoutProfesorInput, LiquidacionUncheckedCreateWithoutProfesorInput>
  }

  export type LiquidacionCreateManyProfesorInputEnvelope = {
    data: LiquidacionCreateManyProfesorInput | LiquidacionCreateManyProfesorInput[]
    skipDuplicates?: boolean
  }

  export type ClaseUpsertWithWhereUniqueWithoutProfesorInput = {
    where: ClaseWhereUniqueInput
    update: XOR<ClaseUpdateWithoutProfesorInput, ClaseUncheckedUpdateWithoutProfesorInput>
    create: XOR<ClaseCreateWithoutProfesorInput, ClaseUncheckedCreateWithoutProfesorInput>
  }

  export type ClaseUpdateWithWhereUniqueWithoutProfesorInput = {
    where: ClaseWhereUniqueInput
    data: XOR<ClaseUpdateWithoutProfesorInput, ClaseUncheckedUpdateWithoutProfesorInput>
  }

  export type ClaseUpdateManyWithWhereWithoutProfesorInput = {
    where: ClaseScalarWhereInput
    data: XOR<ClaseUpdateManyMutationInput, ClaseUncheckedUpdateManyWithoutProfesorInput>
  }

  export type EstiloUpsertWithWhereUniqueWithoutProfesorInput = {
    where: EstiloWhereUniqueInput
    update: XOR<EstiloUpdateWithoutProfesorInput, EstiloUncheckedUpdateWithoutProfesorInput>
    create: XOR<EstiloCreateWithoutProfesorInput, EstiloUncheckedCreateWithoutProfesorInput>
  }

  export type EstiloUpdateWithWhereUniqueWithoutProfesorInput = {
    where: EstiloWhereUniqueInput
    data: XOR<EstiloUpdateWithoutProfesorInput, EstiloUncheckedUpdateWithoutProfesorInput>
  }

  export type EstiloUpdateManyWithWhereWithoutProfesorInput = {
    where: EstiloScalarWhereInput
    data: XOR<EstiloUpdateManyMutationInput, EstiloUncheckedUpdateManyWithoutProfesorInput>
  }

  export type LiquidacionUpsertWithWhereUniqueWithoutProfesorInput = {
    where: LiquidacionWhereUniqueInput
    update: XOR<LiquidacionUpdateWithoutProfesorInput, LiquidacionUncheckedUpdateWithoutProfesorInput>
    create: XOR<LiquidacionCreateWithoutProfesorInput, LiquidacionUncheckedCreateWithoutProfesorInput>
  }

  export type LiquidacionUpdateWithWhereUniqueWithoutProfesorInput = {
    where: LiquidacionWhereUniqueInput
    data: XOR<LiquidacionUpdateWithoutProfesorInput, LiquidacionUncheckedUpdateWithoutProfesorInput>
  }

  export type LiquidacionUpdateManyWithWhereWithoutProfesorInput = {
    where: LiquidacionScalarWhereInput
    data: XOR<LiquidacionUpdateManyMutationInput, LiquidacionUncheckedUpdateManyWithoutProfesorInput>
  }

  export type LiquidacionScalarWhereInput = {
    AND?: LiquidacionScalarWhereInput | LiquidacionScalarWhereInput[]
    OR?: LiquidacionScalarWhereInput[]
    NOT?: LiquidacionScalarWhereInput | LiquidacionScalarWhereInput[]
    id?: IntFilter<"Liquidacion"> | number
    fecha?: DateTimeFilter<"Liquidacion"> | Date | string
    mes?: IntFilter<"Liquidacion"> | number
    anio?: IntFilter<"Liquidacion"> | number
    profesorId?: IntNullableFilter<"Liquidacion"> | number | null
    montoTotal?: FloatFilter<"Liquidacion"> | number
    montoCursos?: FloatFilter<"Liquidacion"> | number
    montoClasesSueltas?: FloatFilter<"Liquidacion"> | number
    porcentajeCursos?: FloatFilter<"Liquidacion"> | number
    porcentajeClasesSueltas?: FloatFilter<"Liquidacion"> | number
    estado?: EnumEstadoLiquidacionFilter<"Liquidacion"> | $Enums.EstadoLiquidacion
    metodoPago?: EnumTipoPagoNullableFilter<"Liquidacion"> | $Enums.TipoPago | null
    fechaPago?: DateTimeNullableFilter<"Liquidacion"> | Date | string | null
    observaciones?: StringNullableFilter<"Liquidacion"> | string | null
    createdAt?: DateTimeFilter<"Liquidacion"> | Date | string
    updatedAt?: DateTimeFilter<"Liquidacion"> | Date | string
  }

  export type AlumnoCreateWithoutCtaCteInput = {
    nombre: string
    apellido: string
    dni: string
    activo?: boolean
    fechaNacimiento: Date | string
    email?: string | null
    telefono?: string | null
    numeroEmergencia?: string | null
    direccion?: string | null
    obraSocial?: string | null
    nombreTutor?: string | null
    dniTutor?: string | null
    notas?: string | null
    fechaIngreso?: Date | string
    fechaBaja?: Date | string | null
    motivoBaja?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recibos?: ReciboCreateNestedManyWithoutAlumnoInput
    alumnosSueltosAnteriores?: AlumnoSueltoCreateNestedManyWithoutAlumnoRegularInput
    estilos?: EstiloCreateNestedManyWithoutAlumnosInput
    asistencias?: AsistenciaCreateNestedManyWithoutAlumnoInput
    alumnoEstilos?: AlumnoEstilosCreateNestedManyWithoutAlumnoInput
    deudas?: DeudaCreateNestedManyWithoutAlumnoInput
    descuentosVigentes?: DescuentoAplicadoCreateNestedManyWithoutAlumnoInput
    configuracionPago?: ConfiguracionPagoAlumnoCreateNestedOneWithoutAlumnoInput
  }

  export type AlumnoUncheckedCreateWithoutCtaCteInput = {
    id?: number
    nombre: string
    apellido: string
    dni: string
    activo?: boolean
    fechaNacimiento: Date | string
    email?: string | null
    telefono?: string | null
    numeroEmergencia?: string | null
    direccion?: string | null
    obraSocial?: string | null
    nombreTutor?: string | null
    dniTutor?: string | null
    notas?: string | null
    fechaIngreso?: Date | string
    fechaBaja?: Date | string | null
    motivoBaja?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recibos?: ReciboUncheckedCreateNestedManyWithoutAlumnoInput
    alumnosSueltosAnteriores?: AlumnoSueltoUncheckedCreateNestedManyWithoutAlumnoRegularInput
    estilos?: EstiloUncheckedCreateNestedManyWithoutAlumnosInput
    asistencias?: AsistenciaUncheckedCreateNestedManyWithoutAlumnoInput
    alumnoEstilos?: AlumnoEstilosUncheckedCreateNestedManyWithoutAlumnoInput
    deudas?: DeudaUncheckedCreateNestedManyWithoutAlumnoInput
    descuentosVigentes?: DescuentoAplicadoUncheckedCreateNestedManyWithoutAlumnoInput
    configuracionPago?: ConfiguracionPagoAlumnoUncheckedCreateNestedOneWithoutAlumnoInput
  }

  export type AlumnoCreateOrConnectWithoutCtaCteInput = {
    where: AlumnoWhereUniqueInput
    create: XOR<AlumnoCreateWithoutCtaCteInput, AlumnoUncheckedCreateWithoutCtaCteInput>
  }

  export type AlumnoUpsertWithoutCtaCteInput = {
    update: XOR<AlumnoUpdateWithoutCtaCteInput, AlumnoUncheckedUpdateWithoutCtaCteInput>
    create: XOR<AlumnoCreateWithoutCtaCteInput, AlumnoUncheckedCreateWithoutCtaCteInput>
    where?: AlumnoWhereInput
  }

  export type AlumnoUpdateToOneWithWhereWithoutCtaCteInput = {
    where?: AlumnoWhereInput
    data: XOR<AlumnoUpdateWithoutCtaCteInput, AlumnoUncheckedUpdateWithoutCtaCteInput>
  }

  export type AlumnoUpdateWithoutCtaCteInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    numeroEmergencia?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    obraSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nombreTutor?: NullableStringFieldUpdateOperationsInput | string | null
    dniTutor?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoBaja?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibos?: ReciboUpdateManyWithoutAlumnoNestedInput
    alumnosSueltosAnteriores?: AlumnoSueltoUpdateManyWithoutAlumnoRegularNestedInput
    estilos?: EstiloUpdateManyWithoutAlumnosNestedInput
    asistencias?: AsistenciaUpdateManyWithoutAlumnoNestedInput
    alumnoEstilos?: AlumnoEstilosUpdateManyWithoutAlumnoNestedInput
    deudas?: DeudaUpdateManyWithoutAlumnoNestedInput
    descuentosVigentes?: DescuentoAplicadoUpdateManyWithoutAlumnoNestedInput
    configuracionPago?: ConfiguracionPagoAlumnoUpdateOneWithoutAlumnoNestedInput
  }

  export type AlumnoUncheckedUpdateWithoutCtaCteInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    numeroEmergencia?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    obraSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nombreTutor?: NullableStringFieldUpdateOperationsInput | string | null
    dniTutor?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoBaja?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibos?: ReciboUncheckedUpdateManyWithoutAlumnoNestedInput
    alumnosSueltosAnteriores?: AlumnoSueltoUncheckedUpdateManyWithoutAlumnoRegularNestedInput
    estilos?: EstiloUncheckedUpdateManyWithoutAlumnosNestedInput
    asistencias?: AsistenciaUncheckedUpdateManyWithoutAlumnoNestedInput
    alumnoEstilos?: AlumnoEstilosUncheckedUpdateManyWithoutAlumnoNestedInput
    deudas?: DeudaUncheckedUpdateManyWithoutAlumnoNestedInput
    descuentosVigentes?: DescuentoAplicadoUncheckedUpdateManyWithoutAlumnoNestedInput
    configuracionPago?: ConfiguracionPagoAlumnoUncheckedUpdateOneWithoutAlumnoNestedInput
  }

  export type ProfesorCreateWithoutClasesInput = {
    nombre: string
    apellido: string
    dni: string
    fechaNacimiento?: Date | string | null
    direccion?: string | null
    cuit?: string | null
    email?: string | null
    telefono?: string | null
    fechaIngreso?: Date | string
    porcentajePorDefecto?: number
    porcentajeClasesSueltasPorDefecto?: number
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    estilos?: EstiloCreateNestedManyWithoutProfesorInput
    liquidaciones?: LiquidacionCreateNestedManyWithoutProfesorInput
  }

  export type ProfesorUncheckedCreateWithoutClasesInput = {
    id?: number
    nombre: string
    apellido: string
    dni: string
    fechaNacimiento?: Date | string | null
    direccion?: string | null
    cuit?: string | null
    email?: string | null
    telefono?: string | null
    fechaIngreso?: Date | string
    porcentajePorDefecto?: number
    porcentajeClasesSueltasPorDefecto?: number
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    estilos?: EstiloUncheckedCreateNestedManyWithoutProfesorInput
    liquidaciones?: LiquidacionUncheckedCreateNestedManyWithoutProfesorInput
  }

  export type ProfesorCreateOrConnectWithoutClasesInput = {
    where: ProfesorWhereUniqueInput
    create: XOR<ProfesorCreateWithoutClasesInput, ProfesorUncheckedCreateWithoutClasesInput>
  }

  export type EstiloCreateWithoutClasesInput = {
    nombre: string
    monto?: number
    descripcion?: string | null
    importe?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deudas?: DeudaCreateNestedManyWithoutEstiloInput
    conceptos?: ConceptoCreateNestedManyWithoutEstiloInput
    alumnoEstilos?: AlumnoEstilosCreateNestedManyWithoutEstiloInput
    profesor?: ProfesorCreateNestedOneWithoutEstilosInput
    alumnos?: AlumnoCreateNestedManyWithoutEstilosInput
  }

  export type EstiloUncheckedCreateWithoutClasesInput = {
    id?: number
    nombre: string
    monto?: number
    descripcion?: string | null
    importe?: number
    profesorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deudas?: DeudaUncheckedCreateNestedManyWithoutEstiloInput
    conceptos?: ConceptoUncheckedCreateNestedManyWithoutEstiloInput
    alumnoEstilos?: AlumnoEstilosUncheckedCreateNestedManyWithoutEstiloInput
    alumnos?: AlumnoUncheckedCreateNestedManyWithoutEstilosInput
  }

  export type EstiloCreateOrConnectWithoutClasesInput = {
    where: EstiloWhereUniqueInput
    create: XOR<EstiloCreateWithoutClasesInput, EstiloUncheckedCreateWithoutClasesInput>
  }

  export type AsistenciaCreateWithoutClaseInput = {
    asistio: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    alumno: AlumnoCreateNestedOneWithoutAsistenciasInput
  }

  export type AsistenciaUncheckedCreateWithoutClaseInput = {
    id?: number
    alumnoId: number
    asistio: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AsistenciaCreateOrConnectWithoutClaseInput = {
    where: AsistenciaWhereUniqueInput
    create: XOR<AsistenciaCreateWithoutClaseInput, AsistenciaUncheckedCreateWithoutClaseInput>
  }

  export type AsistenciaCreateManyClaseInputEnvelope = {
    data: AsistenciaCreateManyClaseInput | AsistenciaCreateManyClaseInput[]
    skipDuplicates?: boolean
  }

  export type AlumnoSueltoCreateWithoutClasesInput = {
    nombre: string
    apellido: string
    dni: string
    telefono?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recibos?: ReciboCreateNestedManyWithoutAlumnoSueltoInput
    alumnoRegular?: AlumnoCreateNestedOneWithoutAlumnosSueltosAnterioresInput
  }

  export type AlumnoSueltoUncheckedCreateWithoutClasesInput = {
    id?: number
    nombre: string
    apellido: string
    dni: string
    telefono?: string | null
    email?: string | null
    alumnoRegularId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recibos?: ReciboUncheckedCreateNestedManyWithoutAlumnoSueltoInput
  }

  export type AlumnoSueltoCreateOrConnectWithoutClasesInput = {
    where: AlumnoSueltoWhereUniqueInput
    create: XOR<AlumnoSueltoCreateWithoutClasesInput, AlumnoSueltoUncheckedCreateWithoutClasesInput>
  }

  export type ReciboCreateWithoutClaseInput = {
    numeroRecibo?: number
    fecha?: Date | string
    fechaEfecto?: Date | string
    monto: number
    montoOriginal: number
    descuento?: number | null
    periodoPago: string
    tipoPago: $Enums.TipoPago
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    anulado?: boolean
    motivoAnulacion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alumno?: AlumnoCreateNestedOneWithoutRecibosInput
    alumnoSuelto?: AlumnoSueltoCreateNestedOneWithoutRecibosInput
    concepto: ConceptoCreateNestedOneWithoutRecibosInput
    pagosDeuda?: PagoDeudaCreateNestedManyWithoutReciboInput
    detallesLiquidacion?: DetalleLiquidacionCreateNestedManyWithoutReciboInput
    reciboAnulado?: ReciboCreateNestedOneWithoutRecibosAnuladosInput
    recibosAnulados?: ReciboCreateNestedManyWithoutReciboAnuladoInput
  }

  export type ReciboUncheckedCreateWithoutClaseInput = {
    id?: number
    numeroRecibo?: number
    fecha?: Date | string
    fechaEfecto?: Date | string
    monto: number
    montoOriginal: number
    descuento?: number | null
    periodoPago: string
    tipoPago: $Enums.TipoPago
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    alumnoId?: number | null
    alumnoSueltoId?: number | null
    conceptoId: number
    anulado?: boolean
    motivoAnulacion?: string | null
    referenciaRecibo?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pagosDeuda?: PagoDeudaUncheckedCreateNestedManyWithoutReciboInput
    detallesLiquidacion?: DetalleLiquidacionUncheckedCreateNestedManyWithoutReciboInput
    recibosAnulados?: ReciboUncheckedCreateNestedManyWithoutReciboAnuladoInput
  }

  export type ReciboCreateOrConnectWithoutClaseInput = {
    where: ReciboWhereUniqueInput
    create: XOR<ReciboCreateWithoutClaseInput, ReciboUncheckedCreateWithoutClaseInput>
  }

  export type ReciboCreateManyClaseInputEnvelope = {
    data: ReciboCreateManyClaseInput | ReciboCreateManyClaseInput[]
    skipDuplicates?: boolean
  }

  export type ProfesorUpsertWithoutClasesInput = {
    update: XOR<ProfesorUpdateWithoutClasesInput, ProfesorUncheckedUpdateWithoutClasesInput>
    create: XOR<ProfesorCreateWithoutClasesInput, ProfesorUncheckedCreateWithoutClasesInput>
    where?: ProfesorWhereInput
  }

  export type ProfesorUpdateToOneWithWhereWithoutClasesInput = {
    where?: ProfesorWhereInput
    data: XOR<ProfesorUpdateWithoutClasesInput, ProfesorUncheckedUpdateWithoutClasesInput>
  }

  export type ProfesorUpdateWithoutClasesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    porcentajePorDefecto?: FloatFieldUpdateOperationsInput | number
    porcentajeClasesSueltasPorDefecto?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estilos?: EstiloUpdateManyWithoutProfesorNestedInput
    liquidaciones?: LiquidacionUpdateManyWithoutProfesorNestedInput
  }

  export type ProfesorUncheckedUpdateWithoutClasesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    porcentajePorDefecto?: FloatFieldUpdateOperationsInput | number
    porcentajeClasesSueltasPorDefecto?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estilos?: EstiloUncheckedUpdateManyWithoutProfesorNestedInput
    liquidaciones?: LiquidacionUncheckedUpdateManyWithoutProfesorNestedInput
  }

  export type EstiloUpsertWithoutClasesInput = {
    update: XOR<EstiloUpdateWithoutClasesInput, EstiloUncheckedUpdateWithoutClasesInput>
    create: XOR<EstiloCreateWithoutClasesInput, EstiloUncheckedCreateWithoutClasesInput>
    where?: EstiloWhereInput
  }

  export type EstiloUpdateToOneWithWhereWithoutClasesInput = {
    where?: EstiloWhereInput
    data: XOR<EstiloUpdateWithoutClasesInput, EstiloUncheckedUpdateWithoutClasesInput>
  }

  export type EstiloUpdateWithoutClasesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deudas?: DeudaUpdateManyWithoutEstiloNestedInput
    conceptos?: ConceptoUpdateManyWithoutEstiloNestedInput
    alumnoEstilos?: AlumnoEstilosUpdateManyWithoutEstiloNestedInput
    profesor?: ProfesorUpdateOneWithoutEstilosNestedInput
    alumnos?: AlumnoUpdateManyWithoutEstilosNestedInput
  }

  export type EstiloUncheckedUpdateWithoutClasesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: FloatFieldUpdateOperationsInput | number
    profesorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deudas?: DeudaUncheckedUpdateManyWithoutEstiloNestedInput
    conceptos?: ConceptoUncheckedUpdateManyWithoutEstiloNestedInput
    alumnoEstilos?: AlumnoEstilosUncheckedUpdateManyWithoutEstiloNestedInput
    alumnos?: AlumnoUncheckedUpdateManyWithoutEstilosNestedInput
  }

  export type AsistenciaUpsertWithWhereUniqueWithoutClaseInput = {
    where: AsistenciaWhereUniqueInput
    update: XOR<AsistenciaUpdateWithoutClaseInput, AsistenciaUncheckedUpdateWithoutClaseInput>
    create: XOR<AsistenciaCreateWithoutClaseInput, AsistenciaUncheckedCreateWithoutClaseInput>
  }

  export type AsistenciaUpdateWithWhereUniqueWithoutClaseInput = {
    where: AsistenciaWhereUniqueInput
    data: XOR<AsistenciaUpdateWithoutClaseInput, AsistenciaUncheckedUpdateWithoutClaseInput>
  }

  export type AsistenciaUpdateManyWithWhereWithoutClaseInput = {
    where: AsistenciaScalarWhereInput
    data: XOR<AsistenciaUpdateManyMutationInput, AsistenciaUncheckedUpdateManyWithoutClaseInput>
  }

  export type AlumnoSueltoUpsertWithWhereUniqueWithoutClasesInput = {
    where: AlumnoSueltoWhereUniqueInput
    update: XOR<AlumnoSueltoUpdateWithoutClasesInput, AlumnoSueltoUncheckedUpdateWithoutClasesInput>
    create: XOR<AlumnoSueltoCreateWithoutClasesInput, AlumnoSueltoUncheckedCreateWithoutClasesInput>
  }

  export type AlumnoSueltoUpdateWithWhereUniqueWithoutClasesInput = {
    where: AlumnoSueltoWhereUniqueInput
    data: XOR<AlumnoSueltoUpdateWithoutClasesInput, AlumnoSueltoUncheckedUpdateWithoutClasesInput>
  }

  export type AlumnoSueltoUpdateManyWithWhereWithoutClasesInput = {
    where: AlumnoSueltoScalarWhereInput
    data: XOR<AlumnoSueltoUpdateManyMutationInput, AlumnoSueltoUncheckedUpdateManyWithoutClasesInput>
  }

  export type ReciboUpsertWithWhereUniqueWithoutClaseInput = {
    where: ReciboWhereUniqueInput
    update: XOR<ReciboUpdateWithoutClaseInput, ReciboUncheckedUpdateWithoutClaseInput>
    create: XOR<ReciboCreateWithoutClaseInput, ReciboUncheckedCreateWithoutClaseInput>
  }

  export type ReciboUpdateWithWhereUniqueWithoutClaseInput = {
    where: ReciboWhereUniqueInput
    data: XOR<ReciboUpdateWithoutClaseInput, ReciboUncheckedUpdateWithoutClaseInput>
  }

  export type ReciboUpdateManyWithWhereWithoutClaseInput = {
    where: ReciboScalarWhereInput
    data: XOR<ReciboUpdateManyMutationInput, ReciboUncheckedUpdateManyWithoutClaseInput>
  }

  export type ClaseCreateWithoutAsistenciasInput = {
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    profesor: ProfesorCreateNestedOneWithoutClasesInput
    estilo: EstiloCreateNestedOneWithoutClasesInput
    alumnosSueltos?: AlumnoSueltoCreateNestedManyWithoutClasesInput
    recibos?: ReciboCreateNestedManyWithoutClaseInput
  }

  export type ClaseUncheckedCreateWithoutAsistenciasInput = {
    id?: number
    fecha?: Date | string
    profesorId: number
    estiloId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    alumnosSueltos?: AlumnoSueltoUncheckedCreateNestedManyWithoutClasesInput
    recibos?: ReciboUncheckedCreateNestedManyWithoutClaseInput
  }

  export type ClaseCreateOrConnectWithoutAsistenciasInput = {
    where: ClaseWhereUniqueInput
    create: XOR<ClaseCreateWithoutAsistenciasInput, ClaseUncheckedCreateWithoutAsistenciasInput>
  }

  export type AlumnoCreateWithoutAsistenciasInput = {
    nombre: string
    apellido: string
    dni: string
    activo?: boolean
    fechaNacimiento: Date | string
    email?: string | null
    telefono?: string | null
    numeroEmergencia?: string | null
    direccion?: string | null
    obraSocial?: string | null
    nombreTutor?: string | null
    dniTutor?: string | null
    notas?: string | null
    fechaIngreso?: Date | string
    fechaBaja?: Date | string | null
    motivoBaja?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recibos?: ReciboCreateNestedManyWithoutAlumnoInput
    alumnosSueltosAnteriores?: AlumnoSueltoCreateNestedManyWithoutAlumnoRegularInput
    ctaCte?: CtaCteCreateNestedOneWithoutAlumnoInput
    estilos?: EstiloCreateNestedManyWithoutAlumnosInput
    alumnoEstilos?: AlumnoEstilosCreateNestedManyWithoutAlumnoInput
    deudas?: DeudaCreateNestedManyWithoutAlumnoInput
    descuentosVigentes?: DescuentoAplicadoCreateNestedManyWithoutAlumnoInput
    configuracionPago?: ConfiguracionPagoAlumnoCreateNestedOneWithoutAlumnoInput
  }

  export type AlumnoUncheckedCreateWithoutAsistenciasInput = {
    id?: number
    nombre: string
    apellido: string
    dni: string
    activo?: boolean
    fechaNacimiento: Date | string
    email?: string | null
    telefono?: string | null
    numeroEmergencia?: string | null
    direccion?: string | null
    obraSocial?: string | null
    nombreTutor?: string | null
    dniTutor?: string | null
    notas?: string | null
    fechaIngreso?: Date | string
    fechaBaja?: Date | string | null
    motivoBaja?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recibos?: ReciboUncheckedCreateNestedManyWithoutAlumnoInput
    alumnosSueltosAnteriores?: AlumnoSueltoUncheckedCreateNestedManyWithoutAlumnoRegularInput
    ctaCte?: CtaCteUncheckedCreateNestedOneWithoutAlumnoInput
    estilos?: EstiloUncheckedCreateNestedManyWithoutAlumnosInput
    alumnoEstilos?: AlumnoEstilosUncheckedCreateNestedManyWithoutAlumnoInput
    deudas?: DeudaUncheckedCreateNestedManyWithoutAlumnoInput
    descuentosVigentes?: DescuentoAplicadoUncheckedCreateNestedManyWithoutAlumnoInput
    configuracionPago?: ConfiguracionPagoAlumnoUncheckedCreateNestedOneWithoutAlumnoInput
  }

  export type AlumnoCreateOrConnectWithoutAsistenciasInput = {
    where: AlumnoWhereUniqueInput
    create: XOR<AlumnoCreateWithoutAsistenciasInput, AlumnoUncheckedCreateWithoutAsistenciasInput>
  }

  export type ClaseUpsertWithoutAsistenciasInput = {
    update: XOR<ClaseUpdateWithoutAsistenciasInput, ClaseUncheckedUpdateWithoutAsistenciasInput>
    create: XOR<ClaseCreateWithoutAsistenciasInput, ClaseUncheckedCreateWithoutAsistenciasInput>
    where?: ClaseWhereInput
  }

  export type ClaseUpdateToOneWithWhereWithoutAsistenciasInput = {
    where?: ClaseWhereInput
    data: XOR<ClaseUpdateWithoutAsistenciasInput, ClaseUncheckedUpdateWithoutAsistenciasInput>
  }

  export type ClaseUpdateWithoutAsistenciasInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profesor?: ProfesorUpdateOneRequiredWithoutClasesNestedInput
    estilo?: EstiloUpdateOneRequiredWithoutClasesNestedInput
    alumnosSueltos?: AlumnoSueltoUpdateManyWithoutClasesNestedInput
    recibos?: ReciboUpdateManyWithoutClaseNestedInput
  }

  export type ClaseUncheckedUpdateWithoutAsistenciasInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    profesorId?: IntFieldUpdateOperationsInput | number
    estiloId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alumnosSueltos?: AlumnoSueltoUncheckedUpdateManyWithoutClasesNestedInput
    recibos?: ReciboUncheckedUpdateManyWithoutClaseNestedInput
  }

  export type AlumnoUpsertWithoutAsistenciasInput = {
    update: XOR<AlumnoUpdateWithoutAsistenciasInput, AlumnoUncheckedUpdateWithoutAsistenciasInput>
    create: XOR<AlumnoCreateWithoutAsistenciasInput, AlumnoUncheckedCreateWithoutAsistenciasInput>
    where?: AlumnoWhereInput
  }

  export type AlumnoUpdateToOneWithWhereWithoutAsistenciasInput = {
    where?: AlumnoWhereInput
    data: XOR<AlumnoUpdateWithoutAsistenciasInput, AlumnoUncheckedUpdateWithoutAsistenciasInput>
  }

  export type AlumnoUpdateWithoutAsistenciasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    numeroEmergencia?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    obraSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nombreTutor?: NullableStringFieldUpdateOperationsInput | string | null
    dniTutor?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoBaja?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibos?: ReciboUpdateManyWithoutAlumnoNestedInput
    alumnosSueltosAnteriores?: AlumnoSueltoUpdateManyWithoutAlumnoRegularNestedInput
    ctaCte?: CtaCteUpdateOneWithoutAlumnoNestedInput
    estilos?: EstiloUpdateManyWithoutAlumnosNestedInput
    alumnoEstilos?: AlumnoEstilosUpdateManyWithoutAlumnoNestedInput
    deudas?: DeudaUpdateManyWithoutAlumnoNestedInput
    descuentosVigentes?: DescuentoAplicadoUpdateManyWithoutAlumnoNestedInput
    configuracionPago?: ConfiguracionPagoAlumnoUpdateOneWithoutAlumnoNestedInput
  }

  export type AlumnoUncheckedUpdateWithoutAsistenciasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    numeroEmergencia?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    obraSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nombreTutor?: NullableStringFieldUpdateOperationsInput | string | null
    dniTutor?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoBaja?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibos?: ReciboUncheckedUpdateManyWithoutAlumnoNestedInput
    alumnosSueltosAnteriores?: AlumnoSueltoUncheckedUpdateManyWithoutAlumnoRegularNestedInput
    ctaCte?: CtaCteUncheckedUpdateOneWithoutAlumnoNestedInput
    estilos?: EstiloUncheckedUpdateManyWithoutAlumnosNestedInput
    alumnoEstilos?: AlumnoEstilosUncheckedUpdateManyWithoutAlumnoNestedInput
    deudas?: DeudaUncheckedUpdateManyWithoutAlumnoNestedInput
    descuentosVigentes?: DescuentoAplicadoUncheckedUpdateManyWithoutAlumnoNestedInput
    configuracionPago?: ConfiguracionPagoAlumnoUncheckedUpdateOneWithoutAlumnoNestedInput
  }

  export type ReciboCreateWithoutAlumnoSueltoInput = {
    numeroRecibo?: number
    fecha?: Date | string
    fechaEfecto?: Date | string
    monto: number
    montoOriginal: number
    descuento?: number | null
    periodoPago: string
    tipoPago: $Enums.TipoPago
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    anulado?: boolean
    motivoAnulacion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alumno?: AlumnoCreateNestedOneWithoutRecibosInput
    concepto: ConceptoCreateNestedOneWithoutRecibosInput
    pagosDeuda?: PagoDeudaCreateNestedManyWithoutReciboInput
    detallesLiquidacion?: DetalleLiquidacionCreateNestedManyWithoutReciboInput
    clase?: ClaseCreateNestedOneWithoutRecibosInput
    reciboAnulado?: ReciboCreateNestedOneWithoutRecibosAnuladosInput
    recibosAnulados?: ReciboCreateNestedManyWithoutReciboAnuladoInput
  }

  export type ReciboUncheckedCreateWithoutAlumnoSueltoInput = {
    id?: number
    numeroRecibo?: number
    fecha?: Date | string
    fechaEfecto?: Date | string
    monto: number
    montoOriginal: number
    descuento?: number | null
    periodoPago: string
    tipoPago: $Enums.TipoPago
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    alumnoId?: number | null
    conceptoId: number
    claseId?: number | null
    anulado?: boolean
    motivoAnulacion?: string | null
    referenciaRecibo?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pagosDeuda?: PagoDeudaUncheckedCreateNestedManyWithoutReciboInput
    detallesLiquidacion?: DetalleLiquidacionUncheckedCreateNestedManyWithoutReciboInput
    recibosAnulados?: ReciboUncheckedCreateNestedManyWithoutReciboAnuladoInput
  }

  export type ReciboCreateOrConnectWithoutAlumnoSueltoInput = {
    where: ReciboWhereUniqueInput
    create: XOR<ReciboCreateWithoutAlumnoSueltoInput, ReciboUncheckedCreateWithoutAlumnoSueltoInput>
  }

  export type ReciboCreateManyAlumnoSueltoInputEnvelope = {
    data: ReciboCreateManyAlumnoSueltoInput | ReciboCreateManyAlumnoSueltoInput[]
    skipDuplicates?: boolean
  }

  export type ClaseCreateWithoutAlumnosSueltosInput = {
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    profesor: ProfesorCreateNestedOneWithoutClasesInput
    estilo: EstiloCreateNestedOneWithoutClasesInput
    asistencias?: AsistenciaCreateNestedManyWithoutClaseInput
    recibos?: ReciboCreateNestedManyWithoutClaseInput
  }

  export type ClaseUncheckedCreateWithoutAlumnosSueltosInput = {
    id?: number
    fecha?: Date | string
    profesorId: number
    estiloId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    asistencias?: AsistenciaUncheckedCreateNestedManyWithoutClaseInput
    recibos?: ReciboUncheckedCreateNestedManyWithoutClaseInput
  }

  export type ClaseCreateOrConnectWithoutAlumnosSueltosInput = {
    where: ClaseWhereUniqueInput
    create: XOR<ClaseCreateWithoutAlumnosSueltosInput, ClaseUncheckedCreateWithoutAlumnosSueltosInput>
  }

  export type AlumnoCreateWithoutAlumnosSueltosAnterioresInput = {
    nombre: string
    apellido: string
    dni: string
    activo?: boolean
    fechaNacimiento: Date | string
    email?: string | null
    telefono?: string | null
    numeroEmergencia?: string | null
    direccion?: string | null
    obraSocial?: string | null
    nombreTutor?: string | null
    dniTutor?: string | null
    notas?: string | null
    fechaIngreso?: Date | string
    fechaBaja?: Date | string | null
    motivoBaja?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recibos?: ReciboCreateNestedManyWithoutAlumnoInput
    ctaCte?: CtaCteCreateNestedOneWithoutAlumnoInput
    estilos?: EstiloCreateNestedManyWithoutAlumnosInput
    asistencias?: AsistenciaCreateNestedManyWithoutAlumnoInput
    alumnoEstilos?: AlumnoEstilosCreateNestedManyWithoutAlumnoInput
    deudas?: DeudaCreateNestedManyWithoutAlumnoInput
    descuentosVigentes?: DescuentoAplicadoCreateNestedManyWithoutAlumnoInput
    configuracionPago?: ConfiguracionPagoAlumnoCreateNestedOneWithoutAlumnoInput
  }

  export type AlumnoUncheckedCreateWithoutAlumnosSueltosAnterioresInput = {
    id?: number
    nombre: string
    apellido: string
    dni: string
    activo?: boolean
    fechaNacimiento: Date | string
    email?: string | null
    telefono?: string | null
    numeroEmergencia?: string | null
    direccion?: string | null
    obraSocial?: string | null
    nombreTutor?: string | null
    dniTutor?: string | null
    notas?: string | null
    fechaIngreso?: Date | string
    fechaBaja?: Date | string | null
    motivoBaja?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recibos?: ReciboUncheckedCreateNestedManyWithoutAlumnoInput
    ctaCte?: CtaCteUncheckedCreateNestedOneWithoutAlumnoInput
    estilos?: EstiloUncheckedCreateNestedManyWithoutAlumnosInput
    asistencias?: AsistenciaUncheckedCreateNestedManyWithoutAlumnoInput
    alumnoEstilos?: AlumnoEstilosUncheckedCreateNestedManyWithoutAlumnoInput
    deudas?: DeudaUncheckedCreateNestedManyWithoutAlumnoInput
    descuentosVigentes?: DescuentoAplicadoUncheckedCreateNestedManyWithoutAlumnoInput
    configuracionPago?: ConfiguracionPagoAlumnoUncheckedCreateNestedOneWithoutAlumnoInput
  }

  export type AlumnoCreateOrConnectWithoutAlumnosSueltosAnterioresInput = {
    where: AlumnoWhereUniqueInput
    create: XOR<AlumnoCreateWithoutAlumnosSueltosAnterioresInput, AlumnoUncheckedCreateWithoutAlumnosSueltosAnterioresInput>
  }

  export type ReciboUpsertWithWhereUniqueWithoutAlumnoSueltoInput = {
    where: ReciboWhereUniqueInput
    update: XOR<ReciboUpdateWithoutAlumnoSueltoInput, ReciboUncheckedUpdateWithoutAlumnoSueltoInput>
    create: XOR<ReciboCreateWithoutAlumnoSueltoInput, ReciboUncheckedCreateWithoutAlumnoSueltoInput>
  }

  export type ReciboUpdateWithWhereUniqueWithoutAlumnoSueltoInput = {
    where: ReciboWhereUniqueInput
    data: XOR<ReciboUpdateWithoutAlumnoSueltoInput, ReciboUncheckedUpdateWithoutAlumnoSueltoInput>
  }

  export type ReciboUpdateManyWithWhereWithoutAlumnoSueltoInput = {
    where: ReciboScalarWhereInput
    data: XOR<ReciboUpdateManyMutationInput, ReciboUncheckedUpdateManyWithoutAlumnoSueltoInput>
  }

  export type ClaseUpsertWithWhereUniqueWithoutAlumnosSueltosInput = {
    where: ClaseWhereUniqueInput
    update: XOR<ClaseUpdateWithoutAlumnosSueltosInput, ClaseUncheckedUpdateWithoutAlumnosSueltosInput>
    create: XOR<ClaseCreateWithoutAlumnosSueltosInput, ClaseUncheckedCreateWithoutAlumnosSueltosInput>
  }

  export type ClaseUpdateWithWhereUniqueWithoutAlumnosSueltosInput = {
    where: ClaseWhereUniqueInput
    data: XOR<ClaseUpdateWithoutAlumnosSueltosInput, ClaseUncheckedUpdateWithoutAlumnosSueltosInput>
  }

  export type ClaseUpdateManyWithWhereWithoutAlumnosSueltosInput = {
    where: ClaseScalarWhereInput
    data: XOR<ClaseUpdateManyMutationInput, ClaseUncheckedUpdateManyWithoutAlumnosSueltosInput>
  }

  export type AlumnoUpsertWithoutAlumnosSueltosAnterioresInput = {
    update: XOR<AlumnoUpdateWithoutAlumnosSueltosAnterioresInput, AlumnoUncheckedUpdateWithoutAlumnosSueltosAnterioresInput>
    create: XOR<AlumnoCreateWithoutAlumnosSueltosAnterioresInput, AlumnoUncheckedCreateWithoutAlumnosSueltosAnterioresInput>
    where?: AlumnoWhereInput
  }

  export type AlumnoUpdateToOneWithWhereWithoutAlumnosSueltosAnterioresInput = {
    where?: AlumnoWhereInput
    data: XOR<AlumnoUpdateWithoutAlumnosSueltosAnterioresInput, AlumnoUncheckedUpdateWithoutAlumnosSueltosAnterioresInput>
  }

  export type AlumnoUpdateWithoutAlumnosSueltosAnterioresInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    numeroEmergencia?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    obraSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nombreTutor?: NullableStringFieldUpdateOperationsInput | string | null
    dniTutor?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoBaja?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibos?: ReciboUpdateManyWithoutAlumnoNestedInput
    ctaCte?: CtaCteUpdateOneWithoutAlumnoNestedInput
    estilos?: EstiloUpdateManyWithoutAlumnosNestedInput
    asistencias?: AsistenciaUpdateManyWithoutAlumnoNestedInput
    alumnoEstilos?: AlumnoEstilosUpdateManyWithoutAlumnoNestedInput
    deudas?: DeudaUpdateManyWithoutAlumnoNestedInput
    descuentosVigentes?: DescuentoAplicadoUpdateManyWithoutAlumnoNestedInput
    configuracionPago?: ConfiguracionPagoAlumnoUpdateOneWithoutAlumnoNestedInput
  }

  export type AlumnoUncheckedUpdateWithoutAlumnosSueltosAnterioresInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    numeroEmergencia?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    obraSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nombreTutor?: NullableStringFieldUpdateOperationsInput | string | null
    dniTutor?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoBaja?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibos?: ReciboUncheckedUpdateManyWithoutAlumnoNestedInput
    ctaCte?: CtaCteUncheckedUpdateOneWithoutAlumnoNestedInput
    estilos?: EstiloUncheckedUpdateManyWithoutAlumnosNestedInput
    asistencias?: AsistenciaUncheckedUpdateManyWithoutAlumnoNestedInput
    alumnoEstilos?: AlumnoEstilosUncheckedUpdateManyWithoutAlumnoNestedInput
    deudas?: DeudaUncheckedUpdateManyWithoutAlumnoNestedInput
    descuentosVigentes?: DescuentoAplicadoUncheckedUpdateManyWithoutAlumnoNestedInput
    configuracionPago?: ConfiguracionPagoAlumnoUncheckedUpdateOneWithoutAlumnoNestedInput
  }

  export type ProfesorCreateWithoutLiquidacionesInput = {
    nombre: string
    apellido: string
    dni: string
    fechaNacimiento?: Date | string | null
    direccion?: string | null
    cuit?: string | null
    email?: string | null
    telefono?: string | null
    fechaIngreso?: Date | string
    porcentajePorDefecto?: number
    porcentajeClasesSueltasPorDefecto?: number
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clases?: ClaseCreateNestedManyWithoutProfesorInput
    estilos?: EstiloCreateNestedManyWithoutProfesorInput
  }

  export type ProfesorUncheckedCreateWithoutLiquidacionesInput = {
    id?: number
    nombre: string
    apellido: string
    dni: string
    fechaNacimiento?: Date | string | null
    direccion?: string | null
    cuit?: string | null
    email?: string | null
    telefono?: string | null
    fechaIngreso?: Date | string
    porcentajePorDefecto?: number
    porcentajeClasesSueltasPorDefecto?: number
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clases?: ClaseUncheckedCreateNestedManyWithoutProfesorInput
    estilos?: EstiloUncheckedCreateNestedManyWithoutProfesorInput
  }

  export type ProfesorCreateOrConnectWithoutLiquidacionesInput = {
    where: ProfesorWhereUniqueInput
    create: XOR<ProfesorCreateWithoutLiquidacionesInput, ProfesorUncheckedCreateWithoutLiquidacionesInput>
  }

  export type DetalleLiquidacionCreateWithoutLiquidacionInput = {
    montoOriginal: number
    porcentaje: number
    montoLiquidado: number
    createdAt?: Date | string
    updatedAt?: Date | string
    recibo?: ReciboCreateNestedOneWithoutDetallesLiquidacionInput
  }

  export type DetalleLiquidacionUncheckedCreateWithoutLiquidacionInput = {
    id?: number
    reciboId?: number | null
    montoOriginal: number
    porcentaje: number
    montoLiquidado: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetalleLiquidacionCreateOrConnectWithoutLiquidacionInput = {
    where: DetalleLiquidacionWhereUniqueInput
    create: XOR<DetalleLiquidacionCreateWithoutLiquidacionInput, DetalleLiquidacionUncheckedCreateWithoutLiquidacionInput>
  }

  export type DetalleLiquidacionCreateManyLiquidacionInputEnvelope = {
    data: DetalleLiquidacionCreateManyLiquidacionInput | DetalleLiquidacionCreateManyLiquidacionInput[]
    skipDuplicates?: boolean
  }

  export type ProfesorUpsertWithoutLiquidacionesInput = {
    update: XOR<ProfesorUpdateWithoutLiquidacionesInput, ProfesorUncheckedUpdateWithoutLiquidacionesInput>
    create: XOR<ProfesorCreateWithoutLiquidacionesInput, ProfesorUncheckedCreateWithoutLiquidacionesInput>
    where?: ProfesorWhereInput
  }

  export type ProfesorUpdateToOneWithWhereWithoutLiquidacionesInput = {
    where?: ProfesorWhereInput
    data: XOR<ProfesorUpdateWithoutLiquidacionesInput, ProfesorUncheckedUpdateWithoutLiquidacionesInput>
  }

  export type ProfesorUpdateWithoutLiquidacionesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    porcentajePorDefecto?: FloatFieldUpdateOperationsInput | number
    porcentajeClasesSueltasPorDefecto?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clases?: ClaseUpdateManyWithoutProfesorNestedInput
    estilos?: EstiloUpdateManyWithoutProfesorNestedInput
  }

  export type ProfesorUncheckedUpdateWithoutLiquidacionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    porcentajePorDefecto?: FloatFieldUpdateOperationsInput | number
    porcentajeClasesSueltasPorDefecto?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clases?: ClaseUncheckedUpdateManyWithoutProfesorNestedInput
    estilos?: EstiloUncheckedUpdateManyWithoutProfesorNestedInput
  }

  export type DetalleLiquidacionUpsertWithWhereUniqueWithoutLiquidacionInput = {
    where: DetalleLiquidacionWhereUniqueInput
    update: XOR<DetalleLiquidacionUpdateWithoutLiquidacionInput, DetalleLiquidacionUncheckedUpdateWithoutLiquidacionInput>
    create: XOR<DetalleLiquidacionCreateWithoutLiquidacionInput, DetalleLiquidacionUncheckedCreateWithoutLiquidacionInput>
  }

  export type DetalleLiquidacionUpdateWithWhereUniqueWithoutLiquidacionInput = {
    where: DetalleLiquidacionWhereUniqueInput
    data: XOR<DetalleLiquidacionUpdateWithoutLiquidacionInput, DetalleLiquidacionUncheckedUpdateWithoutLiquidacionInput>
  }

  export type DetalleLiquidacionUpdateManyWithWhereWithoutLiquidacionInput = {
    where: DetalleLiquidacionScalarWhereInput
    data: XOR<DetalleLiquidacionUpdateManyMutationInput, DetalleLiquidacionUncheckedUpdateManyWithoutLiquidacionInput>
  }

  export type LiquidacionCreateWithoutDetallesInput = {
    fecha?: Date | string
    mes: number
    anio: number
    montoTotal: number
    montoCursos: number
    montoClasesSueltas: number
    porcentajeCursos?: number
    porcentajeClasesSueltas?: number
    estado?: $Enums.EstadoLiquidacion
    metodoPago?: $Enums.TipoPago | null
    fechaPago?: Date | string | null
    observaciones?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profesor?: ProfesorCreateNestedOneWithoutLiquidacionesInput
  }

  export type LiquidacionUncheckedCreateWithoutDetallesInput = {
    id?: number
    fecha?: Date | string
    mes: number
    anio: number
    profesorId?: number | null
    montoTotal: number
    montoCursos: number
    montoClasesSueltas: number
    porcentajeCursos?: number
    porcentajeClasesSueltas?: number
    estado?: $Enums.EstadoLiquidacion
    metodoPago?: $Enums.TipoPago | null
    fechaPago?: Date | string | null
    observaciones?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LiquidacionCreateOrConnectWithoutDetallesInput = {
    where: LiquidacionWhereUniqueInput
    create: XOR<LiquidacionCreateWithoutDetallesInput, LiquidacionUncheckedCreateWithoutDetallesInput>
  }

  export type ReciboCreateWithoutDetallesLiquidacionInput = {
    numeroRecibo?: number
    fecha?: Date | string
    fechaEfecto?: Date | string
    monto: number
    montoOriginal: number
    descuento?: number | null
    periodoPago: string
    tipoPago: $Enums.TipoPago
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    anulado?: boolean
    motivoAnulacion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alumno?: AlumnoCreateNestedOneWithoutRecibosInput
    alumnoSuelto?: AlumnoSueltoCreateNestedOneWithoutRecibosInput
    concepto: ConceptoCreateNestedOneWithoutRecibosInput
    pagosDeuda?: PagoDeudaCreateNestedManyWithoutReciboInput
    clase?: ClaseCreateNestedOneWithoutRecibosInput
    reciboAnulado?: ReciboCreateNestedOneWithoutRecibosAnuladosInput
    recibosAnulados?: ReciboCreateNestedManyWithoutReciboAnuladoInput
  }

  export type ReciboUncheckedCreateWithoutDetallesLiquidacionInput = {
    id?: number
    numeroRecibo?: number
    fecha?: Date | string
    fechaEfecto?: Date | string
    monto: number
    montoOriginal: number
    descuento?: number | null
    periodoPago: string
    tipoPago: $Enums.TipoPago
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    alumnoId?: number | null
    alumnoSueltoId?: number | null
    conceptoId: number
    claseId?: number | null
    anulado?: boolean
    motivoAnulacion?: string | null
    referenciaRecibo?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pagosDeuda?: PagoDeudaUncheckedCreateNestedManyWithoutReciboInput
    recibosAnulados?: ReciboUncheckedCreateNestedManyWithoutReciboAnuladoInput
  }

  export type ReciboCreateOrConnectWithoutDetallesLiquidacionInput = {
    where: ReciboWhereUniqueInput
    create: XOR<ReciboCreateWithoutDetallesLiquidacionInput, ReciboUncheckedCreateWithoutDetallesLiquidacionInput>
  }

  export type LiquidacionUpsertWithoutDetallesInput = {
    update: XOR<LiquidacionUpdateWithoutDetallesInput, LiquidacionUncheckedUpdateWithoutDetallesInput>
    create: XOR<LiquidacionCreateWithoutDetallesInput, LiquidacionUncheckedCreateWithoutDetallesInput>
    where?: LiquidacionWhereInput
  }

  export type LiquidacionUpdateToOneWithWhereWithoutDetallesInput = {
    where?: LiquidacionWhereInput
    data: XOR<LiquidacionUpdateWithoutDetallesInput, LiquidacionUncheckedUpdateWithoutDetallesInput>
  }

  export type LiquidacionUpdateWithoutDetallesInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    mes?: IntFieldUpdateOperationsInput | number
    anio?: IntFieldUpdateOperationsInput | number
    montoTotal?: FloatFieldUpdateOperationsInput | number
    montoCursos?: FloatFieldUpdateOperationsInput | number
    montoClasesSueltas?: FloatFieldUpdateOperationsInput | number
    porcentajeCursos?: FloatFieldUpdateOperationsInput | number
    porcentajeClasesSueltas?: FloatFieldUpdateOperationsInput | number
    estado?: EnumEstadoLiquidacionFieldUpdateOperationsInput | $Enums.EstadoLiquidacion
    metodoPago?: NullableEnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago | null
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profesor?: ProfesorUpdateOneWithoutLiquidacionesNestedInput
  }

  export type LiquidacionUncheckedUpdateWithoutDetallesInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    mes?: IntFieldUpdateOperationsInput | number
    anio?: IntFieldUpdateOperationsInput | number
    profesorId?: NullableIntFieldUpdateOperationsInput | number | null
    montoTotal?: FloatFieldUpdateOperationsInput | number
    montoCursos?: FloatFieldUpdateOperationsInput | number
    montoClasesSueltas?: FloatFieldUpdateOperationsInput | number
    porcentajeCursos?: FloatFieldUpdateOperationsInput | number
    porcentajeClasesSueltas?: FloatFieldUpdateOperationsInput | number
    estado?: EnumEstadoLiquidacionFieldUpdateOperationsInput | $Enums.EstadoLiquidacion
    metodoPago?: NullableEnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago | null
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReciboUpsertWithoutDetallesLiquidacionInput = {
    update: XOR<ReciboUpdateWithoutDetallesLiquidacionInput, ReciboUncheckedUpdateWithoutDetallesLiquidacionInput>
    create: XOR<ReciboCreateWithoutDetallesLiquidacionInput, ReciboUncheckedCreateWithoutDetallesLiquidacionInput>
    where?: ReciboWhereInput
  }

  export type ReciboUpdateToOneWithWhereWithoutDetallesLiquidacionInput = {
    where?: ReciboWhereInput
    data: XOR<ReciboUpdateWithoutDetallesLiquidacionInput, ReciboUncheckedUpdateWithoutDetallesLiquidacionInput>
  }

  export type ReciboUpdateWithoutDetallesLiquidacionInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEfecto?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    periodoPago?: StringFieldUpdateOperationsInput | string
    tipoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    fueraDeTermino?: BoolFieldUpdateOperationsInput | boolean
    esClaseSuelta?: BoolFieldUpdateOperationsInput | boolean
    esMesCompleto?: BoolFieldUpdateOperationsInput | boolean
    anulado?: BoolFieldUpdateOperationsInput | boolean
    motivoAnulacion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alumno?: AlumnoUpdateOneWithoutRecibosNestedInput
    alumnoSuelto?: AlumnoSueltoUpdateOneWithoutRecibosNestedInput
    concepto?: ConceptoUpdateOneRequiredWithoutRecibosNestedInput
    pagosDeuda?: PagoDeudaUpdateManyWithoutReciboNestedInput
    clase?: ClaseUpdateOneWithoutRecibosNestedInput
    reciboAnulado?: ReciboUpdateOneWithoutRecibosAnuladosNestedInput
    recibosAnulados?: ReciboUpdateManyWithoutReciboAnuladoNestedInput
  }

  export type ReciboUncheckedUpdateWithoutDetallesLiquidacionInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroRecibo?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEfecto?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    periodoPago?: StringFieldUpdateOperationsInput | string
    tipoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    fueraDeTermino?: BoolFieldUpdateOperationsInput | boolean
    esClaseSuelta?: BoolFieldUpdateOperationsInput | boolean
    esMesCompleto?: BoolFieldUpdateOperationsInput | boolean
    alumnoId?: NullableIntFieldUpdateOperationsInput | number | null
    alumnoSueltoId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptoId?: IntFieldUpdateOperationsInput | number
    claseId?: NullableIntFieldUpdateOperationsInput | number | null
    anulado?: BoolFieldUpdateOperationsInput | boolean
    motivoAnulacion?: NullableStringFieldUpdateOperationsInput | string | null
    referenciaRecibo?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagosDeuda?: PagoDeudaUncheckedUpdateManyWithoutReciboNestedInput
    recibosAnulados?: ReciboUncheckedUpdateManyWithoutReciboAnuladoNestedInput
  }

  export type ReciboCreateManyAlumnoInput = {
    id?: number
    numeroRecibo?: number
    fecha?: Date | string
    fechaEfecto?: Date | string
    monto: number
    montoOriginal: number
    descuento?: number | null
    periodoPago: string
    tipoPago: $Enums.TipoPago
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    alumnoSueltoId?: number | null
    conceptoId: number
    claseId?: number | null
    anulado?: boolean
    motivoAnulacion?: string | null
    referenciaRecibo?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlumnoSueltoCreateManyAlumnoRegularInput = {
    id?: number
    nombre: string
    apellido: string
    dni: string
    telefono?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AsistenciaCreateManyAlumnoInput = {
    id?: number
    claseId: number
    asistio: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlumnoEstilosCreateManyAlumnoInput = {
    id?: number
    estiloId: number
    activo?: boolean
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    montoPersonalizado?: number | null
    descuentoPersonalizado?: number | null
    observaciones?: string | null
  }

  export type DeudaCreateManyAlumnoInput = {
    id?: number
    monto: number
    montoOriginal: number
    mes: string
    anio: number
    estiloId: number
    pagada?: boolean
    fechaPago?: Date | string | null
    fechaVencimiento: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DescuentoAplicadoCreateManyAlumnoInput = {
    id?: number
    descuentoId: number
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReciboUpdateWithoutAlumnoInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEfecto?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    periodoPago?: StringFieldUpdateOperationsInput | string
    tipoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    fueraDeTermino?: BoolFieldUpdateOperationsInput | boolean
    esClaseSuelta?: BoolFieldUpdateOperationsInput | boolean
    esMesCompleto?: BoolFieldUpdateOperationsInput | boolean
    anulado?: BoolFieldUpdateOperationsInput | boolean
    motivoAnulacion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alumnoSuelto?: AlumnoSueltoUpdateOneWithoutRecibosNestedInput
    concepto?: ConceptoUpdateOneRequiredWithoutRecibosNestedInput
    pagosDeuda?: PagoDeudaUpdateManyWithoutReciboNestedInput
    detallesLiquidacion?: DetalleLiquidacionUpdateManyWithoutReciboNestedInput
    clase?: ClaseUpdateOneWithoutRecibosNestedInput
    reciboAnulado?: ReciboUpdateOneWithoutRecibosAnuladosNestedInput
    recibosAnulados?: ReciboUpdateManyWithoutReciboAnuladoNestedInput
  }

  export type ReciboUncheckedUpdateWithoutAlumnoInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroRecibo?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEfecto?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    periodoPago?: StringFieldUpdateOperationsInput | string
    tipoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    fueraDeTermino?: BoolFieldUpdateOperationsInput | boolean
    esClaseSuelta?: BoolFieldUpdateOperationsInput | boolean
    esMesCompleto?: BoolFieldUpdateOperationsInput | boolean
    alumnoSueltoId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptoId?: IntFieldUpdateOperationsInput | number
    claseId?: NullableIntFieldUpdateOperationsInput | number | null
    anulado?: BoolFieldUpdateOperationsInput | boolean
    motivoAnulacion?: NullableStringFieldUpdateOperationsInput | string | null
    referenciaRecibo?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagosDeuda?: PagoDeudaUncheckedUpdateManyWithoutReciboNestedInput
    detallesLiquidacion?: DetalleLiquidacionUncheckedUpdateManyWithoutReciboNestedInput
    recibosAnulados?: ReciboUncheckedUpdateManyWithoutReciboAnuladoNestedInput
  }

  export type ReciboUncheckedUpdateManyWithoutAlumnoInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroRecibo?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEfecto?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    periodoPago?: StringFieldUpdateOperationsInput | string
    tipoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    fueraDeTermino?: BoolFieldUpdateOperationsInput | boolean
    esClaseSuelta?: BoolFieldUpdateOperationsInput | boolean
    esMesCompleto?: BoolFieldUpdateOperationsInput | boolean
    alumnoSueltoId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptoId?: IntFieldUpdateOperationsInput | number
    claseId?: NullableIntFieldUpdateOperationsInput | number | null
    anulado?: BoolFieldUpdateOperationsInput | boolean
    motivoAnulacion?: NullableStringFieldUpdateOperationsInput | string | null
    referenciaRecibo?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlumnoSueltoUpdateWithoutAlumnoRegularInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibos?: ReciboUpdateManyWithoutAlumnoSueltoNestedInput
    clases?: ClaseUpdateManyWithoutAlumnosSueltosNestedInput
  }

  export type AlumnoSueltoUncheckedUpdateWithoutAlumnoRegularInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibos?: ReciboUncheckedUpdateManyWithoutAlumnoSueltoNestedInput
    clases?: ClaseUncheckedUpdateManyWithoutAlumnosSueltosNestedInput
  }

  export type AlumnoSueltoUncheckedUpdateManyWithoutAlumnoRegularInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EstiloUpdateWithoutAlumnosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deudas?: DeudaUpdateManyWithoutEstiloNestedInput
    conceptos?: ConceptoUpdateManyWithoutEstiloNestedInput
    clases?: ClaseUpdateManyWithoutEstiloNestedInput
    alumnoEstilos?: AlumnoEstilosUpdateManyWithoutEstiloNestedInput
    profesor?: ProfesorUpdateOneWithoutEstilosNestedInput
  }

  export type EstiloUncheckedUpdateWithoutAlumnosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: FloatFieldUpdateOperationsInput | number
    profesorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deudas?: DeudaUncheckedUpdateManyWithoutEstiloNestedInput
    conceptos?: ConceptoUncheckedUpdateManyWithoutEstiloNestedInput
    clases?: ClaseUncheckedUpdateManyWithoutEstiloNestedInput
    alumnoEstilos?: AlumnoEstilosUncheckedUpdateManyWithoutEstiloNestedInput
  }

  export type EstiloUncheckedUpdateManyWithoutAlumnosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: FloatFieldUpdateOperationsInput | number
    profesorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AsistenciaUpdateWithoutAlumnoInput = {
    asistio?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clase?: ClaseUpdateOneRequiredWithoutAsistenciasNestedInput
  }

  export type AsistenciaUncheckedUpdateWithoutAlumnoInput = {
    id?: IntFieldUpdateOperationsInput | number
    claseId?: IntFieldUpdateOperationsInput | number
    asistio?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AsistenciaUncheckedUpdateManyWithoutAlumnoInput = {
    id?: IntFieldUpdateOperationsInput | number
    claseId?: IntFieldUpdateOperationsInput | number
    asistio?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlumnoEstilosUpdateWithoutAlumnoInput = {
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montoPersonalizado?: NullableFloatFieldUpdateOperationsInput | number | null
    descuentoPersonalizado?: NullableFloatFieldUpdateOperationsInput | number | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estilo?: EstiloUpdateOneRequiredWithoutAlumnoEstilosNestedInput
  }

  export type AlumnoEstilosUncheckedUpdateWithoutAlumnoInput = {
    id?: IntFieldUpdateOperationsInput | number
    estiloId?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montoPersonalizado?: NullableFloatFieldUpdateOperationsInput | number | null
    descuentoPersonalizado?: NullableFloatFieldUpdateOperationsInput | number | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlumnoEstilosUncheckedUpdateManyWithoutAlumnoInput = {
    id?: IntFieldUpdateOperationsInput | number
    estiloId?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montoPersonalizado?: NullableFloatFieldUpdateOperationsInput | number | null
    descuentoPersonalizado?: NullableFloatFieldUpdateOperationsInput | number | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeudaUpdateWithoutAlumnoInput = {
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    mes?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    pagada?: BoolFieldUpdateOperationsInput | boolean
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estilo?: EstiloUpdateOneRequiredWithoutDeudasNestedInput
    pagos?: PagoDeudaUpdateManyWithoutDeudaNestedInput
  }

  export type DeudaUncheckedUpdateWithoutAlumnoInput = {
    id?: IntFieldUpdateOperationsInput | number
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    mes?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    estiloId?: IntFieldUpdateOperationsInput | number
    pagada?: BoolFieldUpdateOperationsInput | boolean
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagos?: PagoDeudaUncheckedUpdateManyWithoutDeudaNestedInput
  }

  export type DeudaUncheckedUpdateManyWithoutAlumnoInput = {
    id?: IntFieldUpdateOperationsInput | number
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    mes?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    estiloId?: IntFieldUpdateOperationsInput | number
    pagada?: BoolFieldUpdateOperationsInput | boolean
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DescuentoAplicadoUpdateWithoutAlumnoInput = {
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    descuento?: DescuentoUpdateOneRequiredWithoutAplicadoANestedInput
  }

  export type DescuentoAplicadoUncheckedUpdateWithoutAlumnoInput = {
    id?: IntFieldUpdateOperationsInput | number
    descuentoId?: IntFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DescuentoAplicadoUncheckedUpdateManyWithoutAlumnoInput = {
    id?: IntFieldUpdateOperationsInput | number
    descuentoId?: IntFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DescuentoAplicadoCreateManyDescuentoInput = {
    id?: number
    alumnoId: number
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DescuentoAplicadoUpdateWithoutDescuentoInput = {
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alumno?: AlumnoUpdateOneRequiredWithoutDescuentosVigentesNestedInput
  }

  export type DescuentoAplicadoUncheckedUpdateWithoutDescuentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    alumnoId?: IntFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DescuentoAplicadoUncheckedUpdateManyWithoutDescuentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    alumnoId?: IntFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoDeudaCreateManyDeudaInput = {
    id?: number
    reciboId: number
    monto: number
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PagoDeudaUpdateWithoutDeudaInput = {
    monto?: FloatFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibo?: ReciboUpdateOneRequiredWithoutPagosDeudaNestedInput
  }

  export type PagoDeudaUncheckedUpdateWithoutDeudaInput = {
    id?: IntFieldUpdateOperationsInput | number
    reciboId?: IntFieldUpdateOperationsInput | number
    monto?: FloatFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoDeudaUncheckedUpdateManyWithoutDeudaInput = {
    id?: IntFieldUpdateOperationsInput | number
    reciboId?: IntFieldUpdateOperationsInput | number
    monto?: FloatFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReciboCreateManyConceptoInput = {
    id?: number
    numeroRecibo?: number
    fecha?: Date | string
    fechaEfecto?: Date | string
    monto: number
    montoOriginal: number
    descuento?: number | null
    periodoPago: string
    tipoPago: $Enums.TipoPago
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    alumnoId?: number | null
    alumnoSueltoId?: number | null
    claseId?: number | null
    anulado?: boolean
    motivoAnulacion?: string | null
    referenciaRecibo?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReciboUpdateWithoutConceptoInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEfecto?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    periodoPago?: StringFieldUpdateOperationsInput | string
    tipoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    fueraDeTermino?: BoolFieldUpdateOperationsInput | boolean
    esClaseSuelta?: BoolFieldUpdateOperationsInput | boolean
    esMesCompleto?: BoolFieldUpdateOperationsInput | boolean
    anulado?: BoolFieldUpdateOperationsInput | boolean
    motivoAnulacion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alumno?: AlumnoUpdateOneWithoutRecibosNestedInput
    alumnoSuelto?: AlumnoSueltoUpdateOneWithoutRecibosNestedInput
    pagosDeuda?: PagoDeudaUpdateManyWithoutReciboNestedInput
    detallesLiquidacion?: DetalleLiquidacionUpdateManyWithoutReciboNestedInput
    clase?: ClaseUpdateOneWithoutRecibosNestedInput
    reciboAnulado?: ReciboUpdateOneWithoutRecibosAnuladosNestedInput
    recibosAnulados?: ReciboUpdateManyWithoutReciboAnuladoNestedInput
  }

  export type ReciboUncheckedUpdateWithoutConceptoInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroRecibo?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEfecto?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    periodoPago?: StringFieldUpdateOperationsInput | string
    tipoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    fueraDeTermino?: BoolFieldUpdateOperationsInput | boolean
    esClaseSuelta?: BoolFieldUpdateOperationsInput | boolean
    esMesCompleto?: BoolFieldUpdateOperationsInput | boolean
    alumnoId?: NullableIntFieldUpdateOperationsInput | number | null
    alumnoSueltoId?: NullableIntFieldUpdateOperationsInput | number | null
    claseId?: NullableIntFieldUpdateOperationsInput | number | null
    anulado?: BoolFieldUpdateOperationsInput | boolean
    motivoAnulacion?: NullableStringFieldUpdateOperationsInput | string | null
    referenciaRecibo?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagosDeuda?: PagoDeudaUncheckedUpdateManyWithoutReciboNestedInput
    detallesLiquidacion?: DetalleLiquidacionUncheckedUpdateManyWithoutReciboNestedInput
    recibosAnulados?: ReciboUncheckedUpdateManyWithoutReciboAnuladoNestedInput
  }

  export type ReciboUncheckedUpdateManyWithoutConceptoInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroRecibo?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEfecto?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    periodoPago?: StringFieldUpdateOperationsInput | string
    tipoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    fueraDeTermino?: BoolFieldUpdateOperationsInput | boolean
    esClaseSuelta?: BoolFieldUpdateOperationsInput | boolean
    esMesCompleto?: BoolFieldUpdateOperationsInput | boolean
    alumnoId?: NullableIntFieldUpdateOperationsInput | number | null
    alumnoSueltoId?: NullableIntFieldUpdateOperationsInput | number | null
    claseId?: NullableIntFieldUpdateOperationsInput | number | null
    anulado?: BoolFieldUpdateOperationsInput | boolean
    motivoAnulacion?: NullableStringFieldUpdateOperationsInput | string | null
    referenciaRecibo?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoDeudaCreateManyReciboInput = {
    id?: number
    deudaId: number
    monto: number
    fecha?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetalleLiquidacionCreateManyReciboInput = {
    id?: number
    liquidacionId: number
    montoOriginal: number
    porcentaje: number
    montoLiquidado: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReciboCreateManyReciboAnuladoInput = {
    id?: number
    numeroRecibo?: number
    fecha?: Date | string
    fechaEfecto?: Date | string
    monto: number
    montoOriginal: number
    descuento?: number | null
    periodoPago: string
    tipoPago: $Enums.TipoPago
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    alumnoId?: number | null
    alumnoSueltoId?: number | null
    conceptoId: number
    claseId?: number | null
    anulado?: boolean
    motivoAnulacion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PagoDeudaUpdateWithoutReciboInput = {
    monto?: FloatFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deuda?: DeudaUpdateOneRequiredWithoutPagosNestedInput
  }

  export type PagoDeudaUncheckedUpdateWithoutReciboInput = {
    id?: IntFieldUpdateOperationsInput | number
    deudaId?: IntFieldUpdateOperationsInput | number
    monto?: FloatFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoDeudaUncheckedUpdateManyWithoutReciboInput = {
    id?: IntFieldUpdateOperationsInput | number
    deudaId?: IntFieldUpdateOperationsInput | number
    monto?: FloatFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetalleLiquidacionUpdateWithoutReciboInput = {
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    porcentaje?: FloatFieldUpdateOperationsInput | number
    montoLiquidado?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    liquidacion?: LiquidacionUpdateOneRequiredWithoutDetallesNestedInput
  }

  export type DetalleLiquidacionUncheckedUpdateWithoutReciboInput = {
    id?: IntFieldUpdateOperationsInput | number
    liquidacionId?: IntFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    porcentaje?: FloatFieldUpdateOperationsInput | number
    montoLiquidado?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetalleLiquidacionUncheckedUpdateManyWithoutReciboInput = {
    id?: IntFieldUpdateOperationsInput | number
    liquidacionId?: IntFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    porcentaje?: FloatFieldUpdateOperationsInput | number
    montoLiquidado?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReciboUpdateWithoutReciboAnuladoInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEfecto?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    periodoPago?: StringFieldUpdateOperationsInput | string
    tipoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    fueraDeTermino?: BoolFieldUpdateOperationsInput | boolean
    esClaseSuelta?: BoolFieldUpdateOperationsInput | boolean
    esMesCompleto?: BoolFieldUpdateOperationsInput | boolean
    anulado?: BoolFieldUpdateOperationsInput | boolean
    motivoAnulacion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alumno?: AlumnoUpdateOneWithoutRecibosNestedInput
    alumnoSuelto?: AlumnoSueltoUpdateOneWithoutRecibosNestedInput
    concepto?: ConceptoUpdateOneRequiredWithoutRecibosNestedInput
    pagosDeuda?: PagoDeudaUpdateManyWithoutReciboNestedInput
    detallesLiquidacion?: DetalleLiquidacionUpdateManyWithoutReciboNestedInput
    clase?: ClaseUpdateOneWithoutRecibosNestedInput
    recibosAnulados?: ReciboUpdateManyWithoutReciboAnuladoNestedInput
  }

  export type ReciboUncheckedUpdateWithoutReciboAnuladoInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroRecibo?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEfecto?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    periodoPago?: StringFieldUpdateOperationsInput | string
    tipoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    fueraDeTermino?: BoolFieldUpdateOperationsInput | boolean
    esClaseSuelta?: BoolFieldUpdateOperationsInput | boolean
    esMesCompleto?: BoolFieldUpdateOperationsInput | boolean
    alumnoId?: NullableIntFieldUpdateOperationsInput | number | null
    alumnoSueltoId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptoId?: IntFieldUpdateOperationsInput | number
    claseId?: NullableIntFieldUpdateOperationsInput | number | null
    anulado?: BoolFieldUpdateOperationsInput | boolean
    motivoAnulacion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagosDeuda?: PagoDeudaUncheckedUpdateManyWithoutReciboNestedInput
    detallesLiquidacion?: DetalleLiquidacionUncheckedUpdateManyWithoutReciboNestedInput
    recibosAnulados?: ReciboUncheckedUpdateManyWithoutReciboAnuladoNestedInput
  }

  export type ReciboUncheckedUpdateManyWithoutReciboAnuladoInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroRecibo?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEfecto?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    periodoPago?: StringFieldUpdateOperationsInput | string
    tipoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    fueraDeTermino?: BoolFieldUpdateOperationsInput | boolean
    esClaseSuelta?: BoolFieldUpdateOperationsInput | boolean
    esMesCompleto?: BoolFieldUpdateOperationsInput | boolean
    alumnoId?: NullableIntFieldUpdateOperationsInput | number | null
    alumnoSueltoId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptoId?: IntFieldUpdateOperationsInput | number
    claseId?: NullableIntFieldUpdateOperationsInput | number | null
    anulado?: BoolFieldUpdateOperationsInput | boolean
    motivoAnulacion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeudaCreateManyEstiloInput = {
    id?: number
    alumnoId: number
    monto: number
    montoOriginal: number
    mes: string
    anio: number
    pagada?: boolean
    fechaPago?: Date | string | null
    fechaVencimiento: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConceptoCreateManyEstiloInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    monto: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClaseCreateManyEstiloInput = {
    id?: number
    fecha?: Date | string
    profesorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlumnoEstilosCreateManyEstiloInput = {
    id?: number
    alumnoId: number
    activo?: boolean
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    montoPersonalizado?: number | null
    descuentoPersonalizado?: number | null
    observaciones?: string | null
  }

  export type DeudaUpdateWithoutEstiloInput = {
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    mes?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    pagada?: BoolFieldUpdateOperationsInput | boolean
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alumno?: AlumnoUpdateOneRequiredWithoutDeudasNestedInput
    pagos?: PagoDeudaUpdateManyWithoutDeudaNestedInput
  }

  export type DeudaUncheckedUpdateWithoutEstiloInput = {
    id?: IntFieldUpdateOperationsInput | number
    alumnoId?: IntFieldUpdateOperationsInput | number
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    mes?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    pagada?: BoolFieldUpdateOperationsInput | boolean
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagos?: PagoDeudaUncheckedUpdateManyWithoutDeudaNestedInput
  }

  export type DeudaUncheckedUpdateManyWithoutEstiloInput = {
    id?: IntFieldUpdateOperationsInput | number
    alumnoId?: IntFieldUpdateOperationsInput | number
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    mes?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    pagada?: BoolFieldUpdateOperationsInput | boolean
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptoUpdateWithoutEstiloInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibos?: ReciboUpdateManyWithoutConceptoNestedInput
  }

  export type ConceptoUncheckedUpdateWithoutEstiloInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibos?: ReciboUncheckedUpdateManyWithoutConceptoNestedInput
  }

  export type ConceptoUncheckedUpdateManyWithoutEstiloInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaseUpdateWithoutEstiloInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profesor?: ProfesorUpdateOneRequiredWithoutClasesNestedInput
    asistencias?: AsistenciaUpdateManyWithoutClaseNestedInput
    alumnosSueltos?: AlumnoSueltoUpdateManyWithoutClasesNestedInput
    recibos?: ReciboUpdateManyWithoutClaseNestedInput
  }

  export type ClaseUncheckedUpdateWithoutEstiloInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    profesorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asistencias?: AsistenciaUncheckedUpdateManyWithoutClaseNestedInput
    alumnosSueltos?: AlumnoSueltoUncheckedUpdateManyWithoutClasesNestedInput
    recibos?: ReciboUncheckedUpdateManyWithoutClaseNestedInput
  }

  export type ClaseUncheckedUpdateManyWithoutEstiloInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    profesorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlumnoEstilosUpdateWithoutEstiloInput = {
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montoPersonalizado?: NullableFloatFieldUpdateOperationsInput | number | null
    descuentoPersonalizado?: NullableFloatFieldUpdateOperationsInput | number | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    alumno?: AlumnoUpdateOneRequiredWithoutAlumnoEstilosNestedInput
  }

  export type AlumnoEstilosUncheckedUpdateWithoutEstiloInput = {
    id?: IntFieldUpdateOperationsInput | number
    alumnoId?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montoPersonalizado?: NullableFloatFieldUpdateOperationsInput | number | null
    descuentoPersonalizado?: NullableFloatFieldUpdateOperationsInput | number | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlumnoEstilosUncheckedUpdateManyWithoutEstiloInput = {
    id?: IntFieldUpdateOperationsInput | number
    alumnoId?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montoPersonalizado?: NullableFloatFieldUpdateOperationsInput | number | null
    descuentoPersonalizado?: NullableFloatFieldUpdateOperationsInput | number | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlumnoUpdateWithoutEstilosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    numeroEmergencia?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    obraSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nombreTutor?: NullableStringFieldUpdateOperationsInput | string | null
    dniTutor?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoBaja?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibos?: ReciboUpdateManyWithoutAlumnoNestedInput
    alumnosSueltosAnteriores?: AlumnoSueltoUpdateManyWithoutAlumnoRegularNestedInput
    ctaCte?: CtaCteUpdateOneWithoutAlumnoNestedInput
    asistencias?: AsistenciaUpdateManyWithoutAlumnoNestedInput
    alumnoEstilos?: AlumnoEstilosUpdateManyWithoutAlumnoNestedInput
    deudas?: DeudaUpdateManyWithoutAlumnoNestedInput
    descuentosVigentes?: DescuentoAplicadoUpdateManyWithoutAlumnoNestedInput
    configuracionPago?: ConfiguracionPagoAlumnoUpdateOneWithoutAlumnoNestedInput
  }

  export type AlumnoUncheckedUpdateWithoutEstilosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    numeroEmergencia?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    obraSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nombreTutor?: NullableStringFieldUpdateOperationsInput | string | null
    dniTutor?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoBaja?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibos?: ReciboUncheckedUpdateManyWithoutAlumnoNestedInput
    alumnosSueltosAnteriores?: AlumnoSueltoUncheckedUpdateManyWithoutAlumnoRegularNestedInput
    ctaCte?: CtaCteUncheckedUpdateOneWithoutAlumnoNestedInput
    asistencias?: AsistenciaUncheckedUpdateManyWithoutAlumnoNestedInput
    alumnoEstilos?: AlumnoEstilosUncheckedUpdateManyWithoutAlumnoNestedInput
    deudas?: DeudaUncheckedUpdateManyWithoutAlumnoNestedInput
    descuentosVigentes?: DescuentoAplicadoUncheckedUpdateManyWithoutAlumnoNestedInput
    configuracionPago?: ConfiguracionPagoAlumnoUncheckedUpdateOneWithoutAlumnoNestedInput
  }

  export type AlumnoUncheckedUpdateManyWithoutEstilosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    numeroEmergencia?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    obraSocial?: NullableStringFieldUpdateOperationsInput | string | null
    nombreTutor?: NullableStringFieldUpdateOperationsInput | string | null
    dniTutor?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoBaja?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaseCreateManyProfesorInput = {
    id?: number
    fecha?: Date | string
    estiloId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EstiloCreateManyProfesorInput = {
    id?: number
    nombre: string
    monto?: number
    descripcion?: string | null
    importe?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LiquidacionCreateManyProfesorInput = {
    id?: number
    fecha?: Date | string
    mes: number
    anio: number
    montoTotal: number
    montoCursos: number
    montoClasesSueltas: number
    porcentajeCursos?: number
    porcentajeClasesSueltas?: number
    estado?: $Enums.EstadoLiquidacion
    metodoPago?: $Enums.TipoPago | null
    fechaPago?: Date | string | null
    observaciones?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClaseUpdateWithoutProfesorInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estilo?: EstiloUpdateOneRequiredWithoutClasesNestedInput
    asistencias?: AsistenciaUpdateManyWithoutClaseNestedInput
    alumnosSueltos?: AlumnoSueltoUpdateManyWithoutClasesNestedInput
    recibos?: ReciboUpdateManyWithoutClaseNestedInput
  }

  export type ClaseUncheckedUpdateWithoutProfesorInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estiloId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asistencias?: AsistenciaUncheckedUpdateManyWithoutClaseNestedInput
    alumnosSueltos?: AlumnoSueltoUncheckedUpdateManyWithoutClasesNestedInput
    recibos?: ReciboUncheckedUpdateManyWithoutClaseNestedInput
  }

  export type ClaseUncheckedUpdateManyWithoutProfesorInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estiloId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EstiloUpdateWithoutProfesorInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deudas?: DeudaUpdateManyWithoutEstiloNestedInput
    conceptos?: ConceptoUpdateManyWithoutEstiloNestedInput
    clases?: ClaseUpdateManyWithoutEstiloNestedInput
    alumnoEstilos?: AlumnoEstilosUpdateManyWithoutEstiloNestedInput
    alumnos?: AlumnoUpdateManyWithoutEstilosNestedInput
  }

  export type EstiloUncheckedUpdateWithoutProfesorInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deudas?: DeudaUncheckedUpdateManyWithoutEstiloNestedInput
    conceptos?: ConceptoUncheckedUpdateManyWithoutEstiloNestedInput
    clases?: ClaseUncheckedUpdateManyWithoutEstiloNestedInput
    alumnoEstilos?: AlumnoEstilosUncheckedUpdateManyWithoutEstiloNestedInput
    alumnos?: AlumnoUncheckedUpdateManyWithoutEstilosNestedInput
  }

  export type EstiloUncheckedUpdateManyWithoutProfesorInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiquidacionUpdateWithoutProfesorInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    mes?: IntFieldUpdateOperationsInput | number
    anio?: IntFieldUpdateOperationsInput | number
    montoTotal?: FloatFieldUpdateOperationsInput | number
    montoCursos?: FloatFieldUpdateOperationsInput | number
    montoClasesSueltas?: FloatFieldUpdateOperationsInput | number
    porcentajeCursos?: FloatFieldUpdateOperationsInput | number
    porcentajeClasesSueltas?: FloatFieldUpdateOperationsInput | number
    estado?: EnumEstadoLiquidacionFieldUpdateOperationsInput | $Enums.EstadoLiquidacion
    metodoPago?: NullableEnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago | null
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detalles?: DetalleLiquidacionUpdateManyWithoutLiquidacionNestedInput
  }

  export type LiquidacionUncheckedUpdateWithoutProfesorInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    mes?: IntFieldUpdateOperationsInput | number
    anio?: IntFieldUpdateOperationsInput | number
    montoTotal?: FloatFieldUpdateOperationsInput | number
    montoCursos?: FloatFieldUpdateOperationsInput | number
    montoClasesSueltas?: FloatFieldUpdateOperationsInput | number
    porcentajeCursos?: FloatFieldUpdateOperationsInput | number
    porcentajeClasesSueltas?: FloatFieldUpdateOperationsInput | number
    estado?: EnumEstadoLiquidacionFieldUpdateOperationsInput | $Enums.EstadoLiquidacion
    metodoPago?: NullableEnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago | null
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detalles?: DetalleLiquidacionUncheckedUpdateManyWithoutLiquidacionNestedInput
  }

  export type LiquidacionUncheckedUpdateManyWithoutProfesorInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    mes?: IntFieldUpdateOperationsInput | number
    anio?: IntFieldUpdateOperationsInput | number
    montoTotal?: FloatFieldUpdateOperationsInput | number
    montoCursos?: FloatFieldUpdateOperationsInput | number
    montoClasesSueltas?: FloatFieldUpdateOperationsInput | number
    porcentajeCursos?: FloatFieldUpdateOperationsInput | number
    porcentajeClasesSueltas?: FloatFieldUpdateOperationsInput | number
    estado?: EnumEstadoLiquidacionFieldUpdateOperationsInput | $Enums.EstadoLiquidacion
    metodoPago?: NullableEnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago | null
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AsistenciaCreateManyClaseInput = {
    id?: number
    alumnoId: number
    asistio: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReciboCreateManyClaseInput = {
    id?: number
    numeroRecibo?: number
    fecha?: Date | string
    fechaEfecto?: Date | string
    monto: number
    montoOriginal: number
    descuento?: number | null
    periodoPago: string
    tipoPago: $Enums.TipoPago
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    alumnoId?: number | null
    alumnoSueltoId?: number | null
    conceptoId: number
    anulado?: boolean
    motivoAnulacion?: string | null
    referenciaRecibo?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AsistenciaUpdateWithoutClaseInput = {
    asistio?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alumno?: AlumnoUpdateOneRequiredWithoutAsistenciasNestedInput
  }

  export type AsistenciaUncheckedUpdateWithoutClaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    alumnoId?: IntFieldUpdateOperationsInput | number
    asistio?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AsistenciaUncheckedUpdateManyWithoutClaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    alumnoId?: IntFieldUpdateOperationsInput | number
    asistio?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlumnoSueltoUpdateWithoutClasesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibos?: ReciboUpdateManyWithoutAlumnoSueltoNestedInput
    alumnoRegular?: AlumnoUpdateOneWithoutAlumnosSueltosAnterioresNestedInput
  }

  export type AlumnoSueltoUncheckedUpdateWithoutClasesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    alumnoRegularId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibos?: ReciboUncheckedUpdateManyWithoutAlumnoSueltoNestedInput
  }

  export type AlumnoSueltoUncheckedUpdateManyWithoutClasesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    alumnoRegularId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReciboUpdateWithoutClaseInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEfecto?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    periodoPago?: StringFieldUpdateOperationsInput | string
    tipoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    fueraDeTermino?: BoolFieldUpdateOperationsInput | boolean
    esClaseSuelta?: BoolFieldUpdateOperationsInput | boolean
    esMesCompleto?: BoolFieldUpdateOperationsInput | boolean
    anulado?: BoolFieldUpdateOperationsInput | boolean
    motivoAnulacion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alumno?: AlumnoUpdateOneWithoutRecibosNestedInput
    alumnoSuelto?: AlumnoSueltoUpdateOneWithoutRecibosNestedInput
    concepto?: ConceptoUpdateOneRequiredWithoutRecibosNestedInput
    pagosDeuda?: PagoDeudaUpdateManyWithoutReciboNestedInput
    detallesLiquidacion?: DetalleLiquidacionUpdateManyWithoutReciboNestedInput
    reciboAnulado?: ReciboUpdateOneWithoutRecibosAnuladosNestedInput
    recibosAnulados?: ReciboUpdateManyWithoutReciboAnuladoNestedInput
  }

  export type ReciboUncheckedUpdateWithoutClaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroRecibo?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEfecto?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    periodoPago?: StringFieldUpdateOperationsInput | string
    tipoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    fueraDeTermino?: BoolFieldUpdateOperationsInput | boolean
    esClaseSuelta?: BoolFieldUpdateOperationsInput | boolean
    esMesCompleto?: BoolFieldUpdateOperationsInput | boolean
    alumnoId?: NullableIntFieldUpdateOperationsInput | number | null
    alumnoSueltoId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptoId?: IntFieldUpdateOperationsInput | number
    anulado?: BoolFieldUpdateOperationsInput | boolean
    motivoAnulacion?: NullableStringFieldUpdateOperationsInput | string | null
    referenciaRecibo?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagosDeuda?: PagoDeudaUncheckedUpdateManyWithoutReciboNestedInput
    detallesLiquidacion?: DetalleLiquidacionUncheckedUpdateManyWithoutReciboNestedInput
    recibosAnulados?: ReciboUncheckedUpdateManyWithoutReciboAnuladoNestedInput
  }

  export type ReciboUncheckedUpdateManyWithoutClaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroRecibo?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEfecto?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    periodoPago?: StringFieldUpdateOperationsInput | string
    tipoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    fueraDeTermino?: BoolFieldUpdateOperationsInput | boolean
    esClaseSuelta?: BoolFieldUpdateOperationsInput | boolean
    esMesCompleto?: BoolFieldUpdateOperationsInput | boolean
    alumnoId?: NullableIntFieldUpdateOperationsInput | number | null
    alumnoSueltoId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptoId?: IntFieldUpdateOperationsInput | number
    anulado?: BoolFieldUpdateOperationsInput | boolean
    motivoAnulacion?: NullableStringFieldUpdateOperationsInput | string | null
    referenciaRecibo?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReciboCreateManyAlumnoSueltoInput = {
    id?: number
    numeroRecibo?: number
    fecha?: Date | string
    fechaEfecto?: Date | string
    monto: number
    montoOriginal: number
    descuento?: number | null
    periodoPago: string
    tipoPago: $Enums.TipoPago
    fueraDeTermino?: boolean
    esClaseSuelta?: boolean
    esMesCompleto?: boolean
    alumnoId?: number | null
    conceptoId: number
    claseId?: number | null
    anulado?: boolean
    motivoAnulacion?: string | null
    referenciaRecibo?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReciboUpdateWithoutAlumnoSueltoInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEfecto?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    periodoPago?: StringFieldUpdateOperationsInput | string
    tipoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    fueraDeTermino?: BoolFieldUpdateOperationsInput | boolean
    esClaseSuelta?: BoolFieldUpdateOperationsInput | boolean
    esMesCompleto?: BoolFieldUpdateOperationsInput | boolean
    anulado?: BoolFieldUpdateOperationsInput | boolean
    motivoAnulacion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alumno?: AlumnoUpdateOneWithoutRecibosNestedInput
    concepto?: ConceptoUpdateOneRequiredWithoutRecibosNestedInput
    pagosDeuda?: PagoDeudaUpdateManyWithoutReciboNestedInput
    detallesLiquidacion?: DetalleLiquidacionUpdateManyWithoutReciboNestedInput
    clase?: ClaseUpdateOneWithoutRecibosNestedInput
    reciboAnulado?: ReciboUpdateOneWithoutRecibosAnuladosNestedInput
    recibosAnulados?: ReciboUpdateManyWithoutReciboAnuladoNestedInput
  }

  export type ReciboUncheckedUpdateWithoutAlumnoSueltoInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroRecibo?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEfecto?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    periodoPago?: StringFieldUpdateOperationsInput | string
    tipoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    fueraDeTermino?: BoolFieldUpdateOperationsInput | boolean
    esClaseSuelta?: BoolFieldUpdateOperationsInput | boolean
    esMesCompleto?: BoolFieldUpdateOperationsInput | boolean
    alumnoId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptoId?: IntFieldUpdateOperationsInput | number
    claseId?: NullableIntFieldUpdateOperationsInput | number | null
    anulado?: BoolFieldUpdateOperationsInput | boolean
    motivoAnulacion?: NullableStringFieldUpdateOperationsInput | string | null
    referenciaRecibo?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagosDeuda?: PagoDeudaUncheckedUpdateManyWithoutReciboNestedInput
    detallesLiquidacion?: DetalleLiquidacionUncheckedUpdateManyWithoutReciboNestedInput
    recibosAnulados?: ReciboUncheckedUpdateManyWithoutReciboAnuladoNestedInput
  }

  export type ReciboUncheckedUpdateManyWithoutAlumnoSueltoInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroRecibo?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaEfecto?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: FloatFieldUpdateOperationsInput | number
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    descuento?: NullableFloatFieldUpdateOperationsInput | number | null
    periodoPago?: StringFieldUpdateOperationsInput | string
    tipoPago?: EnumTipoPagoFieldUpdateOperationsInput | $Enums.TipoPago
    fueraDeTermino?: BoolFieldUpdateOperationsInput | boolean
    esClaseSuelta?: BoolFieldUpdateOperationsInput | boolean
    esMesCompleto?: BoolFieldUpdateOperationsInput | boolean
    alumnoId?: NullableIntFieldUpdateOperationsInput | number | null
    conceptoId?: IntFieldUpdateOperationsInput | number
    claseId?: NullableIntFieldUpdateOperationsInput | number | null
    anulado?: BoolFieldUpdateOperationsInput | boolean
    motivoAnulacion?: NullableStringFieldUpdateOperationsInput | string | null
    referenciaRecibo?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaseUpdateWithoutAlumnosSueltosInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profesor?: ProfesorUpdateOneRequiredWithoutClasesNestedInput
    estilo?: EstiloUpdateOneRequiredWithoutClasesNestedInput
    asistencias?: AsistenciaUpdateManyWithoutClaseNestedInput
    recibos?: ReciboUpdateManyWithoutClaseNestedInput
  }

  export type ClaseUncheckedUpdateWithoutAlumnosSueltosInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    profesorId?: IntFieldUpdateOperationsInput | number
    estiloId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asistencias?: AsistenciaUncheckedUpdateManyWithoutClaseNestedInput
    recibos?: ReciboUncheckedUpdateManyWithoutClaseNestedInput
  }

  export type ClaseUncheckedUpdateManyWithoutAlumnosSueltosInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    profesorId?: IntFieldUpdateOperationsInput | number
    estiloId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetalleLiquidacionCreateManyLiquidacionInput = {
    id?: number
    reciboId?: number | null
    montoOriginal: number
    porcentaje: number
    montoLiquidado: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetalleLiquidacionUpdateWithoutLiquidacionInput = {
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    porcentaje?: FloatFieldUpdateOperationsInput | number
    montoLiquidado?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recibo?: ReciboUpdateOneWithoutDetallesLiquidacionNestedInput
  }

  export type DetalleLiquidacionUncheckedUpdateWithoutLiquidacionInput = {
    id?: IntFieldUpdateOperationsInput | number
    reciboId?: NullableIntFieldUpdateOperationsInput | number | null
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    porcentaje?: FloatFieldUpdateOperationsInput | number
    montoLiquidado?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetalleLiquidacionUncheckedUpdateManyWithoutLiquidacionInput = {
    id?: IntFieldUpdateOperationsInput | number
    reciboId?: NullableIntFieldUpdateOperationsInput | number | null
    montoOriginal?: FloatFieldUpdateOperationsInput | number
    porcentaje?: FloatFieldUpdateOperationsInput | number
    montoLiquidado?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}